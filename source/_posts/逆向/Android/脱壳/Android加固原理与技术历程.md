---
title: Android加固原理与技术历程
date: 2020-07-22 18:22:53
categories:
  - 逆向
tags:
	- 逆向
---

# 加固技术发展历程

{% asset_img 加固发展历程.jpg %}

# 动态加载

基于Java虚拟机提供的动态加载技术；Android multidex组件也是这个原理

## 原理

**开发阶段**：将程序切分成加载（Loader）与关键逻辑(Payload）两部分，并分别打包；

{% asset_img 动态加载-开发.jpg %}

**运行时**：Loader会先运行，释放出解密的Payload，动态加载Payload，执行Payload。

{% asset_img 动态加载-启动.jpg %}

### 核心代码

```java
classLoader = new DexPathClassLoader("/sdcard/extra.jar",...):
clazz = classLoader.loadClass("com.test.Action");
```

## 缺陷与对抗

Payload必须解密解压，并且释放到文件系统

攻击者很容易hook获取到完整的解密后的Payload

# 不落地加载

解决了两个关键问题：

- 解密的Payload不落地(释放到文件系统)
	- hook系统IO函数，透明加解密
	- 存内存中
- 对开发零干扰
	- 保护 从 **开发阶段** 延后到 **发布阶段**
	- 只需要在最终发布前进行保护即可

## 不落地

主要的技术方案有两种：

### hook系统IO函数，透明加解密

- Payload释放到文件系统(加密状态)
- hook系统IO函数
	- read
	- write
- 动态加载Payload，执行Payload

跟一代的区别就是落地的Payload是加密状态，通过hook虚拟机系统的IO，使虚拟机读取到解密的Payload(对用户透明)

### 解密Payload存内存中

- 解密的Payload释放到内存
- 调用**虚拟机内部接口**加载Payload
	- dvmDexFileOPenFromFd
	- dvmDexFileOPenFromPartial

跟一代的区别就是解密的Payload是放在内存中的

### 兼容性

hook系统的IO函数(inline 或 got)，带来一定的兼容性问题

需要调用虚拟机系统内部的接口(接口并不导出)，各厂商在实现时有自定义修改，导致该方案存在兼容性问题

## 对开发零干扰

Loader需要处理好Android的组件的生命周期。

{% asset_img 不落地加载-开发零干扰.jpg %}

1）Loader被系统加载。

2）系统初始化Loader内的StubApplication。
 
3）StubApplication解密并且加载原始的DEX文件（Payload）。
 
4）StubApplication从原始的DEX文件（Payload）中找到原始的Application对象，创建并初始化。
 
5）将系统内所有对StubApplication对象的引用使用替换成原始Application，此步骤使用JAVA的反射机制实现。

6）由Android系统进行其他组件的正常生命周期管理。

## 缺陷与对抗

### 缺陷

- 存在兼容性问题
- 在应用启动时要处理大量的加解密加载操作，会造成应用长时间假死（黑屏），用户体验差。

### 对抗

**Payload在内存中连续**，在合适的时机(比如Android的类加载器，必须能找到对应的结构体才能正常执行)，很容易dump内存得到完整Payload(利用gdb等调试工具)

可以简单破坏内存中DEX文件结构(清除DEX文件头，增加一些错误的数据)，提高恢复的成本。

# 指令抽离

第二代加固技术以**文件级别**进行保护，内存中的Payload是连续的，可以被攻击者轻易获取。第三代加固技术对这部分进行了改进，将保护级别降到了**函数级别**。

## 原理

**发布阶段**：将原始DEX内的函数内容(CodeItem)清除，单独移除到一个文件中

{% asset_img 指令抽离-抽离.jpg %}

运行阶段：将函数内容重新恢复到对应的函数体

### 函数内容恢复方案

#### 恢复到DEX壳的内存区域

{% asset_img 指令抽离-恢复到壳内存 %}

#### 恢复到虚拟机内部的结构体上

{% asset_img 指令抽离-恢复到虚拟机内部结构体.jpg %}

虚拟机读取DEX文件后内部每一个函数有一个结构体，这个结构体上有一个指针指向函数内容(CodeItem)，可以通过修改这个指针修改对应的函数内容

#### 拦截虚拟机内查找执行代码函数

返回函数内容

## 兼容性

使用了大量的虚拟内部结构与未被文档化的特性，再加上Android复杂的厂商定制，带来大量的兼容性问题。

## 缺陷与对抗

某些方案与虚拟机的JIT**性能**优化冲突，无法达到最佳的运行性能。

依旧使用了java虚拟机进行函数内容的执行。

攻击者可以通过**自定义Android虚拟机**，在**解释器**的代码上记录一个函数的内容(CodeItem)。接下来遍历触发调用所有函数，从而获取到全部的函数内容。最终重新组装成一个完整的DEX文件。目前已经有自动化工具可以指令抽离技术中脱壳。

# 指令转换/VMP

第三代加固技术在函数级别进行保护，但使用Android虚拟机内的解释器执行代码，带来能被记录的缺陷

第四代加固技术**转换为Native函数**来避免第三代的缺陷。

## 原理

DEX文件内的函数被标记为native，内容被抽离并转换

**转换有两种方案：**

- **转换成动态库**
	- 动态库内通过JNI和Android系统进行交互
- **转换成自定义指令**
	- 使用**自定义解释器**执行。
		- 自定义解释器无法直接调用Android系统内的其他函数，必须通过JNI和Android系统进行交互

## 兼容性

第四代加固技术一般配合第三代加固技术使用，所以也存在第三代的所有兼容性问题

## 缺陷与对抗

必须通过虚拟机提供的JNI接口与虚拟机进行交互，攻击者可以直接将加固方案当作黑盒，通过自定义的JNI接口对象，对黑盒内部进行探测、记录和分析，进而得到完整DEX程序。

另外，第四代VMP加固技术只实现Java代码保护，没有做到使用VMP技术来保护C/C++等代码，安全保护能力有所欠缺

# 虚机源码保护

用虚机技术保护所有的代码，包括Java，Kotlin，C/C++，Objective-C，Swift等多种代码，具备极高的兼容性；使App得到更高安全级别的保护，运行更加稳定。

## 原理

虚机源码保护为用户提供一套完整的工具链，首先把用户待保护的核心代码编译成中间的二进制文件，随后生成独特的虚机源码保护执行环境和只能在该环境下执行的运行程序。
 
虚机源码保护会在App内部隔离出独立的执行环境，该核心代码的运行程序在此独立的执行环境里运行。即便App本身被破解，这部分核心代码仍然不可见。

{% asset_img 虚机源码保护.jpg %}

## 对抗优势

生成的虚机源码保护拥有独特的可变指令集，极大的提高了指令跟踪、逆向分析的难度。同时，虚机源码保护还提供了反调试能力和监控能力。虚机源码保护可以通过自身的探针感知到环境的变化，实时探测到外界对本环境的调试、注入等非正常执行流程变化，将调试动作引入程序陷阱，并发出警报，进而进行实时更新，提高安全强度。

# 参考&扩展

- [Android App加固原理与技术历程](https://bbs.pediy.com/thread-260124.htm)