---
title: 线程锁
date: 2019-03-27 15:44:53
categories:
  - Java
tags: 
	- Java
---

[Java中锁分类](https://www.cnblogs.com/qifengshi/p/6831055.html)

# 乐观锁/悲观锁 #

区别在于看待并发同步的角度/态度。

**悲观锁**认为对于同一个数据的并发操作，一定是会发生修改的，不加锁的并发操作一定会出问题。

- 适合写操作非常多的场景
- 悲观锁在Java中的使用，就是利用各种锁。

**乐观锁**则认为对于同一个数据的并发操作，是不会发生修改的，不加锁的并发操作是没有问题的。

- 适合读操作非常多的场景
- 乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。

# 公平锁/非公平锁 #

**公平锁**是指多个线程按照申请锁的顺序来获取锁。

**非公平锁**是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。

`ReentrantLock(Re entrant Lock)`，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。通过AQS(AbstractQueuedSynchronizer)实现线程调度

`Synchronized`，非公平锁。

# 可重入锁 #

又名递归锁，是指同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。

可重入锁的一个好处是可一定程度避免死锁。

`ReentrantLock` `Synchronized`,都是可重入锁。

	synchronized void setA() throws Exception{
	    Thread.sleep(1000);
	    setB();
	}
	
	synchronized void setB() throws Exception{
	    Thread.sleep(1000);
	}

	如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁。

# 独享锁/共享锁 #

**独享锁**是指该锁一次只能被一个线程所持有。

**共享锁**是指该锁可被多个线程所持有。

独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。

`ReentrantLock`，独享锁。

`Synchronized`，独享锁。

`ReadWriteLock`，读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。

# 互斥锁/同步锁/读写锁 #

上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。

**互斥锁**：两个线程不能同时运行，一个线程运行完毕，另一个才能运行

- 具有唯一性和排它性
- 无序

**同步锁**：也是不能同时运行，但是必须安照某种次序来运行

- 一种特殊互斥
- 互斥的基础上
- 有序访问

**读写锁**:

1）多个读者可以同时进行读  
2）写者必须互斥（只允许一个写者写，也不能读者写者同时进行）  
3）写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）  

# 分段锁 #

其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。
我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。
当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。
但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。
分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。

# 偏向锁/轻量级锁/重量级锁 #

这三种锁是指锁的状态，并且是针对Synchronized。

Java 5通过引入锁升级的机制来实现高效Synchronized。

这三种锁的状态是通过 `对象监视器在对象头中的字段` 来表明的。

**偏向锁**是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。

**轻量级锁**是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。

**重量级锁**是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

# 自旋锁 #

自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环(jvm默认是10次)的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。

自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时 才能进入临界区。如下


	public class SpinLock {
	
	  private AtomicReference<Thread> sign =new AtomicReference<>();
	
	  public void lock(){
	    Thread current = Thread.currentThread();
	    while(!sign .compareAndSet(null, current)){
	    }
	  }
	
	  public void unlock (){
	    Thread current = Thread.currentThread();
	    sign .compareAndSet(current, null);
	  }
	}

使用了CAS原子操作，lock函数将owner设置为当前线程，并且预测原来的值为空。unlock函数将owner设置为null，并且预测值为当前线程。

当有第二个线程调用lock操作时由于owner值不为空，导致循环一直被执行，直至第一个线程调用unlock函数将owner设置为null，第二个线程才能进入临界区。

由于自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。如果线程竞争不激烈，并且保持锁的时间短，适合使用自旋锁。
