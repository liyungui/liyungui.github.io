---
title: 内存模型JVM和volatile
date: 2019-03-27 15:48:53
categories:
  - Java
tags: 
	- Java
---
	
	volatile 英[ˈvɒlətaɪl] 易变的，不稳定的;
# Java内存模型JMM(Java Memory Mode) #

1. **原子性**

	操作**不可被中断**。即使多线程并发，操作不会被其他线程干扰

	例如为int i 赋值，32位系统能保证该操作具有原子性，不会出现对一个线程赋值了i的高16位，另一个线程赋值i的低16位
	
	但是，long l 赋值，32位操作系统该操作需要两步，就不具备原子性。

	最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了

	**对基本数据类型的读取和赋值操作是原子性操作**

	
		x = 10;         //原子性
		y = x;         //两个操作，读x，将x赋值给y
		x++;           //x = x + 1;三个操作，读x，+1，赋值给x

	**原子操作类**

	java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，保证这些操作是原子性操作。如 AtomicInteger

	即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装

	atomic是利用CAS(Compare And Swap)来实现原子性操作的，CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。

2. **可见性**

	一个线程修改了变量的值，其他线程能够**立即看到**修改的值

	产生问题原因：

	1. 编译器优化
	2. 缓存优化(将变量缓存在CPU cache或寄存器里)
	3. 硬件优化(部分内存读写不立即触发，而先进入硬件队列等待)
	4. 指令重排

	可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值

3. **有序性**

	程序执行的**顺序**按照代码的先后顺序执行

	有序性问题是三个问题中**最难理解**的

	产生问题原因：

	- 指令重排

	Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性

	Java内存模型具备一些先天的“有序性”，即 **happens-before原则（先行发生原则）**：

		程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
		锁定规则：unLock操作先行发生于后面对同一个锁lock操作
		volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
		传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
		线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
		线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
		线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
		对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法

**synchronized**和**Lock**

- 保证原子性

- 保证可见性
	
	synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。

- 保证有序性

**volatile**

- 保证可见性

	保证变量修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值

- 保证一定的“有序性”

volatile无法保证对变量的任何操作都是原子性的

volatile关键字的两层语义：

1）保证了不同线程对这个变量进行操作时的可见性。

2）禁止进行指令重排序。

**使用volatile必须具备2个条件**

- 对变量的写操作不依赖于当前值

- 该变量没有包含在具有其他变量的不变式中

**使用volatile关键字的场景**

- 状态标记量

- double check
