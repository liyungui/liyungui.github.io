---
title: 播放器技术二-缓冲区管理
date: 2019-09-17 16:12:14
categories:
  - 直播
tags:
  - 直播
---

# 缓冲区

在上一篇文章中，我们利用缓冲区把单线程模型的数据流改造为多线程模型，从而可以有效抵抗网络和解码的抖动，防止频繁卡顿，同时也能充分利用多核 CPU 的计算能力，如下图所示：

{% asset_img 单线程多线程对比.png %}

# 缓冲区的作用

## 帧缓冲区

“读线程”和“解码线程”之间的缓冲池

它主要起到了三个作用：

1. 抵抗网络抖动。

	单线程无缓冲区，IO卡顿会卡住Decoder

2. 抵抗解码抖动。

	单线程无缓冲区，Decoder卡顿会卡住IO

3. 避免被动丢帧导致花屏。

	单线程无缓冲区，IO卡顿，服务端的 TCP 协议栈缓存了较多的数据，TCP 发送队列爆满而产生被动丢帧；
	
	网络恢复，下发到客户端，数据不完整导致解码花屏

## 显示缓冲区

“解码线程”和“显示线程”之间的缓冲池

它主要起到了两个作用：

1. 实现 “音画同步” 的必要条件

	单线程无缓冲区，Decoder完直接渲染，无法添加音画同步逻辑
	
2. 抵抗渲染抖动

	单线程无缓冲区，Render卡顿会卡住Decoder
	
# 缓冲区的数据填充方式

“主动缓冲” 与 “被动缓冲”	

## 主动缓冲

播放器**主动暂停消费**缓冲区的数据，等待数据生产者逐渐填充数据，直到达到某种条件再恢复

多用于**点播场景**

为了降低频繁卡顿，在开始播放视频之前，会主动 buffering 一段时间（比如：10s）的数据，再开始播放。当缓冲区内的数据因为网络抖动等原因消耗完了，会再次启动 buffering，如此循环。

{% asset_img 主动缓冲.png %}

如图所示，假设播放器缓冲区内的数据低于 Low 这个水位点后，会主动暂停播放，启动 buffering 过程直到缓冲区中的数据达到 M 水位值。

## 被动缓冲

播放器对缓冲区数据的**消费速度赶不上生产速度**，从而被动滞留了数据在缓冲区中

多出现在**直播场景**

可能有 2 种原因：

1. 设备**解码性能不足**

	比如软解 1080P 的高清视频，导致视频的解码和渲染的速度赶不上视频的读取速度，导致数据堆积在“帧缓冲区”

2. **网络抖动**频繁

	客户端无法及时拿到数据进行解码渲染，当网络恢复后，数据会迅速下发下来，但播放器已没有办法再快速消费掉（因为播放的速率是固定的，除非添加追帧的逻辑，后续文章会详细介绍）

# 缓冲区的大小

理解了缓冲区的作用，那这两个缓冲区的大小如何制定呢 ？

首先，我们需要知道这两个缓冲区大小究竟影响或者决定了什么 ？

## 缓冲区大小的影响

1. 缓冲区越大 -> **抗抖动能力**越强

2. 缓冲区越大 -> **内存占用**越高

3. 缓冲区越大 -> **播放延时**越大

由此可见，缓冲区也不是越大越好，需要根据实际的**使用场景来决定**。

## 缓冲区大小的策略

### 帧缓冲区

可以抵抗网络抖动，网络抖动往往是比较频繁的，抖动的时间也有时会比较久一些，所以相对要设置得**大**一点，但以不过于影响内存和播放延时为前提。

对于直播场景，为了防止 “被动丢帧”，往往 “帧缓冲区” 默认是设置为 “无限大” 的，当检测到缓冲区达到一定阈值后，启动一些诸如主动丢帧或者倍数播放的方式，来快速消耗掉缓冲的内容，从而降低内存和延时。

### 显示缓冲区

解码和渲染的抖动并不频繁，所以并不需要特别大的缓冲区，最低 **3 帧**左右即可，一帧在生产，一帧在消费，还有一帧在缓冲区中待命。

# 缓冲区主动清空	

有如下几种场景，播放器会主动清空缓冲区内的数据：

1. 播放器重置

2. 播放进度条被拖动

3. 消除累积延时

4. 系统内存告警

# IJKPlayer 的缓冲区管理

```c
// ff_ffplay_def.h
#define DEFAULT_HIGH_WATER_MARK_IN_BYTES        (256 * 1024)

/*
 * START: buffering after prepared/seeked
 * NEXT:  buffering for the second time after START
 * MAX:   ...
 */
#define DEFAULT_FIRST_HIGH_WATER_MARK_IN_MS     (100)
#define DEFAULT_NEXT_HIGH_WATER_MARK_IN_MS      (1 * 1000)
#define DEFAULT_LAST_HIGH_WATER_MARK_IN_MS      (5 * 1000)
```

ijkplayer 使用非常广泛，这里以它为例看看播放器缓冲区的真实案例是怎么样的 ？

1. 播放器首次打开，缓冲 100ms，再开始播放

2. 遇到了卡顿（缓冲区为空），则暂停播放，缓冲到 1000ms，再开始播放

3. 再次遇到卡顿，则缓冲时间增加 1000ms，依次类推，直到 5000ms
 
它的缓冲区的**最大阈值是逐步递增**上去的，这是一个**非常棒**的用户体验优化，因为如果用户网络不是那么差的话，不用第一次缓冲就等 5s 了

# 参考&扩展

- [播放器技术分享（2）：缓冲区管理](https://blog.51cto.com/ticktick/2326207) 七牛-卢俊
