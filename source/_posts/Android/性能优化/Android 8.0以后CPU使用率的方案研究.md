---
title: Android 8.0以后CPU使用率的方案研究
date: 2019-09-28 15:43:53
categories:
  - Android
tags:
  - 性能优化
---

# 背景

Android 8.0以后Google的权限限制，再也拿不到进程CPU的实时占用率，只能拿到自己本身进程的Jiffies，但是又拿不到系统整体Jiffies的情况下，就没办法衡量CPU当前的消耗状况了，也没办法根据当前CPU状态实时做一些策略调整。

因此进行深入研究以后，给出Android 8.0以后判断CPU状态的几个参考方案（非标准答案）。

# 单位时间执行汇编指令数获取CPU频率

## 基础概念

### Jiffies

全局变量jiffies用来记录自系统启动以来产生的节拍的总数。

启动时，内核将该变量初始化为0，此后，每次时钟中断处理程序都会增加该变量的值。

一秒内时钟中断的次数等于Hz，所以jiffies一秒内增加的值也就是Hz。

### Tick

HZ的倒数，意即timer interrupt每发生一次中断的时间。如HZ为250时，tick为4毫秒。

## 思路

- 一条原子化操作汇编指令（比如 add），在任意型号CPU上是都是在一个时钟周期内完成的
- 连续执行n条 add指令
- 循环20次，取出花费时间最小的那轮时间 min_time_s
	- 取最小值，而不是平均值；是因为CPU时刻在动态调整频率，各CPU调整策略各不相同。
	- 使用最小值，可以避免CPU调频导致的误差
	- 执行次数越多，CPU频率越准确，但也耗时越久。取一个平衡点
- 每条指令耗时 cos = min_time_s/n;
- cpu频率 freq = 1/cos;也就是单位时间（s）内执行cycles的数量

## 总结

反应整机CPU繁忙程度；不能很好的反应当前应用APP所在CPU核心的繁忙程度

# 在代码内部执行TOP获取CPU占比

TOP本身是有权限拿到 `/proc/stat` 后统计的

TOP整体来说是比较准确的，耗时太大，资源消耗也大；

# 读取`/proc/$pid/stat` 的Jiffies值

准确判断当前进程的性能消耗；无法反应整机CPU繁忙程度

# 读取CPU各个核的当前频率

## 思路

CPU的频率档位是离散的(不连续)，Android为了Linux系统稳定运行，会对几个核锁频。

计算CPU的频率有下面几个步骤：

1）拿到各个核心的当前频率

2）拿到CPU的频率档位

3）解析当前进程/线程被系统分派到哪几个核上

## 总结

可以实时反应当前设备以及进程所在CPU核的繁忙程度

# 任务调度延迟时间

## 思路

开个线程测试两次调度的延迟时间；这个相对指标用来反映系统的繁忙程度。这个值20ms以下，意味着较为流畅；80ms以上，非常繁忙；

## 延迟时间的计算

比如一个每秒调度一次的线程；发现两次调度的时间差为1100ms，这个延迟即为100ms

下面的日志是 80% cpu使用率时，延迟>20ms的时间戳

```
2019-09-28 15:32:51.098 20418-20979/com.zy.course.dev I/time:  122
2019-09-28 15:33:01.350 20418-20979/com.zy.course.dev I/time:  240
2019-09-28 15:34:12.473 20418-20979/com.zy.course.dev I/time:  45
2019-09-28 15:36:47.727 20418-20979/com.zy.course.dev I/time:  23
2019-09-28 15:36:52.767 20418-20979/com.zy.course.dev I/time:  35
2019-09-28 15:37:11.816 20418-20979/com.zy.course.dev I/time:  26
2019-09-28 15:38:41.957 20418-20979/com.zy.course.dev I/time:  28
2019-09-28 15:38:47.986 20418-20979/com.zy.course.dev I/time:  29
2019-09-28 15:39:22.134 20418-20979/com.zy.course.dev I/time:  87
2019-09-28 15:39:49.226 20418-20979/com.zy.course.dev I/time:  48
2019-09-28 15:40:33.382 20418-20979/com.zy.course.dev I/time:  50
2019-09-28 15:40:37.383 20418-20979/com.zy.course.dev I/time:  29
2019-09-28 15:41:19.569 20418-20979/com.zy.course.dev I/time:  64
2019-09-28 15:41:26.621 20418-20979/com.zy.course.dev I/time:  29
```

观察发现，并不是每次调度都会延迟，有可能2分钟内，调度延迟都是正常的

所以，为了直观反映CPU繁忙程度，需要对延迟进行聚合，取最高的延迟值；

# 参考&扩展

- [Android 8.0以后CPU使用率的方案研究](https://cloud.tencent.com/developer/article/1427843) 