<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="随心而动，随刃而行">
<meta property="og:type" content="website">
<meta property="og:title" content="风">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="风">
<meta property="og:description" content="随心而动，随刃而行">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="风">
<meta name="twitter:description" content="随心而动，随刃而行">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/5/"/>





  <title>风</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">风</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">技术博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/24/AndroidManifest合并原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/24/AndroidManifest合并原理/" itemprop="url">AndroidManifest合并原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-24T18:44:53+08:00">
                2018-05-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://mouxuejie.com/blog/2016-02-05/androidmanifest-merge/" target="_blank" rel="noopener">ss</a></p>
<p><a href="https://developer.android.com/studio/build/manifest-merge?hl=zh-cn" target="_blank" rel="noopener">啊啊</a></p>
<p>APK 只能包含一个 AndroidManifest.xml 文件，但 Android Studio 项目可以包含多个文件（通过主源集、构建变体和导入的库提供）。因此，在构建应用时，Gradle 构建会将所有清单文件合并到一个清单文件中。</p>
<p>清单合并工具通过遵循某些<strong>合并冲突启发式算法</strong>，和 <strong>合并首选项</strong>(通过特殊 XML 属性定义)，来合并各个文件中的所有 XML 元素 。</p>
<h1 id="合并优先级"><a href="#合并优先级" class="headerlink" title="合并优先级"></a>合并优先级</h1><p><strong>从优先级最低的文件合并至优先级最高的文件</strong></p>
<img src="/2018/05/24/AndroidManifest合并原理/manifest-merger_priority.png">
<h2 id="库清单文件"><a href="#库清单文件" class="headerlink" title="库清单文件"></a>库清单文件</h2><p>多个库，则其清单优先级与依赖顺序（库出现在 Gradle dependencies 块中的顺序，由高到低）匹配</p>
<h2 id="构建变体"><a href="#构建变体" class="headerlink" title="构建变体"></a>构建变体</h2><p>变体有多个源集，则其清单优先级如下(由高到低)：</p>
<ul>
<li>构建变体清单（如 src/demoDebug/）</li>
<li>构建类型清单（如 src/debug/）</li>
<li>产品定制清单（如 src/demo/）</li>
</ul>
<p>如果使用的是定制维度，清单优先级将与每个维度在 flavorDimensions 属性中的列示顺序(由高到低)对应。</p>
<h1 id="合并冲突启发式算法"><a href="#合并冲突启发式算法" class="headerlink" title="合并冲突启发式算法"></a>合并冲突启发式算法</h1><h2 id="默认合并规则"><a href="#默认合并规则" class="headerlink" title="默认合并规则"></a>默认合并规则</h2><img src="/2018/05/24/AndroidManifest合并原理/merge.png">
<h3 id="编码原则：不依赖于默认属性值"><a href="#编码原则：不依赖于默认属性值" class="headerlink" title="编码原则：不依赖于默认属性值"></a>编码原则：不依赖于默认属性值</h3><p>高优先级清单实际上依赖于属性的默认值而不需要声明，则可能会导致意外结果。</p>
<p>例如，高优先级清单不声明android:launchMode 属性，则会使用 “standard” 的默认值；但如果低优先级清单声明此属性具有其他值，该值将应用于合并清单（替代默认值）。因此，您应该按期望明确定义每个属性。（每个属性的默认值都会记录在 <a href="https://developer.android.com/guide/topics/manifest/manifest-intro?hl=zh-cn" target="_blank" rel="noopener">Manifest reference</a> 中）。</p>
<h2 id="合并工具为减少合并冲突的特殊规则"><a href="#合并工具为减少合并冲突的特殊规则" class="headerlink" title="合并工具为减少合并冲突的特殊规则"></a>合并工具为减少合并冲突的特殊规则</h2><ul>
<li><code>&lt;manifest&gt;</code>元素的属性绝不合并—仅使用优先级最高的清单中的属性。</li>
<li><code>&lt;uses-feature&gt;</code>元素 <code>&lt;uses-library&gt;</code>元素<code>android:required</code>属性 使用 <strong>OR</strong> 合并，因此如果出现冲突，系统将应用 “true” 并始终包括某个清单所需的功能或库。</li>
<li><code>&lt;uses-sdk&gt;</code>元素始终使用较高优先级的清单中的值，但以下情况有些特殊：<ul>
<li>minSdkVersion，低优先级清单的值 较高<ul>
<li>默认，使用 低优先级清单的值</li>
<li>应用 overrideLibrary 合并规则，使用 较高优先级的清单中的值</li>
</ul>
</li>
<li>targetSdkVersion，低优先级清单的值 较低<ul>
<li>合并工具将使用高优先级清单中的值</li>
<li>但也会添加任何必要的系统权限，以确保所导入的库继续正常工作<ul>
<li>适用于 较高的 Android 版本需要更多权限限制的情况。 如需了解有关此行为的详细信息，请参阅有关隐式系统权限的部分。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>&lt;intent-filter&gt;</code>元素。 每个元素都被视为唯一元素，直接添加至合并清单中的常用父元素。</li>
</ul>
<h1 id="合并规则标记"><a href="#合并规则标记" class="headerlink" title="合并规则标记"></a>合并规则标记</h1><ul>
<li>是什么：是一个 XML 属性</li>
<li>作用：标记如何解决合并冲突和属性的首选项</li>
<li>作用域：整个元素或元素的特定属性</li>
<li>合并工具会在高优先级清单文件中寻找这些标记</li>
<li>所有标记均属于 Android <code>tools</code> 命名空间，必须先在 <code>&lt;manifest&gt;</code>元素中声明此命名空间</li>
</ul>
<h2 id="元素-节点标记"><a href="#元素-节点标记" class="headerlink" title="元素/节点标记"></a>元素/节点标记</h2><p><strong>tools:node=”xx”</strong></p>
<ul>
<li><strong>merge</strong> <ul>
<li>元素的默认行为</li>
<li>合并所有属性以及所有嵌套元素。 例如：<code>&lt;activity&gt;</code> 嵌套 <code>&lt;intent-filter&gt;</code></li>
</ul>
</li>
<li><strong>merge-only-attributes</strong><ul>
<li>仅合并属性，不合并嵌套元素</li>
</ul>
</li>
<li><strong>remove</strong></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/24/Android系统版本适配/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/24/Android系统版本适配/" itemprop="url">Android系统版本适配</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-24T18:40:36+08:00">
                2018-05-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="FileProvider替代file-Uri"><a href="#FileProvider替代file-Uri" class="headerlink" title="FileProvider替代file://Uri"></a>FileProvider替代file://Uri</h1><p>不再允许在app中把file://Uri暴露给其他app，包括但不局限于通过Intent或ClipData 等方法</p>
<p>Android7 提供了FileProvider，使用它生成content://Uri来替代file://Uri。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>使用file://Uri会有一些风险，比如：</p>
<ul>
<li>文件是私有的，接收file://Uri的app无法访问该文件。</li>
<li>Android6.0引入运行时权限，如果接收file://Uri的app没有申请READ_EXTERNAL_STORAGE权限，在读取文件时会引发崩溃。</li>
</ul>
<h2 id="FileProvider"><a href="#FileProvider" class="headerlink" title="FileProvider"></a>FileProvider</h2><p>manifest application节点下</p>
<pre><code>&lt;provider
    android:authorities=&quot;${applicationId}.fileProvider&quot;
    android:exported=&quot;false&quot;
    android:grantUriPermissions=&quot;true&quot;&gt;
    &lt;meta-data
        android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;
        android:resource=&quot;@xml/provider_paths&quot;/&gt;
&lt;/provider&gt;
</code></pre><p>res/xml/provider_paths.xml 指定路径和转换规则</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;files-path name=&quot;cache_pdf&quot; path=&quot;cache/pdf/&quot;/&gt;
    &lt;external-files-path name=&quot;external_cache_pdf&quot; path=&quot;cache/pdf/&quot;/&gt;
    &lt;external-path name=&quot;external_image&quot; path=&quot;zywx/image/&quot;/&gt;
&lt;/paths&gt;
</code></pre><p>代码</p>
<pre><code>//Uri photoOutputUri = Uri.fromFile(photoOutputFile);
Uri photoOutputUri = FileProvider.getUriForFile(
                    mContext,
                    mActivity.getPackageName() + &quot;.fileprovider&quot;,
                    photoOutputFile);
            intent.putExtra(MediaStore.EXTRA_OUTPUT, photoOutputUri);
</code></pre><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>android.support.v4.content.FileProvider 类只可以在manifest中注册一次。就如同一个Activity只可以注册一次一样</p>
<pre><code>Error:
    Element provider#android.support.v4.content.FileProvider at AndroidManifest.xml:119:9-131:20 duplicated with element declared at AndroidManifest.xml:105:9-117:20
</code></pre><p>一些第三方sdk为了适配android 7 也添加了这个节点</p>
<p>解决方案：</p>
<ul>
<li>自定义类 继承自FileProvider</li>
<li>使用合并规则替换resource为我们的xml，然后把第三方sdk中的路径配置copy到provider_paths.xml<ul>
<li>如果 authorities 不一致，就是利用合并规则替换了，也会报错。因为第三方库java代码大概率写死了 authorities。<ul>
<li>代码不要写死 authorities，从manifest动态获取</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul>
<li><p>FileUriExposedException</p>
<pre><code>android.os.FileUriExposedException: file:///storage/emulated/0/Android/data/com.zy.course.dev/1467180514061025%23kefuchannelapp54752/test_22616/video/1527152182117.mp4 exposed beyond app through Intent.getData()
    at android.os.StrictMode.onFileUriExposed(StrictMode.java:1799)
    at android.net.Uri.checkFileUriExposed(Uri.java:2346)
</code></pre><ul>
<li>解决方案：使用FileProvider代替Uri.fromFile</li>
</ul>
</li>
</ul>
<ul>
<li>java.lang.SecurityException: Provider must not be exported<ul>
<li>解决方案：android:exported必须设置成false</li>
</ul>
</li>
</ul>
<ul>
<li>Attempt to invoke virtual method ‘android.content.res.XmlResourceParser android.content.pm.PackageItemInfo.loadXmlMetaData(android.content.pm.PackageManager, java.lang.String)’ on a null object reference<ul>
<li>解决方案：AndroidManifest.xml处的android:authorities必须跟 mActivity.getPackageName() + “.fileProvider” 一样</li>
</ul>
</li>
</ul>
<h1 id="AlarmManager"><a href="#AlarmManager" class="headerlink" title="AlarmManager"></a>AlarmManager</h1><h2 id="定时任务的最佳实践"><a href="#定时任务的最佳实践" class="headerlink" title="定时任务的最佳实践"></a>定时任务的最佳实践</h2><ul>
<li>Handler 依赖于 Handler 所在的线程的，如果线程结束，就起不到定时任务的效果；</li>
<li>Timer 手机关屏后长时间不使用，CPU 就会进入休眠模式。Timer 无法唤醒 CPU，定时任务就会失败</li>
<li>AlarmManager 依赖 Android 系统服务，具备唤醒机制</li>
</ul>
<p>AlarmManager实质是一个全局的定时器，是Android中常用的一种系统级别的提示服务，在指定时间或周期性发送<code>PendingIntent</code>广播  启动其它组件（包括Activity,Service,BroadcastReceiver）</p>
<h2 id="版本适配"><a href="#版本适配" class="headerlink" title="版本适配"></a>版本适配</h2><p>查阅 <a href="https://developer.android.google.cn/about/versions/android-4.4" target="_blank" rel="noopener">Android官网中关于 Android 4.4 变更</a>发现Google 为了追求系统省电，<code>set()</code> 或 <code>setRepeating()</code> 创建的闹铃将变得不准确。还要追求精准的闹钟定时任务，要使用 <code>setExact()</code> 方法</p>
<p><a href="https://developer.android.google.cn/about/versions/marshmallow/android-6.0-changes" target="_blank" rel="noopener">查阅 Android官网中关于 Android 6.0 变更</a> ，发现在 Android 6.0 中引入了低电耗模式和应用待机模式，标准 AlarmManager 闹铃（包括 <code>setExact()</code> 和 <code>setWindow()</code>）推迟到下一维护时段。<br>如果您需要设置在低电耗模式下触发的闹铃，请使用 <code>setAndAllowWhileIdle()</code> 或 <code>setExactAndAllowWhileIdle()</code>。触发闹铃的时间间隔都不能超过 9 分钟</p>
<pre><code>public static void setAlarmTimer(Context context, long triggerAtMillis,
                                 String action, int AlarmManagerType, int alarmId, String tutorTeacherName) {
    Intent myIntent = new Intent();
    myIntent.putExtra(&quot;tutorTeacherName&quot;, tutorTeacherName);//闹铃广播可以传递数据
    myIntent.setAction(action);
    PendingIntent pendingIntent = PendingIntent.getBroadcast(context, alarmId, myIntent, 0);
    AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);

    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {
        alarmManager.setExactAndAllowWhileIdle(AlarmManagerType, triggerAtMillis, pendingIntent);
    } else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
        alarmManager.setExact(AlarmManagerType, triggerAtMillis, pendingIntent);
    } else {
        alarmManager.set(AlarmManagerType, triggerAtMillis, pendingIntent);
    }
}

public static void cancelAlarmTimer(Context context, String action) {
    Intent myIntent = new Intent();
    myIntent.setAction(action);
    PendingIntent sender = PendingIntent.getBroadcast(context, 0, myIntent, 0);
    AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
    alarm.cancel(sender);
}
</code></pre><p>广播接收者接收闹铃广播</p>
<pre><code>public class AlarmReceiver extends BroadcastReceiver {
    public final static String TIMER_ACTION_REPEATING = &quot;com.shensz.TIMER_ACTION_REPEATING&quot;;// 周期性的闹钟
    public final static String TIMER_ACTION = &quot;com.shensz.TIMER_ACTION&quot;;// 定时闹钟

    @Override
    public void onReceive(Context context, Intent intent) {
        if (intent.getAction().equals(TIMER_ACTION_REPEATING)) {
        } else if (intent.getAction().equals(TIMER_ACTION)) {
            String tutorTeacherName = intent.getStringExtra(&quot;tutorTeacherName&quot;);
            if (!TextUtils.isEmpty(tutorTeacherName)) {
                sendNotification(context, tutorTeacherName);
            }
        }
    }

}
</code></pre><p>注册广播接收者</p>
<pre><code>    &lt;receiver android:name=&quot;com.shensz.course.module.main.AlarmReceiver&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;com.shensz.TIMER_ACTION_REPEATING&quot; /&gt;
        &lt;action android:name=&quot;com.shensz.TIMER_ACTION&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
</code></pre><h2 id="int-type-和-long-triggerAtMillis"><a href="#int-type-和-long-triggerAtMillis" class="headerlink" title="int type 和 long triggerAtMillis"></a>int type 和 long triggerAtMillis</h2><p>这个需要注意文档的描述。不留神triggerAtMillis没有加上基准时间(根据type而不同)，就会发现广播都是马上触发(因为触发时间已过，所以马上发送广播)</p>
<p>type：闹钟类型</p>
<ul>
<li>ELAPSED_REALTIME：<ul>
<li>在指定的延时过后，发送广播，但不唤醒设备（闹钟在睡眠状态下不可用）。如果在系统休眠时闹钟触发，它将不会被传递，直到下一次设备唤醒。</li>
<li>延时是要把系统启动到现在的时间SystemClock.elapsedRealtime()(基准时间)算进去的。</li>
</ul>
</li>
<li>ELAPSED_REALTIME_WAKEUP：<ul>
<li>同上，唯一区别就是 会唤醒设备</li>
</ul>
</li>
<li>RTC：<ul>
<li>当系统调用System.currentTimeMillis()方法返回的值等于triggerAtTime时，发送广播，但不唤醒设备。<ul>
<li>可以设置系统时间触发闹铃广播</li>
</ul>
</li>
</ul>
</li>
<li>RTC_WAKEUP：<ul>
<li>同上，唯一区别就是 会唤醒设备</li>
</ul>
</li>
<li>POWER_OFF_WAKEUP：<ul>
<li>闹钟在手机关机状态下也能正常进行提示功能，所以是5个状态中用的最多的状态之一</li>
<li>该状态下闹钟也是用绝对时间，状态值为4；不过本状态好像受SDK版本影响，某些版本并不支持。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre><code>AlarmManager.RTC，System.currentTimeMillis()+10 * 60 * 1000
AlarmManager.ELAPSED_REALTIME，SystemClock.elapsedRealtime()+10 * 60 * 1000
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/Android逆向/Android-Hook/Android-dalvik-hook原理与实现/Android-dalvik-hook原理与实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/Android逆向/Android-Hook/Android-dalvik-hook原理与实现/Android-dalvik-hook原理与实现/" itemprop="url">Android dalvik hook原理与实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T16:44:42+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://bbs.pediy.com/showthread.php?t=187522&amp;highlight=dalvik+hook" target="_blank" rel="noopener">Android dalvik hook的另外一种实现形式</a> </p>
<p><a href="http://bbs.pediy.com/showthread.php?t=186054" target="_blank" rel="noopener">注入安卓进程,并hook java世界的方法</a> </p>
<h1 id="替换方法实现–修改Method对象的insns字段"><a href="#替换方法实现–修改Method对象的insns字段" class="headerlink" title="替换方法实现–修改Method对象的insns字段"></a>替换方法实现–修改Method对象的insns字段</h1><p>dalvik中，每一个java方法都有一个对应的Method对象（Method结构体声明在源码目录树下的dalvik/vm/oo/Object.h文件内）</p>
<p>Method结构体字段insns保存着java方法具体的实现代码。</p>
<p>下面用代码实现说明</p>
<pre><code>public class HelloJni extends Activity {
    static {
        System.loadLibrary(&quot;hello-jni&quot;);
    }

    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        TextView tv = new TextView(this);
        tv.setText(truth());
        setContentView(tv);
    }

    public String truth() {
        return &quot;hello from truth&quot;;
    }

    public String fake() {
        return &quot;fake string&quot;;
    }

}
-----------------------c code --------------------
#include &lt;string.h&gt;
#include &lt;jni.h&gt;

jint JNI_OnLoad(JavaVM* vm, void* reserved) {
    JNIEnv *env;

    if ((*vm)-&gt;GetEnv(vm, (void**) &amp;env, JNI_VERSION_1_6) != 0) {
        return -1;
    }
    jclass father = (*env)-&gt;FindClass(env, &quot;com/example/hellojni/HelloJni&quot;); //搜索java类

    jmethodID truthMethod = (*env)-&gt;GetMethodID(env, father, &quot;truth&quot;, &quot;()Ljava/lang/String;&quot;); //搜索java方法
    jmethodID fakeMethod = (*env)-&gt;GetMethodID(env, father, &quot;fake&quot;, &quot;()Ljava/lang/String;&quot;);

    // jmethodID 是一个ClassObject 的指针类型，
    // ClassObject 对象的偏移地址32位处为insns字段。
    *(int *) ((int) truthMethod + 32) = *(int *) ((int) fakeMethod + 32);

    int result = JNI_OK;
    return ((result != JNI_OK) ? result : JNI_VERSION_1_6);
}
</code></pre><h1 id="替换方法为native方法–native方法替换java方法"><a href="#替换方法为native方法–native方法替换java方法" class="headerlink" title="替换方法为native方法–native方法替换java方法"></a>替换方法为native方法–native方法替换java方法</h1><p>正常情况下,只能在Java世界通过jni调用native方法,而native不能在没有任何java上的支持下干涉java世界。</p>
<p>传统的linux进程注入技术在安卓上只能进入目标进程的native世界。</p>
<p>本教程是要注入别的进程,并hook java世界的java 方法!</p>
<p>程序大致的流程是这样的：</p>
<pre><code>so.so注入到目标进程 --&gt; 执行Hook()函数 
                  --&gt; Hook()加载libTest.so,获取libTest.so定义的Hook信息.接着用ClassMethodHook()hook java世界的方法.
</code></pre><p>  关键一,从native世界进入java世界。我们只要获得一个JNIEnv就能进入到java世界了。突破点就在android::AndroidRuntime::getJavaVM();这个静态方法能够获取一个JavaVM,JavaVM-&gt;GetEnv方法能够获得一个JNIEnv了。JNIEnv是和线程相关的,使用前一定记得将其附加到当前进程,也要在适当的时候将其销毁。</p>
<p>  关键二,怎么影响内存里的java代码。替换内存是不现实的,但是可以取巧，在运行时将一个不是native的方法修改成native方法。我们知道java代码里将一个方法声明为native方法时,对此函数的调用就会到native世界里找。</p>
<h1 id="两种方法的比较"><a href="#两种方法的比较" class="headerlink" title="两种方法的比较"></a>两种方法的比较</h1><table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">替换方法实现</th>
<th style="text-align:left">替换方法为native方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">难度</td>
<td style="text-align:left">容易，只要修改insns字段</td>
<td style="text-align:left">难，多个字段</td>
</tr>
<tr>
<td style="text-align:left">线程安全</td>
<td style="text-align:left">安全</td>
<td style="text-align:left">非安全，修改字段过多</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/Android逆向/Android-Hook/android-hook框架/xposed--Dalvik FrameWork/Xposed热更新hook目标方法后的行为代码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/Android逆向/Android-Hook/android-hook框架/xposed--Dalvik FrameWork/Xposed热更新hook目标方法后的行为代码/" itemprop="url">Xposed热更新hook目标方法后的行为代码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T16:44:42+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://github.com/githubwing/HotXposed" target="_blank" rel="noopener">Xposed热更新 hook目标方法后的行为代码</a></p>
<p>无法更新hook的目标，但可以更新hook目标后的行为。</p>
<p>比如 hook Activity的onCreate方法，toast Activity名称改为 logcat 打印Activity名称</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>参考android里classloader实现，发现findClass()最后都是调用了DexFile来loadClass。把需要写的逻辑代码单独放到一个dex里，然后使用DexFile加载</p>
<p>读取/sdcard/classes.dex文件，直接导入Hotfix类，调用他的invoke方法</p>
<img src="/2018/05/18/Android逆向/Android-Hook/android-hook框架/xposed--Dalvik%20FrameWork/Xposed热更新hook目标方法后的行为代码/DexFile-loadClass.jpg">
<img src="/2018/05/18/Android逆向/Android-Hook/android-hook框架/xposed--Dalvik%20FrameWork/Xposed热更新hook目标方法后的行为代码/DexFile-loadClass-2.jpg">

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/Android逆向/Android-Hook/gdb演示Android-ELF的GOT-Hook/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/Android逆向/Android-Hook/gdb演示Android-ELF的GOT-Hook/" itemprop="url">Android Hook原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T16:44:42+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://laokaddk.blog.51cto.com/368606/1168989/" target="_blank" rel="noopener">gdb演示Android ELF的GOT Hook</a> </p>
<p>需要Android源码环境编译，GOT时还需要源码库下的Android库的符号信息（包括libmym.so）</p>
<p>gdb ‘/home/liyunggui/桌面/testhook’</p>
<p>Reading symbols from /home/liyunggui/桌面/testhook…(no debugging symbols found)…done. 可能是因为编译过程跟博文不同，导致调试信息丢失而找不到</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/Android逆向/Android-Hook/Android-Hook原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/Android逆向/Android-Hook/Android-Hook原理/" itemprop="url">Android Hook原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T16:44:42+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.sanwho.com/248.html" target="_blank" rel="noopener">Android inline hook之原理分析篇 </a></p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">修改GOT</th>
<th style="text-align:left">inLine</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">实现难易</td>
<td style="text-align:left">比较容易，只需知道elf文件中调用外部符号的地址</td>
<td style="text-align:left">比较难，需要分析函数实现汇编码，保持堆栈平衡</td>
</tr>
<tr>
<td style="text-align:left">使用频率</td>
<td style="text-align:left">基本都是用此方式</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">功能强弱</td>
<td style="text-align:left">比较弱，只能hookGOT调用方式（通过java层调用API真实实现代码）</td>
<td style="text-align:left">很强大，能hookjni调用真实实现API的方式</td>
</tr>
<tr>
<td style="text-align:left">R11</td>
<td style="text-align:left">fp</td>
<td style="text-align:left">桢指针</td>
</tr>
<tr>
<td style="text-align:left">R12</td>
<td style="text-align:left">ip</td>
<td style="text-align:left">指令指针，内部过程调用寄存器</td>
</tr>
<tr>
<td style="text-align:left">R13</td>
<td style="text-align:left">sp</td>
<td style="text-align:left">栈指针</td>
</tr>
<tr>
<td style="text-align:left">R14</td>
<td style="text-align:left">lr</td>
<td style="text-align:left">返回地址，连接寄存器</td>
</tr>
<tr>
<td style="text-align:left">R15</td>
<td style="text-align:left">pc</td>
<td style="text-align:left">程序计数器</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/Android逆向/Android-Hook/android-hook框架/DDI--Dalvik InLine/ddi-原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/Android逆向/Android-Hook/android-hook框架/DDI--Dalvik InLine/ddi-原理/" itemprop="url">ddi 原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T16:44:42+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.csdn.net/roland_sun/article/details/38640297" target="_blank" rel="noopener">Android平台下Dalvik层hook框架ddi的研究</a> </p>
<p><a href="https://github.com/crmulliner/ddi" target="_blank" rel="noopener">ddi源码</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/Android逆向/Android-Hook/android-hook框架/ADBI--Native InLine/adbi注入原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/Android逆向/Android-Hook/android-hook框架/ADBI--Native InLine/adbi注入原理/" itemprop="url">adbi 注入原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T16:44:42+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.csdn.net/roland_sun/article/details/34109569" target="_blank" rel="noopener">Android平台下hook框架adbi的研究（上）</a></p>
<p><a href="https://github.com/crmulliner/adbi" target="_blank" rel="noopener">adbi源代码</a></p>
<p>Linux可以利用ptrace()函数来attach到一个进程上，从而可以修改对应该进程的内存内容和寄存器的值</p>
<p>adbi（The Android Dynamic Binary Instrumentation Toolkit）是一个通用的框架，使得hook变得异常简单。</p>
<h1 id="进程注入基本实现原理"><a href="#进程注入基本实现原理" class="headerlink" title="进程注入基本实现原理"></a>进程注入基本实现原理</h1><p>利用ptrace()attach到一个进程上，然后在进程调用序列中插入一个调用dlopen()加载so文件（初始化函数中hook指定的函数）的步骤。</p>
<p>adbi工具集由两个主要模块组成，分别是用于注入.so文件的进程劫持工具（hijack tool）和一个修改函数入口的基础库。</p>
<p>接下来，我们还是通过阅读代码来分别了解这两个模块的实现原理，本篇我们先将重点放在劫持工具的实现上。</p>
<p><strong>注入进程需要解决两个问题</strong></p>
<ol>
<li>获得目标进程dlopen()函数的调用地址</li>
<li>插入一个调用dlopen()函数的步骤到目标进程的调用序列中。</li>
</ol>
<h2 id="1-获得目标进程dlopen-函数的调用地址"><a href="#1-获得目标进程dlopen-函数的调用地址" class="headerlink" title="1. 获得目标进程dlopen()函数的调用地址"></a>1. 获得目标进程dlopen()函数的调用地址</h2><pre><code>----main()-----------------------------------------------------------------------
//在当前进程中dlopen()加载libdl.so动态库，接着用dlsym()函数获得当前进程dlopen()函数的调用地址
//libdl.so动态库肯定早已加载到当前进程中了，这里再加载一次并不会真的再在内存中的另一个位置加载一次，而是返回已经加载过的地址
void *ldl = dlopen(&quot;libdl.so&quot;, RTLD_LAZY);  
if (ldl) {  
    dlopenaddr = dlsym(ldl, &quot;dlopen&quot;);  
    dlclose(ldl);  
}  

unsigned long int lkaddr; //本进程linker地址。linker是Android提供的动态链接器，不同于普通的Linux。dlopen()函数就是在linker里面定义的（bionic/linker/dlfcn.cpp中: soinfo libdl_info = {&quot;libdl.so&quot;）  
unsigned long int lkaddr2; //目标进程linker地址   
find_linker(getpid(), &amp;lkaddr);  
find_linker(pid, &amp;lkaddr2);  

dlopenaddr = lkaddr2 + (dlopenaddr - lkaddr); //同一台机器上的进程肯定用的是同一个linker，所以其内部的dlopen()函数和linker头的偏移量是固定的

----find_linker()-----------------------------------------------------------------------
static int find_linker(pid_t pid, unsigned long *addr) {  
    struct mm mm[1000];  
    unsigned long libcaddr;  
    int nmm;  
    char libc[256];  
    symtab_t s;  

    if (0 &gt; load_memmap(pid, mm, &amp;nmm)) {  
        printf(&quot;cannot read memory map\n&quot;);  
        return -1;  
    }  
    if (0 &gt; find_linker_mem(libc, sizeof(libc), &amp;libcaddr, mm, nmm)) {  
        printf(&quot;cannot find libc\n&quot;);  
        return -1;  
    }  

    *addr = libcaddr;  

    return 1;  
} 

      ----load_memmap()-----------------------------------------------------------------------
    static int load_memmap(pid_t pid, struct mm *mm, int *nmmp) {  
        char raw[80000]; // this depends on the number of libraries an executable uses  
        char name[MAX_NAME_LEN];  
        char *p;  
        unsigned long start, end;  
        struct mm *m;  
        int nmm = 0;  
        int fd, rv;  
        int i;  

        //打开文件(路径是“/proc/&lt;进程号&gt;/maps”)读出指定进程的内存映射信息，其格式大概如下：
        sprintf(raw, &quot;/proc/%d/maps&quot;, pid);  
        fd = open(raw, O_RDONLY);  
        if (0 &gt; fd) {  
            printf(&quot;Can&apos;t open %s for reading\n&quot;, raw);  
            return -1;  
        }  

        //逐行读取内存映射信息文件的内容
        memset(raw, 0, sizeof(raw));  /* Zero to ensure data is null terminated */                
        p = raw;  
        while (1) {  
            rv = read(fd, p, sizeof(raw)-(p-raw));  
            if (0 &gt; rv) {  
                return -1;  
            }  
            if (0 == rv)  
                break;  
            p += rv;  
            if (p-raw &gt;= sizeof(raw)) {  
                printf(&quot;Too many memory mapping\n&quot;);  
                return -1;  
            }  
        }  
        close(fd);  

        //逐行解析内存映射信息文件的内容。文件格式如下：
        40096000-40098000 r-xp 00000000 b3:16 109        /system/bin/app_process  
        40098000-40099000 r--p 00001000 b3:16 109        /system/bin/app_process  
        40099000-4009a000 rw-p 00000000 00:00 0   
        4009a000-400a9000 r-xp 00000000 b3:16 176        /system/bin/linker  
        400a9000-400aa000 r--p 0000e000 b3:16 176        /system/bin/linker  
        400aa000-400ab000 rw-p 0000f000 b3:16 176        /system/bin/linker  
        400ab000-400ae000 rw-p 00000000 00:00 0   
        400ae000-400b0000 r--p 00000000 00:00 0   
        400b0000-400b9000 r-xp 00000000 b3:16 855        /system/lib/libcutils.so  
        be846000-be867000 rw-p 00000000 00:00 0          [stack] 
        p = strtok(raw, &quot;\n&quot;);  
        m = mm;  
        while (p) {  
            /* parse current map line */  
            rv = sscanf(p, &quot;%08lx-%08lx %*s %*s %*s %*s %s\n&quot;,  
                &amp;start, &amp;end, name);  //解析出当前行的 起始地址，结束地址，和名称。

            p = strtok(NULL, &quot;\n&quot;);  //获取下一行

            if (rv == 2) {  //没有解析出名称(只有两个返回值)，就会用一个自定义的名称补上（“[memory]”）
                m = &amp;mm[nmm++];  
                m-&gt;start = start;  
                m-&gt;end = end;  
                strcpy(m-&gt;name, MEMORY_ONLY);  
                continue;  
            }  

            if (strstr(name, &quot;stack&quot;) != 0) {  //名字是“stack”，表明这段内存用于栈
                stack_start = start;  
                stack_end = end;  
            }  

            //将连续的并且名字相同的内存段合并一下.(从前面的格式中可以看出，会有几行都叫一个名字的情况)
            /* search backward for other mapping with same name */  
            for (i = nmm-1; i &gt;= 0; i--) {  
                m = &amp;mm[i];  
                if (!strcmp(m-&gt;name, name))  
                    break;  
            }  

            if (i &gt;= 0) {  
                if (start &lt; m-&gt;start)  
                    m-&gt;start = start;  
                if (end &gt; m-&gt;end)  
                    m-&gt;end = end;  
            } else {  
                /* new entry */  
                m = &amp;mm[nmm++];  
                m-&gt;start = start;  
                m-&gt;end = end;  
                strcpy(m-&gt;name, name);  
        }  

        *nmmp = nmm;  
        return 0;  
    } 

    ----find_linker_mem()-----------------------------------------------------------------------
    static int find_linker_mem(char *name, int len, unsigned long *start, struct mm *mm, int nmm) {  
        int i;  
        struct mm *m;  
        char *p;  
        for (i = 0, m = mm; i &lt; nmm; i++, m++) {  
            if (!strcmp(m-&gt;name, MEMORY_ONLY))  
                continue;  
            p = strrchr(m-&gt;name, &apos;/&apos;);  
            if (!p)  
                continue;  
            p++;  
            if (strncmp(&quot;linker&quot;, p, 6))  //找出名字以“linker”结尾(/system/bin/linker)的那段内存的起始地址。
                continue;  
        break;  
        }  
        if (i &gt;= nmm)  
        /* not found */  
            return -1;  

        *start = m-&gt;start;  
        strncpy(name, m-&gt;name, len);  
        if (strlen(m-&gt;name) &gt;= len)  
            name[len-1] = &apos;\0&apos;;  
        return 0;  
    }  
</code></pre><h2 id="2-插入一个调用dlopen-函数的步骤到目标进程的调用序列中"><a href="#2-插入一个调用dlopen-函数的步骤到目标进程的调用序列中" class="headerlink" title="2. 插入一个调用dlopen()函数的步骤到目标进程的调用序列中"></a>2. 插入一个调用dlopen()函数的步骤到目标进程的调用序列中</h2><pre><code>// Attach 
if (0 &gt; ptrace(PTRACE_ATTACH, pid, 0, 0)) {//被Attach的进程将成为当前进程的子进程，并且会暂停执行。
    printf(&quot;cannot attach to %d, error!\n&quot;, pid);
    exit(1);
}
waitpid(pid, NULL, 0);//等待被Attach的进程暂停运行才返回
ptrace(PTRACE_GETREGS, pid, 0, &amp;regs); //获得目标进程的所有寄存器的值
//unsigned int sc[]
sc[11] = regs.ARM_r0;  
sc[12] = regs.ARM_r1;  
sc[13] = regs.ARM_r2;  
sc[14] = regs.ARM_r3;  
sc[15] = regs.ARM_lr;  
sc[16] = regs.ARM_pc;  
sc[17] = regs.ARM_sp;  
sc[19] = dlopenaddr;
// push library name to stack  
//case &apos;l&apos;: n = strlen(optarg)+1; n = n/4 + (n%4 ? 1 : 0); 
//命令行-l参数后就是so库完整名称。ptrace()写入目标进程以4字节为单位 
libaddr = regs.ARM_sp - n*4 - sizeof(sc);  
sc[18] = libaddr; 
// write library name to stack  
if (0 &gt; write_mem(pid, (unsigned long*)arg, n, libaddr)) {  
    printf(&quot;cannot write library name (%s) to stack, error!\n&quot;, arg);  
    exit(1);  
}  
// write code to stack  
codeaddr = regs.ARM_sp - sizeof(sc);  
if (0 &gt; write_mem(pid, (unsigned long*)&amp;sc, sizeof(sc)/sizeof(long), codeaddr)) {  
    printf(&quot;cannot write code, error!\n&quot;);  
    exit(1);  
}

    ----write_mem()-----------------------------------------------------------------------
    /* Write NLONG 4 byte words from BUF into PID starting at address POS.  Calling process must be attached to PID. */  
    static int write_mem(pid_t pid, unsigned long *buf, int nlong, unsigned long pos) {  
        unsigned long *p;  
        int i;  

        for (p = buf, i = 0; i &lt; nlong; p++, i++)  
            if (0 &gt; ptrace(PTRACE_POKETEXT, pid, pos+(i*4), *p))  
                return -1;  
        return 0;  
    }

mprotect()给栈内存段设置可执行属性。
    adbi采用了另一种方法找目标进程mprotect()内存地址。
    思路是分析ELF文件libc.so来获得其中符号mprotect的值（其实就是mprotect()函数相对于文件头的偏移），再加上libc.so文件在内存中映射的起始地址，就是mprotect()函数真正的调用地址了
// calc stack pointer  
regs.ARM_sp = regs.ARM_sp - n*4 - sizeof(sc);  

// call mprotect() to make stack executable  
regs.ARM_r0 = stack_start; // want to make stack executable  
regs.ARM_r1 = stack_end - stack_start; // stack size  
regs.ARM_r2 = PROT_READ|PROT_WRITE|PROT_EXEC; // protections  

regs.ARM_lr = codeaddr; // points to loading and fixing code  
regs.ARM_pc = mprotectaddr; // execute mprotect()

ptrace(PTRACE_SETREGS, pid, 0, &amp;regs);  
ptrace(PTRACE_DETACH, pid, 0, SIGCONT); //deAttach,让目标进程恢复运行 
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/Android逆向/Android-Hook/android-hook框架/Cydia-- Native Dalvik FrameWork/CydiaSubstrate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/Android逆向/Android-Hook/android-hook框架/Cydia-- Native Dalvik FrameWork/CydiaSubstrate/" itemprop="url">CydiaSubstrate</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T16:44:42+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Cydia Substrate可以修改任何主进程的代码，不管是用Java还是C/C++（native代码）编写的。而Xposed（开源）只支持 HOOK app_process中的java函数，因此Cydia Substrate是一款强大而实用的HOOK工具</p>
<p>Cydia Substrate</p>
<pre><code>参考自： 
    Android HOOK工具Cydia Substrate使用详解 http://mobile.51cto.com/aprogram-454091.htm
    周圣韬 Android上玩玩Hook：Cydia Substrate实战 http://www.csdn.net/article/2015-08-07/2825405 
Cydia Substrate原名MobileSubstrate（类库中都是以MS开头），
作者为大名鼎鼎的Jay Freeman（saurik）
Cydia Substrate框架对于inline Hook(框架实现都是通过该方式)的操作目前还是存在一些bug，
    使用的时候可能会出现崩溃的现象，
    部分使用了国内定制ROM的设备在使用Cydia Substrate框架时会造成设备无法重新启动或无法Hook的现象。
    无法重启可以按住音量+ 键 跳过hook插件，进入系统。
</code></pre><p>1.安装substrate.apk，点击”Link Substrate Files”（连接本地的Substrate服务文件），<br>    这一步是需要Root权限的，连接后还需要重启设备才能够生效<br>    <a href="http://www.cydiasubstrate.com/download/com.saurik.substrate.apk" target="_blank" rel="noopener">http://www.cydiasubstrate.com/download/com.saurik.substrate.apk</a></p>
<p>2.创建空Android工程。复制jar和so到libs文件夹中。<br>    其中的substrate.h头文件与lib文件夹下的so文件<br>        主要是substrate-api.jar<br>        .h和so是提供在使用NDK进行原生Hook程序开发中的函数支持库<br>    <a href="http://asdk.cydiasubstrate.com/zips/cydia_substrate-r2.zip" target="_blank" rel="noopener">http://asdk.cydiasubstrate.com/zips/cydia_substrate-r2.zip</a></p>
<p>3.Manifest文件配置 权限和hook类（入口）<br>（1）需要指定权限：cydia.permission.SUBSTRATE<br>        manifest下 <uses-permission android:name="cydia.permission.SUBSTRATE"><br>（2）添加meta-data标签，指定自定义的hook类<br>        application下 <meta-data android:name="com.saurik.substrate.main" android:value=".Main"><br>            name 固定，value就是我们自定义的hook类完整类名（包含包名）</meta-data></uses-permission></p>
<p>4.自定义hook类<br>    public class Main {<br>        static void initialize() { //插件加载时回调 static方法initialize<br>             MS.hookClassLoad(“android.content.res.Resources”, new MS.ClassLoadHook() { //hook 类加载<br>                public void classLoaded(Class&lt;?&gt; resources) { //类被加载时回调<br>                    Method getColor;<br>                    try {<br>                        getColor = resources.getMethod(“getColor”, Integer.TYPE);<br>                    } catch (NoSuchMethodException e) {<br>                        getColor = null;<br>                    }</p>
<pre><code>                if (getColor != null) {
                    final MS.MethodPointer old = new MS.MethodPointer(); //原方法指针。可以在任何时候运行原方法（被hook方法）

                    MS.hookMethod(resources, getColor, new MS.MethodHook() {
                        public Object invoked(Object resources, Object... args)
                            throws Throwable
                        {
                            int color = (Integer) old.invoke(resources, args);
                            return color &amp; ~0x0000ff00 | 0x00ff0000; //改变系统颜色
                        }
                    }, old);
                }
            }
        });
    }
}

也可以用以下代码实现hook
MS.hookMethod(resources, getColor, new MS.MethodAlteration&lt;Resources, Integer&gt;() {
    public Integer invoked(Resources resources, Object... args)
        throws Throwable
    {
        return invoke(resources, args) &amp; ~0x0000ff00 | 0x00ff0000;
    }
});
</code></pre><p>5.安装apk，重启手机，生效。</p>
<p>关键api<br>    void hookClassLoad(String className, MS.ClassLoadHook hook); Hook一个指定的Class<br>    void hookMethod(Class _class, Member member, MS.MethodHook methodhHook, MS.MethodPointer old);<br>    void hookMethod(Class _class, Member member, MS.MethodAlteration alteration);好用，稳定<br>        _class,需要hook的方法所属类<br>        member,需要hook的方法(或构造函数). 注意：不能HOOK字段 (在编译的时候会进行检测).<br>        methodhHook,MethodHook实例，其包含的invoked方法会被调用，用以代替被hook方法中的代码<br>        old,原方法指针，指向原方法（随时用该指针调用方法）<br>        alteration，MethodAlteration实例，其包含的invoked方法会被调用，用以代替被hook方法中的代码<br>            比MethodHook更好用稳定，在该方法直接调用invoke方法就是调用原方法<br>                不用自己定义 MS.MethodPointer old 指向原方法（随时用该指针调用方法）<br>    <t> T moveUnderClassLoader(ClassLoader loader, T object);   使用ClassLoder重载对象(少用)</t></p>
<p>6.补充<br>“卧槽”洗脑病毒分析 <a href="http://www.2cto.com/Article/201505/400301.html" target="_blank" rel="noopener">http://www.2cto.com/Article/201505/400301.html</a><br>    表现：所有字变为 卧槽。<br>    分析：跟上例改变字体颜色原理相同，只是hook的设置字体的方法<br>        TextView.setText(CharSequence)<br>    复现：<br>        public class Main {<br>            public static void initialize() {<br>                MS.hookClassLoad(“android.widget.TextView”, new MS.ClassLoadHook() {<br>                    @Override<br>                    public void classLoaded(Class arg0) {<br>                        Method smstest ;<br>                        try {<br>                           smstest=arg0.getMethod(“setText”, CharSequence.class);<br>                        } catch (SecurityException e) {<br>                            smstest=null;<br>                            e.printStackTrace();<br>                        } catch (NoSuchMethodException e) {<br>                            smstest=null;<br>                            e.printStackTrace();<br>                        }  </p>
<pre><code>               if(smstest!=null){        
                    final MS.MethodPointer old = new MS.MethodPointer();  
                    MS.hookMethod(arg0, smstest, new MS.MethodHook() {  
                       @Override 
                        public Object invoked(Object arg0, Object... arg1)throws Throwable {                                        
                            return old.invoke(arg0, &quot;爱破解，爱鬼哥&quot;);                                                                 
                        }                             
                    }, old);                          
                }                     
            }                
        });               
    }                                 
}  
</code></pre><p>周圣韬 Android上玩玩Hook：Cydia Substrate实战 <a href="http://www.csdn.net/article/2015-08-07/2825405" target="_blank" rel="noopener">http://www.csdn.net/article/2015-08-07/2825405</a><br>    开始实战（广告注入）<br>    针对Android操作系统的浏览器应用，Hook其首页Activity的onCreate方法（其他方法不一定存在，但是onCreate方法一定会有），<br>        (1)声明一个透明的广告的Activity<br>            为什么设置透明背景的Activity?<br>                就是为了使得弹出来的广告与浏览器融为一体，让用户感觉是浏览器弹出的广告，<br>                也是恶意广告程序为了防止自身被卸载掉的一些通用隐藏手段。<br>                这里演示的注入广告是通过Hook指定的Activity中的onCreate方法来启动一个广告Activity。<br>                如果启动的Activity带有恶意性，如将Activity做得与原Activity一模一样的钓鱼Activity，<br>                那么对于移动设备用户来说是极具欺骗性的。<br>            <!-- 透明无动画的广告Activity --><br>            <activity android:name="com.example.hookad.MainActivity" android:theme="@android:style/Theme.Translucent.NoTitleBar"><br>                <intent-filter><br>                    <action android:name="android.intent.action.VIEW"><br>                    <category android:name="android.intent.category.DEFAULT"><br>                    <!-- 广告的action,方便无context时启动  --><br>                    <action android:name="com.example.hook.AD"><br>                </action></category></action></intent-filter><br>            </activity><br>        (2)找到浏览器主页的Activity名称<br>            使用adb shell下使用dumpsys activity命令找到浏览器主页的Activity名称为<br>                com.android.browser.BrowserActivity<br>        (3)关键hook代码<br>            // 执行Hook前的onCreate方法，保证浏览器正常启动<br>            Object result =  old.invoke(object, args);<br>            // 没有Context。所以执行一个shell 启动我们的广告Activity<br>            CMD.run(“am start -a com.example.hook.AD”);</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/Android开发流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/Android开发流程/" itemprop="url">Android开发流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T16:44:42+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p>需求预审 → 需求评审 → 需求分解</p>
<p>→ 需求开发 → 自测 → 静态代码检查   </p>
<p>→ 提测预发布包 →  QA测试验证  </p>
<p>→ 逐步放量灰度及异常数据观察→ hotfix修复灰度中的问题</p>
<p>→  全渠道发布经过灰度验证后的版本（灰度中的问题已修复）→  异常数据观察 </p>
<p>→ 版本总结</p>
<h2 id="需求分解："><a href="#需求分解：" class="headerlink" title="需求分解："></a>需求分解：</h2><p>1）根据需求文档<strong>分解需求</strong>，分清需求的<strong>优先级</strong>，评估需求<strong>工作量</strong></p>
<p>2）罗列需求的<strong>前置条件及关联方</strong>，联系关联方确定前置条件的<strong>交付时间</strong></p>
<p>3）对于<strong>不确定因素和风险点</strong>，需同步出来并作为预估<strong>版本交付时间</strong>的依据。</p>
<p>4）根据前面的工作，结合现有人力，安排需求分工，<strong>预估版本交付时间</strong></p>
<h2 id="需求开发："><a href="#需求开发：" class="headerlink" title="需求开发："></a>需求开发：</h2><p>每天关注版本<strong>进度是否正常</strong>，及时发现风险，争取资源解决</p>
<h2 id="QA测试验证："><a href="#QA测试验证：" class="headerlink" title="QA测试验证："></a>QA测试验证：</h2><p>1）提交云测平台进行安装卸载monkey测试</p>
<p>2）功能测试</p>
<p>3）视情况进行其他专项测试</p>
<p>从CI（<a href="http://ci.xxx.local/job/xxx_android_release/）中提取发布包，并将发版记录登记到Android卓越网校钉钉群" target="_blank" rel="noopener">http://ci.xxx.local/job/xxx_android_release/）中提取发布包，并将发版记录登记到Android卓越网校钉钉群</a> 里面。</p>
<h2 id="逐步放量灰度及异常数据观察"><a href="#逐步放量灰度及异常数据观察" class="headerlink" title="逐步放量灰度及异常数据观察"></a>逐步放量灰度及异常数据观察</h2><p>通过bugly提供的<strong>灰度功能进行逐步放量</strong>，并对异常数据（崩溃率、ANR率、错误率）进行观察</p>
<p>灰度更新策略 <a href="https://bugly.qq.com" target="_blank" rel="noopener">https://bugly.qq.com</a> </p>
<p>hotfix修复灰度中的问题</p>
<p>Hotfix使用说明</p>
<p><a href="https://bugly.qq.com" target="_blank" rel="noopener">https://bugly.qq.com</a></p>
<p>（bugly账号目前由 xxx 保管）</p>
<p>部分应用市场需要加固上传提审，可以通过 <a href="http://console.qcloud.com/legu" target="_blank" rel="noopener">http://console.qcloud.com/legu</a> 腾讯乐固加固应用。</p>
<h2 id="全渠道发布"><a href="#全渠道发布" class="headerlink" title="全渠道发布"></a>全渠道发布</h2><p>1）官网渠道</p>
<p>官网下载地址指向公司OSS地址，所以更新名为android-xxx-cn的bucket下的xxx_release.apk文件。</p>
<p>2）应用商店渠道</p>
<p>现在上线的商店有 应用宝/华为/小米/360/百度，相关账号，目前由 xxx 保管。</p>
<p>3）检查更新渠道</p>
<p>将bugly的灰度更新量提到不限下载量</p>
<h2 id="版本总结"><a href="#版本总结" class="headerlink" title="版本总结"></a>版本总结</h2><p>1）异常经验集的完善</p>
<p>2）总结开发过程中的不足及改进点</p>
<h1 id="质量保障体系"><a href="#质量保障体系" class="headerlink" title="质量保障体系"></a>质量保障体系</h1><p>避免问题-&gt;发现问题-&gt;排查问题-&gt;解决问题-&gt;补救问题</p>
<p>问题的定义：对于用户造成了影响，增加其不必要的使用成本的都叫做问题</p>
<p>1.避免问题</p>
<p><strong>异常处理经验集</strong>的丰富完善</p>
<p><strong>代码规范</strong></p>
<p>静态<strong>代码检查</strong></p>
<p>2.发现问题</p>
<p><strong>异常数据收集</strong></p>
<p><strong>灰度验证</strong>（提前发现问题，缩小问题影响面）</p>
<p>3.排查问题</p>
<p>数据<strong>统计打点</strong>，数据分析，还原用户操作路径</p>
<p>4.解决问题</p>
<p><strong>Hotfix</strong>(加速修复问题)</p>
<p>5.补救问题</p>
<p>观察问题<strong>是否造成用户流失</strong>，通过短信或推送等方式通知用户已解决问题，并观察数据</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="风" />
            
              <p class="site-author-name" itemprop="name">风</p>
              <p class="site-description motion-element" itemprop="description">随心而动，随刃而行</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">69</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">风</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
