<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="随心而动，随刃而行">
<meta property="og:type" content="website">
<meta property="og:title" content="风">
<meta property="og:url" content="http://yoursite.com/page/28/index.html">
<meta property="og:site_name" content="风">
<meta property="og:description" content="随心而动，随刃而行">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="风">
<meta name="twitter:description" content="随心而动，随刃而行">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/28/"/>





  <title>风</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">风</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">技术博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/19/Android/得到Android彻底组件化方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/19/Android/得到Android彻底组件化方案/" itemprop="url">得到Android彻底组件化方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-19T11:37:17+08:00">
                2018-06-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、模块化：组件化与插件化"><a href="#一、模块化：组件化与插件化" class="headerlink" title="一、模块化：组件化与插件化"></a>一、模块化：组件化与插件化</h1><h2 id="模块化、插件化和组件化的关系"><a href="#模块化、插件化和组件化的关系" class="headerlink" title="模块化、插件化和组件化的关系"></a>模块化、插件化和组件化的关系</h2><p>项目发展到一定程度，就必须进行模块化的拆分。</p>
<p>模块化是一种指导理念，其核心思想就是分而治之、降低耦合。</p>
<p>而在 Android 工程实践，目前有两种途径(两大流派)，一个是组件化，一个是插件化。</p>
<h2 id="插件化和组件化的区别"><a href="#插件化和组件化的区别" class="headerlink" title="插件化和组件化的区别"></a>插件化和组件化的区别</h2><p>组件化和插件化的区别，有一个很形象的图：</p>
<img src="/2018/06/19/Android/得到Android彻底组件化方案/1.png">
<p>上图看上去比较清晰，其实容易导致一些误解，下面五个小问题，图中可能说的不太清楚：</p>
<ul>
<li>整体的各组件缺一不可吗？<ul>
<li>不是的。</li>
<li>组件化的第一个目标就是<strong>降低 整体与组件 的依赖关系</strong>，缺少任何组件都能正常运行</li>
</ul>
</li>
<li>组件<strong>独立运行</strong>支持吗？<ul>
<li>可以。</li>
<li>组件化的第二个目标就是<strong>组件可以独立运行</strong>，补足一些基本功能之后都是可以独立运行的</li>
</ul>
</li>
<li>组件化和插件化可以都用右图来表示吗？<ul>
<li>可以。</li>
<li>每个组件都可以看成一个单独的整体</li>
</ul>
</li>
<li>右图中的小机器人可以<strong>动态的添加和修改</strong>吗？<ul>
<li>如果组件化和插件化都用右图来表示，答案就不一样了</li>
<li>组件化，<strong>编译期</strong>可以</li>
<li>插件化，编译期和<strong>运行时</strong>可以</li>
</ul>
</li>
<li>组件化和插件化的最大区别（应该也是唯一区别）<ul>
<li>组件化在运行时不具备动态添加和修改组件的功能，但是插件化是可以的</li>
</ul>
</li>
</ul>
<h2 id="如何取舍插件化和组件化"><a href="#如何取舍插件化和组件化" class="headerlink" title="如何取舍插件化和组件化"></a>如何取舍插件化和组件化</h2><p>理想的代码组织形式是插件化的方式，届时就具备了完备的运行时动态化</p>
<p>奈何目前还没有一个完美兼容的插件化方案(RePlugin关注中)</p>
<p>在插件化和组件化取舍的一个重要原则是：<strong>产品对动态性的要求</strong>比较高，考虑插件化。一般来说，电商类或广告类产品对动态性要求比较强烈，而类似“得到 APP”这类的知识服务产品，每个功能的推出都是经过精细打磨的，对这种即时的动态性要求不高，所以不需要采用插件化。</p>
<p>产品对动态性的要求比较高，选择<strong>插件化</strong>之前也需要从两个方面权衡一下。</p>
<ul>
<li><strong>兼容性</strong>。一是插件化不可避免的去 hook 一些系统的 api，也就不可避免地有兼容性的问题，因此每个插件化方案需要有专门的团队去负责维护；</li>
<li><strong>开发节奏</strong>。二是从一个业务逻辑复杂的项目中去拆分插件化需要的时间可能是非常巨大的，需要考虑对开发节奏的影响。</li>
</ul>
<p>因此，对大多数产品来说，组件化都是一个不错甚至最佳的选择，它没有兼容性，可以更方便地拆分，并且几乎没有技术障碍，可以更顺利地去执行。特别是对急需拆分的产品来说，组件化是一个可退可守的方案，可以更快地执行下去，并且将来要是迁移到插件化，组件化拆分也是必经的一步。</p>
<h1 id="二、为何组件化"><a href="#二、为何组件化" class="headerlink" title="二、为何组件化"></a>二、为何组件化</h1><p>现状：</p>
<ul>
<li>业务复杂，代码交织在一起，可谓牵一发而动全身</li>
<li>花费在熟悉代码的时间甚至大于新需求的开发时间</li>
<li>大量代码堆积在一起，编译非常耗时。“得到 APP”Android端几十万行代码，编译一次大约10分钟</li>
<li>每个改动都需要测试人员进行大范围的回归</li>
<li>各项目组重复造轮子</li>
</ul>
<p>目标：<strong>优化代码结构，提升编码效率，降低编译耗时，减轻测试回归压力，组件复用</strong></p>
<h1 id="三、何为彻底组件化"><a href="#三、何为彻底组件化" class="headerlink" title="三、何为彻底组件化"></a>三、何为彻底组件化</h1><p>彻底组件化，主要是为了更好地强调两点：<strong>独立运行，动态集成</strong>。只有做到了代码隔离，才可以称之为“彻底”的</p>
<p><strong>组件可以独立运行，可以动态加载或卸载组件(组件之间针对接口编程，间接引用)</strong></p>
<h1 id="四、如何彻底组件化"><a href="#四、如何彻底组件化" class="headerlink" title="四、如何彻底组件化"></a>四、如何彻底组件化</h1><p>要实现彻底组件化，需要考虑的问题主要包括下面四个：</p>
<ul>
<li><p>组件独立运行。每个组件都是一个完整的整体，如何让其单独运行和调试呢？</p>
</li>
<li><p>代码解耦与代码隔离。如何将一个庞大的工程拆分成有机的整体？如何从根本上避免组件之间的直接引用呢？也就是如何从根本上杜绝耦合的产生呢？</p>
</li>
<li><p>数据传递和UI跳转。因为每个组件都会给其他组件提供服务，那么主项目（Host）与组件、组件与组件之间如何传递数据？UI 跳转可以认为是一种特殊的数据传递，在实现思路上有啥不同？</p>
</li>
<li><p>组件的生命周期。我们的目标是可以做到对组件可以按需、动态的使用，因此就会涉及到组件加载、卸载和降维的生命周期。</p>
</li>
</ul>
<img src="/2018/06/19/Android/得到Android彻底组件化方案/architecture.png">
<p>对三种 module 进行区分：</p>
<ul>
<li><p>依赖库 library，被其他组件直接引用。比如网络库 module 可以认为是一个 library。</p>
</li>
<li><p>组件 Component，是一个完整的功能模块。比如读书或者分享 module 就是一个 Component。我们讲的组件化也主要是针对这种类型</p>
</li>
<li><p>主项目 Host，负责拼装组件以形成一个完整app 的 module。一般我们称之为主项目、主 module 或者 Host</p>
</li>
</ul>
<h2 id="组件独立运行"><a href="#组件独立运行" class="headerlink" title="组件独立运行"></a>组件独立运行</h2><p>设置一个变量 isRunAlone，标记当前是否需要独立运行，根据 isRunAlone 的取值，使用不同的 gradle 插件和 AndroidManifest 文件，甚至可以添加 Application 等 Java 文件，以便可以做一下初始化的操作。</p>
<p>为了避免不同组件之间资源名重复，在每个组件的 build.gradle 中增加 resourcePrefix “xxx_”，从而固定每个组件的资源前缀</p>
<p>下面是读书组件的 build.gradle 的示例：</p>
<pre><code>if(isRunAlone.toBoolean()){    
    apply plugin: &apos;com.android.application&apos;
}else{  
    apply plugin: &apos;com.android.library&apos;
}
.....
resourcePrefix &quot;readerbook_&quot;
sourceSets {
  main {
      if (isRunAlone.toBoolean()) {
          manifest.srcFile &apos;src/main/runalone/AndroidManifest.xml&apos;
          java.srcDirs = [&apos;src/main/java&apos;,&apos;src/main/runalone/java&apos;]
          res.srcDirs = [&apos;src/main/res&apos;,&apos;src/main/runalone/res&apos;]
      } else {
          manifest.srcFile &apos;src/main/AndroidManifest.xml&apos;
      }
  }
}
</code></pre><h2 id="代码解耦与代码隔离"><a href="#代码解耦与代码隔离" class="headerlink" title="代码解耦与代码隔离"></a>代码解耦与代码隔离</h2><p>Android 的 multiple module 功能，很容易把代码进行初步的拆分</p>
<p>组件针对接口编程</p>
<ul>
<li>坚决<strong>避免组件之间直接引用</strong>（compile) 。<ul>
<li>直接引用难免会导致使用其他组件的具体实现类，这样针对接口编程的要求就成了一句空话。</li>
<li>更严重的是，一旦对组件进行动态地加载或卸载，就会导致严重地崩溃。</li>
</ul>
</li>
<li><strong>代码编写期间组件之间完全不可见</strong>。<ul>
<li>杜绝了直接使用具体的实现类的情况，</li>
</ul>
</li>
<li><strong>自动打包依赖的组件</strong></li>
</ul>
<p>通过 <strong>自定义gradle插件 + 配置文件</strong>，从根本上杜绝耦合的产生。每个组件都 apply 这个插件</p>
<p>配置文件，每个组件声明自己所需要的其他组件，配置分为 debug 和 release 两种，可以在日常开发和正式打包之间更灵活的切换。</p>
<p>自定义gradle插件，分析运行的 task 命令，如果是打包命令(例如 assembleRelease)自动根据配置文件引入依赖组件，不是(例如 sync/build)则不引入</p>
<p>自定义gradle插件，自动的识别和修改组件的属性，识别出当前调试的组件，然后把这个组件修改为 application 项目，而其他组件则默默的修改成 library 项目。因此不论是要单独编译一个组件还是要把这个组件集成到其他组件中调试，都是不需要做任何的手动修改，使用起来相当的方便。</p>
<pre><code>// 根据配置添加各种组件依赖，并且自动化生成组件加载代码
if (project.android instanceof AppExtension) {
       AssembleTask assembleTask = getTaskInfo(project.gradle.startParameter.taskNames)
       if (assembleTask.isAssemble
               &amp;&amp; (assembleTask.modules.contains(&quot;all&quot;) || assembleTask.modules.contains(module))) {
         // 添加组件依赖
          project.dependencies.add(&quot;compile&quot;,&quot;xxx:reader-release@aar&quot;)
         // 字节码插入的部分也在这里实现
       }
}

private AssembleTask getTaskInfo(List&lt;String&gt; taskNames) {
   AssembleTask assembleTask = new AssembleTask();
   for (String task : taskNames) {
       if (task.toUpperCase().contains(&quot;ASSEMBLE&quot;)) {
           assembleTask.isAssemble = true;
           String[] strs = task.split(&quot;:&quot;)
           assembleTask.modules.add(strs.length &gt; 1 ? strs[strs.length - 2] : &quot;all&quot;);
       }
   }
   return assembleTask
}
</code></pre><h2 id="数据传递和UI跳转"><a href="#数据传递和UI跳转" class="headerlink" title="数据传递和UI跳转"></a>数据传递和UI跳转</h2><h3 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h3><p>向 Router 请求 组件功能 的具体实现，与 Binder 的 C/S 架构很相像。</p>
<p>一个很容易犯的小错误就是通过持久化的方式来传递数据，例如 file、sharedpreference 等方式，这个是需要避免的。</p>
<h4 id="组件声明自己提供的服务"><a href="#组件声明自己提供的服务" class="headerlink" title="组件声明自己提供的服务"></a>组件声明自己提供的服务</h4><p>组件声明自己提供的服务(抽象类或者接口)</p>
<p>简单起见，专门建立了一个 componentservice 的依赖库，里面定义了每个组件向外提供的 service 和一些公共 model。将所有组件的 service 整合在一起，是为了在拆分初期操作更为简单，后面需要改为自动化的方式来生成。这个依赖库需要严格遵循开闭原则，以避免出现版本兼容等问题。</p>
<h4 id="组件注册服务的具体实现"><a href="#组件注册服务的具体实现" class="headerlink" title="组件注册服务的具体实现"></a>组件注册服务的具体实现</h4><p>主项目加载组件时，组件注册服务的具体实现到 Router中。</p>
<h3 id="UI跳转"><a href="#UI跳转" class="headerlink" title="UI跳转"></a>UI跳转</h3><p>UI 的跳转也是组件提供的一种特殊的服务，可以归属到上面的数据传递中去。不过一般 UI 的跳转我们会单独处理，一般通过短链的方式来跳转到具体的 Activity。每个组件可以注册自己所能处理的短链的 schme 和 host，并定义传输数据的格式。然后注册到统一的 UIRouter 中，UIRouter 通过 schme 和 host 的匹配关系负责分发路由。</p>
<p>UI 跳转部分的具体实现是通过在每个 Activity 上添加注解，然后通过 apt 形成具体的逻辑代码。这个也是目前 Android 中 UI 路由的主流实现方式。</p>
<p>声明注册服务以及UI跳转已经有成熟的注解框架，后期考虑替换</p>
<h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>要动态的管理组件，给每个组件添加几个生命周期状态：加载、卸载和降维。</p>
<p>为此我们给每个组件增加一个 ApplicationLike 类，里面定义了 onCreate 和 onStop 两个生命周期函数。</p>
<ul>
<li><p>加载：onCreate()。主项目调用 onCreate() 就称之为组件的加载。组件把自己的服务实现注册到 Router 里面去。</p>
</li>
<li><p>卸载：onStop()。组件将自己的服务实现从 Router 中取消注册。不过这种使用场景可能比较少，一般适用于一些只用一次的组件。</p>
</li>
<li><p>降维：降维使用的场景更为少见，比如一个组件出现了问题，我们想把这个组件从本地实现改为一个 wap 页。降维一般需要后台配置才生效，可以在 onCreate 对线上配置进行检查，如果需要降维，则把所有的 UI 跳转到配置的 wap 页上面去。</p>
</li>
</ul>
<p>主项目负责加载组件，由于主项目和组件之间是隔离的，那么主项目如何调用组件 ApplicationLike 的生命周期方法呢，目前我们采用的是基于编译期字节码插入的方式，扫描所有的 ApplicationLike 类（其有一个共同的父类），然后通过 javassisit 在主项目的 onCreate 中插入调用 ApplicationLike.onCreate 的代码。</p>
<h1 id="五、组件化的拆分步骤"><a href="#五、组件化的拆分步骤" class="headerlink" title="五、组件化的拆分步骤"></a>五、组件化的拆分步骤</h1><p>组件化的拆分是个庞大的工程，可以分成三步：</p>
<ul>
<li><p>从产品需求到开发阶段再到运营阶段都有清晰边界的功能开始拆分。比如读书模块、直播模块等，这些开始分批先拆分出去</p>
</li>
<li><p>在拆分中，造成组件依赖主项目的依赖模块继续拆出去。比如账户体系等</p>
</li>
<li><p>最终主项目就是一个 Host，包含很小的功能模块（比如启动图）以及组件之间的拼接逻辑</p>
</li>
</ul>
<h1 id="六、组件化过程中要注意的问题"><a href="#六、组件化过程中要注意的问题" class="headerlink" title="六、组件化过程中要注意的问题"></a>六、组件化过程中要注意的问题</h1><p>一是技术细节上的不断完善，二是团队的共识建设问题</p>
<p>方案中数据传输和 UI 跳转是分开的两个功能，这是在实际拆分中才做出的选择，因为数据传输更为频繁，且交互形式更多样，使用一个标准化的路由协议难以满足，因此把数据传输改成了接口 + 实现的形式，针对接口编程就可以更加灵活地处理这些情况。</p>
<h1 id="七、组件化后的具体成果"><a href="#七、组件化后的具体成果" class="headerlink" title="七、组件化后的具体成果"></a>七、组件化后的具体成果</h1><ul>
<li><strong>代码结构非常清晰</strong>，分层结构以及之间的交互很明了，团队中的任何一个人都可以很轻松的绘制出代码结构图，这个在之前是没法做到的</li>
<li>每次开发需求的时候，面对的代码越来越少，不用背负那么重的代码包袱，可以说达到了“<strong>代码越写越少</strong>”的理想情况。</li>
<li>每个组件的<strong>编译耗时大大降低</strong>。从 10 分钟降到了几十秒，工作效率有了很大地提升</li>
<li><strong>减轻测试回归压力</strong>。可以分组件测试</li>
<li><strong>组件可以复用</strong>。新产品可以使用已有的组件，提升整个公司效率</li>
</ul>
<h1 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h1><p>方案在设计之初参考了目前已有的组件化和插件化方案，站在巨人的肩膀上又加了一点自己的想法，主要是组件化生命周期以及完全的代码隔离方面。特别是代码隔离，不仅要有规范上的约束(针对接口编程)，更要有机制保证开发者不犯错(自定义gradle插件)，我觉得只有做到这一点才能认为是一个彻底的组件化方案</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/11/Android/Android图片压缩/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/11/Android/Android图片压缩/" itemprop="url">Android图片压缩</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-11T15:03:18+08:00">
                2018-06-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="内存大小"><a href="#内存大小" class="headerlink" title="内存大小"></a>内存大小</h1><p><strong>色彩模式</strong>是数字世界中表示颜色的一种算法，在Bitmap里用Config来表示。</p>
<p>颜色默认是 RGB，三原色各占8位，共计24位，即3个字节</p>
<pre><code>颜色值0-255，8位刚好能标示一种颜色
</code></pre><p>BitmapFactory.Options 设置图像的色彩模式，共有4种取值</p>
<pre><code>ARGB_8888，表示一个像素点的透明度以及三原色各占8位，共计32位，即4个字节
ALPHA_8，表示一个像素点只有透明度，没有三原色，此时，一个像素点占8位，即1个字节
ARGB_4444，表示一个像素点的透明度以及三原色各占4位，共计16位，即2个字节
RGB_565，这种色彩模式不能表示透明度，红绿蓝三色各占5、6、6位，共计16位，即2个字节
</code></pre><p>Bitmap的计算方式</p>
<pre><code>memory=scaledWidth*scaledHeight*每个像素所占字节数

    scaledWidth :  widthtargetDensity/density+0.5
    scaledHeight： heighttargetDensity/density+0.5

        targetDensity表示手机的像素密度,这个值一般跟手机相关,
        density表示decodingBitmap 的 density,这个值一般跟图片放置的目录有关(hdpi/xxhdpi)
</code></pre><p><strong>Bitmap获取内存占用大小的API</strong></p>
<ul>
<li>getByteCount()：API12 加入，代表存储 Bitmap 的像素需要的最少内存。</li>
<li>getAllocationByteCount()：API19 加入，代表在内存中为 Bitmap 分配的内存大小，代替了 getByteCount() 方法。</li>
</ul>
<p>两者的区别:</p>
<p>在不复用 Bitmap 时，getByteCount() 和 getAllocationByteCount 返回的结果是一样的。</p>
<p>在通过复用 Bitmap 来解码图片时，那么 getByteCount() 表示新解码图片占用内存的大小，getAllocationByteCount() 表示被复用 Bitmap真实占用的内存大小（即 mBuffer 的长度）。</p>
<p>早期的Android平台下,对一张图片进行多次质量压缩,会得到一张<strong>变绿</strong>的图片</p>
<p>假设客户端需要加载一张图片，图片尺寸为3000*3000（像素）,如果客户端显示原图，按一个像素四个字节算(argb)， </p>
<p>3000 <em> 3000 </em> 4 / 1024 / 1024 = 34 M，</p>
<p>客户端一个应用程序的运行内存就16M,你一下显示一个30多M的图片，直接 OOM crash了。</p>
<h1 id="图片压缩方式"><a href="#图片压缩方式" class="headerlink" title="图片压缩方式"></a>图片压缩方式</h1><h2 id="质量压缩"><a href="#质量压缩" class="headerlink" title="质量压缩"></a>质量压缩</h2><p>不会改变图像的宽高，降低图像的质量，从而降低存储大小</p>
<pre><code>bitmap.compress(Bitmap.CompressFormat.JPEG, 100, outputStream);

    压缩格式,它有JPEG、PNG、WEBP三种选择，JPEG是有损压缩，PNG是无损压缩，WEBP是Google推出的图像格式(会存在兼容性的问题).一般会选择JPEG
    quality：0~100可选，数值越大，质量越高，图像越大。
</code></pre><h2 id="尺寸压缩"><a href="#尺寸压缩" class="headerlink" title="尺寸压缩"></a>尺寸压缩</h2><p>尺寸压缩本质上就是一个重新采样的过程，放大图像称为上采样，缩小图像称为下采样</p>
<p>Android提供了两种图像采样方法，邻近采样和双线性采样。</p>
<p><strong>采样效果 从低到高依次：</strong></p>
<h3 id="邻近采样"><a href="#邻近采样" class="headerlink" title="邻近采样"></a>邻近采样</h3><p>采用邻近点插值算法，用一个像素点代替邻近的像素点</p>
<pre><code>BitmapFactory.Options options = new BitmapFactory.Options();
options.inSampleSize = 2
Bitmap bitmap = BitmapFactory.decodeFile(&quot;/sdcard/test.png&quot;);
Bitmap compress = BitmapFactory.decodeFile(&quot;/sdcard/test.png&quot;, options);

options.inSampleSize = 2;一个像素点会代替原来的2个像素点
    注意这里的2个像素点仅仅指水平方向或者竖直方向上的。
    即原来2x2的像素,压缩后仅使用一个像素点来代替
</code></pre><p><strong>压缩前红绿相间的图片,经过压缩后,完全变成了绿色</strong>.这时因为邻近点插值算法直接选择其中一个像素作为生成像素,另外一个像素直接抛弃,这样才会造成图片变成纯绿色的情况。</p>
<p>邻近采样的方法有些<strong>暴力</strong>,Android平台提供了另一种尺寸压缩方案</p>
<h3 id="双线性采样"><a href="#双线性采样" class="headerlink" title="双线性采样"></a>双线性采样</h3><p>采用双线性插值算法，相比邻近采样简单粗暴的选择一个像素点代替其他像素点，双线性采样参考源像素相应位置周围2x2个点的值，根据相对位置取对应的权重，经过计算得到目标图像。</p>
<pre><code>Bitmap bitmap = BitmapFactory.decodeFile(&quot;/sdcard/test.png&quot;);
Bitmap compress = Bitmap.createScaledBitmap(bitmap, bitmap.getWidth()/2, bitmap.getHeight()/2, true);

或者
Bitmap bitmap = BitmapFactory.decodeFile(&quot;/sdcard/test.png&quot;);
Matrix matrix = new Matrix();
matrix.setScale(0.5f, 0.5f);
bm = Bitmap.createBitmap(bitmap, 0, 0, bit.getWidth(), bit.getHeight(), matrix, true);
</code></pre><p>压缩后的图片不会像邻近采样那般只有纯粹的一种颜色,而是参考了像素源周围2x2个点的像素，并取其权重得到目标图像。</p>
<p>双线性采样相比邻近采样而言,图片的保真度会高些,但压缩的速率不及前者,因为前者不需要计算直接选择了其中一个像素作为生成像素。</p>
<h4 id="二次采样"><a href="#二次采样" class="headerlink" title="二次采样"></a>二次采样</h4><p><strong><code>二次采样</code></strong> 二次设置图片采样比率，达到减小加载图片所需内存空间</p>
<p>步骤： </p>
<pre><code>第一次采样：
    第一次解码,只获取图片的尺寸(不会占用太多内存)，不进行实际的Bitmap创建。

计算采样率：根据图片宽高，以及客户端希望图片加载后的尺寸

第二次采样：

    给BitmapFactory设置采样率，加载Bitmap到内存
</code></pre><p><code>BitmapFactory.Options</code> 参数说明</p>
<pre><code>In开头的：用于给解码器传递参数 

    inSampleSize 

Out开头的：用于从解码器获取结果

    options.outMimeType; // 图片类型 &quot;image/png&quot;
</code></pre><p>代码实例：</p>
<pre><code>public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId,
        int reqWidth, int reqHeight) {
    final BitmapFactory.Options options = new BitmapFactory.Options();
    options.inJustDecodeBounds = true; //是否只加载图片的边框
    BitmapFactory.decodeResource(res, resId, options); //加载图片，此时加载只能够获取到图片的边框

    // 计算inSampleSize
    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);

    options.inJustDecodeBounds = false;
    // 加载压缩版图片
    return BitmapFactory.decodeResource(res, resId, options);
}


//google推荐算法：以对角线的方式进行缩放比率的计算
public static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {
    // 图片原始宽高
    final int height = options.outHeight;
    final int width = options.outWidth;
    int inSampleSize = 1;

    //只有当请求的宽度、高度 &gt; 0时，进行缩放。否则，图片不进行缩放
    if(reqHeight &gt; 0 &amp;&amp; reqWidth &gt; 0){
        if (height &gt; reqHeight || width &gt; reqWidth) {

            final int halfHeight = height / 2;
            final int halfWidth = width / 2;

            //计算一个最大的缩放比例（采样比率，2的n次幂），保证缩放后的宽高大于要求的宽高
            while ((halfHeight / inSampleSize) &gt; reqHeight &amp;&amp; (halfWidth / inSampleSize) &gt; reqWidth) {
                inSampleSize *= 2;
            }
        }
    }
    return inSampleSize;
}
</code></pre><p>特别注意：</p>
<p>二次采样后获得的图片宽高并不是完全吻合控件宽高，还是需要设置ScaleType来适应</p>
<p>二次采样只是为了解决图片OOM</p>
<h3 id="双立方／双三次采样-Android原生不支持"><a href="#双立方／双三次采样-Android原生不支持" class="headerlink" title="双立方／双三次采样 (Android原生不支持)"></a>双立方／双三次采样 (Android原生不支持)</h3><p>双立方／双三次采样使用的是双立方／双三次插值算法。双立方／双三次插值算法参考了源像素某点周围 4x4 个像素。</p>
<p>双立方/双三次插值算法经常用于图像或者视频的缩放，它能比双线性内插值算法保留更好的细节质量。</p>
<p>双立方／双三次插值算法在平时的软件中是很常用的一种图片处理算法，但是这个算法有一个缺点就是计算量会相对比较大，是前三种算法中计算量最大的，软件 photoshop 中的图片缩放功能使用的就是这个算法。</p>
<h3 id="Lanczos-采样-原生不支持"><a href="#Lanczos-采样-原生不支持" class="headerlink" title="Lanczos 采样 (原生不支持)"></a>Lanczos 采样 (原生不支持)</h3><p>Lanczos 采样和 Lanczos 过滤是 Lanczos 算法的两种常见应用，它可以用作低通滤波器或者用于平滑地在采样之间插入数字信号，Lanczos 采样一般用来增加数字信号的采样率，或者间隔采样来降低采样率。</p>
<p>采样效果对比参考：腾讯音乐技术团队<a href="https://mp.weixin.qq.com/s/H9Tz1n4O2-Aawgu7p-XL5w" target="_blank" rel="noopener">Android中图片压缩分析（下）</a>。总的来说，上采样和对二值化图片(黑白)的处理表现差异特别明显</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/11/Android/Android资源文件res/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/11/Android/Android资源文件res/" itemprop="url">Android资源文件res</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-11T11:08:38+08:00">
                2018-06-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="根据资源名获取资源id–getIdentifier"><a href="#根据资源名获取资源id–getIdentifier" class="headerlink" title="根据资源名获取资源id–getIdentifier()"></a>根据资源名获取资源id–getIdentifier()</h1><pre><code>int layoutId = getResources().getIdentifier(&quot;activity_main&quot;, &quot;layout&quot;, getPackageName());
</code></pre><p>一般都是动态替换资源id时用到，可以有效避免定义资源Array。比如下例，动态展示连击1到连击9，超过9展示最佳连击</p>
<pre><code>getResources().getIdentifier(comboNum &lt;= 9 ? &quot;combo_&quot; + comboNum : &quot;combo_best&quot;, &quot;drawable&quot;, getPackageName());
</code></pre><h1 id="图片资源"><a href="#图片资源" class="headerlink" title="图片资源"></a>图片资源</h1><p>存放目录：<code>drawable</code> <code>mipmap</code></p>
<p>支持格式：</p>
<ul>
<li>png</li>
<li>xml</li>
<li>gif</li>
</ul>
<p>使用：</p>
<p>xml中：<code>@drawable/distraction</code> <code>@mipmap/distraction</code></p>
<p>Java代码中：<code>R.drawable.distraction</code> <code>R.mipmap.distraction</code></p>
<h1 id="音频资源"><a href="#音频资源" class="headerlink" title="音频资源"></a>音频资源</h1><p>存放目录：<code>raw</code></p>
<p>使用：<code>R.raw.sound_connect_praise</code></p>
<pre><code>SoundPool.load()
SoundPool.play()
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/07/Android/View转为Bitmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/07/Android/View转为Bitmap/" itemprop="url">View转为Bitmap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-07T15:54:53+08:00">
                2018-06-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="方法一-view-getDrawingCache"><a href="#方法一-view-getDrawingCache" class="headerlink" title="方法一:view.getDrawingCache()"></a>方法一:view.getDrawingCache()</h1><p>适用于View显示在界面上的情况。可以被完全遮挡住，只要android:visibility=”visible”就可以</p>
<pre><code>public Bitmap convertViewToBitmap(View view){

    view.setDrawingCacheEnabled(true); ////启用DrawingCache

    view.buildDrawingCache(); //创建位图

    Bitmap bitmap=Bitmap.createBitmap(view.getDrawingCache()); ////创建一个DrawingCache的拷贝，因为DrawingCache得到的位图在禁用后会被回收

    view.setDrawingCacheEnabled(false);  //禁用DrawingCahce否则会影响性能

    return bitmap;

}
</code></pre><h2 id="返回的Bitmap为null或生成Bitmap全黑色"><a href="#返回的Bitmap为null或生成Bitmap全黑色" class="headerlink" title="返回的Bitmap为null或生成Bitmap全黑色"></a>返回的Bitmap为null或生成Bitmap全黑色</h2><p>主要原因是drawingCache的值大于系统给定的值，buildDrawingCache()失败</p>
<pre><code>if (width &lt;= 0 || height &lt;= 0 ||(width * height * (opaque &amp;&amp; !translucentWindow ? 2 : 4) &gt; ViewConfiguration.get(mContext).getScaledMaximumDrawingCacheSize())) {   
     destroyDrawingCache();   
     return;   
  }  
</code></pre><p>解决方案：</p>
<pre><code>public static Bitmap convertViewToBitmap(View view){
    view.measure(MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED), MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED));
    view.layout(0, 0, view.getMeasuredWidth(), view.getMeasuredHeight());
    view.buildDrawingCache();
    Bitmap bitmap = view.getDrawingCache();
    return bitmap;
}
</code></pre><h1 id="方法二-View-draw-Canvas-canvas"><a href="#方法二-View-draw-Canvas-canvas" class="headerlink" title="方法二:View.draw(Canvas canvas)"></a>方法二:View.draw(Canvas canvas)</h1><p>从源码中可以看到buildDrawingCache就是获得View的Canvas然后画到bitmap上，直接返回对应的bitmap。有些同学就直接将View画到bitmap</p>
<p><strong>个人不推荐使用</strong>。因为系统buildDrawingCache考虑的因素很多，比如透明磁，大小 ，图片质量等；还有重新定位到当前可显示的区域(这点很重要，如果有可滚动的控件，不重定位是无法正确得到Bitmap的，比如ViewPager第二页，手动draw就会出问题)</p>
<pre><code>public static Bitmap convertViewToBitmap(View view) {  
    Bitmap bitmap= Bitmap.createBitmap(view.getWidth(), view.getHeight(), HDConstantSet.BITMAP_QUALITY);  
    Canvas canvas = new Canvas(bitmap);  
    view.draw(canvas);  
    return bitmap;  
}

public static Bitmap loadBitmapFromView(View v) {
 Bitmap b = Bitmap.createBitmap( v.getLayoutParams().width, v.getLayoutParams().height, Bitmap.Config.ARGB_8888);                
 Canvas c = new Canvas(b);
 v.layout(0, 0, v.getLayoutParams().width, v.getLayoutParams().height);
 v.draw(c);
 return b;
</code></pre><p>}</p>
<h2 id="View没有显示在界面上的情况"><a href="#View没有显示在界面上的情况" class="headerlink" title="View没有显示在界面上的情况"></a>View没有显示在界面上的情况</h2><p>通过java代码创建的或者inflate创建的View，是获取不到Bitmap的。</p>
<p>因为View在添加到容器中之前并没有得到实际的大小，需要先指定View的大小</p>
<pre><code>public static Bitmap convertViewToBitmap(View view) {  
    layoutView(view);//必须measure和layout。否则宽高都为0，报错 java.lang.IllegalArgumentException: width and height must be &gt; 0
    Bitmap bitmap= Bitmap.createBitmap(view.getWidth(), view.getHeight(), Bitmap.Config.ARGB_8888);  
    Canvas canvas = new Canvas(bitmap);  
    view.draw(canvas);  
    return bitmap;  
}

private void layoutView(View v) {
    DisplayMetrics metric = new DisplayMetrics();
    getWindowManager().getDefaultDisplay().getMetrics(metric);
    int width = metric.widthPixels;     // 屏幕宽度（像素）
    int height = metric.heightPixels;   // 屏幕高度（像素）
    v.layout(0, 0, width, height);
    int measuredWidth = View.MeasureSpec.makeMeasureSpec(width, View.MeasureSpec.EXACTLY);
    int measuredHeight = View.MeasureSpec.makeMeasureSpec(10000, View.MeasureSpec.AT_MOST);
    v.measure(measuredWidth, measuredHeight);
    v.layout(0, 0, v.getMeasuredWidth(), v.getMeasuredHeight());
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/07/Android/Bitmap图片生成/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/07/Android/Bitmap图片生成/" itemprop="url">Bitmap图片生成</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-07T15:51:21+08:00">
                2018-06-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>把两张bitmap合成为一张图</p>
<pre><code>/**
 * 把两个位图覆盖合成为一个位图，以底层位图的长宽为基准
 * @param backBitmap 在底部的位图
 * @param frontBitmap 盖在上面的位图
 * @return
 */
public static Bitmap mergeBitmap(Bitmap backBitmap, Bitmap frontBitmap) {

    if (backBitmap == null || backBitmap.isRecycled() 
            || frontBitmap == null || frontBitmap.isRecycled()) {
        Log.e(TAG, &quot;backBitmap=&quot; + backBitmap + &quot;;frontBitmap=&quot; + frontBitmap);
        return null;
    }
    Bitmap bitmap = backBitmap.copy(Config.ARGB_8888, true);
    Canvas canvas = new Canvas(bitmap);
    Rect baseRect  = new Rect(0, 0, backBitmap.getWidth(), backBitmap.getHeight());
    Rect frontRect = new Rect(0, 0, frontBitmap.getWidth(), frontBitmap.getHeight());
    canvas.drawBitmap(frontBitmap, frontRect, baseRect, null);
    return bitmap;
}

/**
 * 把两个位图覆盖合成为一个位图，左右拼接
 * @param leftBitmap 
 * @param rightBitmap 
 * @param isBaseMax 是否以宽度大的位图为准，true则小图等比拉伸，false则大图等比压缩
 * @return
 */
public static Bitmap mergeBitmap_LR(Bitmap leftBitmap, Bitmap rightBitmap, boolean isBaseMax) {

    if (leftBitmap == null || leftBitmap.isRecycled() 
            || rightBitmap == null || rightBitmap.isRecycled()) {
        JDLog.logError(TAG, &quot;leftBitmap=&quot; + leftBitmap + &quot;;rightBitmap=&quot; + rightBitmap);
        return null;
    }
    int height = 0; // 拼接后的高度，按照参数取大或取小
    if (isBaseMax) {
        height = leftBitmap.getHeight() &gt; rightBitmap.getHeight() ? leftBitmap.getHeight() : rightBitmap.getHeight();
    } else {
        height = leftBitmap.getHeight() &lt; rightBitmap.getHeight() ? leftBitmap.getHeight() : rightBitmap.getHeight();
    }

    // 缩放之后的bitmap
    Bitmap tempBitmapL = leftBitmap;
    Bitmap tempBitmapR = rightBitmap;

    if (leftBitmap.getHeight() != height) {
        tempBitmapL = Bitmap.createScaledBitmap(leftBitmap, (int)(leftBitmap.getWidth()*1f/leftBitmap.getHeight()*height), height, false);
    } else if (rightBitmap.getHeight() != height) {
        tempBitmapR = Bitmap.createScaledBitmap(rightBitmap, (int)(rightBitmap.getWidth()*1f/rightBitmap.getHeight()*height), height, false);
    }

    // 拼接后的宽度
    int width = tempBitmapL.getWidth() + tempBitmapR.getWidth();

    // 定义输出的bitmap
    Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);
    Canvas canvas = new Canvas(bitmap);

    // 缩放后两个bitmap需要绘制的参数
    Rect leftRect = new Rect(0, 0, tempBitmapL.getWidth(), tempBitmapL.getHeight());
    Rect rightRect  = new Rect(0, 0, tempBitmapR.getWidth(), tempBitmapR.getHeight());

    // 右边图需要绘制的位置，往右边偏移左边图的宽度，高度是相同的
    Rect rightRectT  = new Rect(tempBitmapL.getWidth(), 0, width, height);

    canvas.drawBitmap(tempBitmapL, leftRect, leftRect, null);
    canvas.drawBitmap(tempBitmapR, rightRect, rightRectT, null);
    return bitmap;
}


/**
 * 把两个位图覆盖合成为一个位图，上下拼接
 * @param leftBitmap 
 * @param rightBitmap 
 * @param isBaseMax 是否以高度大的位图为准，true则小图等比拉伸，false则大图等比压缩
 * @return
 */
public static Bitmap mergeBitmap_TB(Bitmap topBitmap, Bitmap bottomBitmap, boolean isBaseMax) {

    if (topBitmap == null || topBitmap.isRecycled() 
            || bottomBitmap == null || bottomBitmap.isRecycled()) {
        JDLog.logError(TAG, &quot;topBitmap=&quot; + topBitmap + &quot;;bottomBitmap=&quot; + bottomBitmap);
        return null;
    }
    int width = 0;
    if (isBaseMax) {
        width = topBitmap.getWidth() &gt; bottomBitmap.getWidth() ? topBitmap.getWidth() : bottomBitmap.getWidth();
    } else {
        width = topBitmap.getWidth() &lt; bottomBitmap.getWidth() ? topBitmap.getWidth() : bottomBitmap.getWidth();
    }
    Bitmap tempBitmapT = topBitmap;
    Bitmap tempBitmapB = bottomBitmap;

    if (topBitmap.getWidth() != width) {
        tempBitmapT = Bitmap.createScaledBitmap(topBitmap, width, (int)(topBitmap.getHeight()*1f/topBitmap.getWidth()*width), false);
    } else if (bottomBitmap.getWidth() != width) {
        tempBitmapB = Bitmap.createScaledBitmap(bottomBitmap, width, (int)(bottomBitmap.getHeight()*1f/bottomBitmap.getWidth()*width), false);
    }

    int height = tempBitmapT.getHeight() + tempBitmapB.getHeight();

    Bitmap bitmap = Bitmap.createBitmap(width, height, Config.ARGB_8888);
    Canvas canvas = new Canvas(bitmap);

    Rect topRect = new Rect(0, 0, tempBitmapT.getWidth(), tempBitmapT.getHeight());
    Rect bottomRect  = new Rect(0, 0, tempBitmapB.getWidth(), tempBitmapB.getHeight());

    Rect bottomRectT  = new Rect(0, tempBitmapT.getHeight(), width, height);

    canvas.drawBitmap(tempBitmapT, topRect, topRect, null);
    canvas.drawBitmap(tempBitmapB, bottomRect, bottomRectT, null);
    return bitmap;
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/25/Android/Android-Studio-运行-Java代码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/25/Android/Android-Studio-运行-Java代码/" itemprop="url">Android Studio 运行 Java代码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-25T11:45:08+08:00">
                2018-05-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="修改启动方式"><a href="#修改启动方式" class="headerlink" title="修改启动方式"></a>修改启动方式</h1><p>目前有2种方法 :</p>
<h2 id="右键运行方法"><a href="#右键运行方法" class="headerlink" title="右键运行方法"></a>右键运行方法</h2><p>在Java文件中添加main方法，  鼠标点击到main方法里任意地方，然后点击鼠标右键，选择Run ‘MainActivity main()’或者Debug ‘MainActivity main’就行了</p>
<pre><code>public static void main(String[] args) {
       System.out.println(&quot;ok&quot;);
   }
</code></pre><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><pre><code>Error:Gradle: failed to create directory &apos;D:\AndroidProject\app\build\generated\source\r\debug\com\example\test&apos;.
</code></pre><p>Android Studio 3.0，在项目的 gradle.properties 中添加 android.enableAapt2=false 即可</p>
<h2 id="Java-Library"><a href="#Java-Library" class="headerlink" title="Java Library"></a>Java Library</h2><p>new Module – Java Library</p>
<p>运行处有个下拉小箭头，点击Edit Configuration – Add New Configuration – Application</p>
<pre><code>Name 名字随便，这里取名Java
Main class 填要运行的Java类路径
Use class of Module 选择lib名字
</code></pre><p>运行处选择运行方式为Java， 然后点击绿色运行按钮就行了</p>
<h1 id="直接创建JAVA文件"><a href="#直接创建JAVA文件" class="headerlink" title="直接创建JAVA文件"></a>直接创建JAVA文件</h1><p>类文件上右键 ，<code>Run &#39;MainClass.mian()&#39;</code></p>
<h1 id="使用Gradle编译和运行Java程序"><a href="#使用Gradle编译和运行Java程序" class="headerlink" title="使用Gradle编译和运行Java程序"></a>使用Gradle编译和运行Java程序</h1><p>build.gradle</p>
<pre><code>apply plugin: &apos;java&apos;  
apply plugin: &apos;application&apos;  

mainClassName = &apos;com.binwin20.testjava.Main&apos; // main() 的路径
</code></pre><p>运行java</p>
<pre><code>gradle -q run  
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/24/Android/AndroidManifest合并原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/24/Android/AndroidManifest合并原理/" itemprop="url">AndroidManifest合并原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-24T18:44:53+08:00">
                2018-05-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://mouxuejie.com/blog/2016-02-05/androidmanifest-merge/" target="_blank" rel="noopener">AndroidManifest合并原理</a></p>
<p><a href="https://developer.android.com/studio/build/manifest-merge?hl=zh-cn" target="_blank" rel="noopener">官网 manifest-merge</a></p>
<p>APK 只能包含一个 AndroidManifest.xml 文件，但 Android Studio 项目可以包含多个文件（通过主源集、构建变体和导入的库提供）。因此，在构建应用时，Gradle 构建会将所有清单文件合并到一个清单文件中。</p>
<p>清单合并工具通过遵循某些<strong>合并冲突启发式算法</strong>，和 <strong>合并首选项</strong>(通过特殊 XML 属性定义)，来合并各个文件中的所有 XML 元素 。</p>
<h1 id="合并优先级"><a href="#合并优先级" class="headerlink" title="合并优先级"></a>合并优先级</h1><p><strong>从优先级最低的文件合并至优先级最高的文件</strong></p>
<img src="/2018/05/24/Android/AndroidManifest合并原理/manifest-merger_priority.png">
<h2 id="库清单文件"><a href="#库清单文件" class="headerlink" title="库清单文件"></a>库清单文件</h2><p>多个库，则其清单优先级与依赖顺序（库出现在 Gradle dependencies 块中的顺序，由高到低）匹配</p>
<h2 id="构建变体"><a href="#构建变体" class="headerlink" title="构建变体"></a>构建变体</h2><p>变体有多个源集，则其清单优先级如下(由高到低)：</p>
<ul>
<li>构建变体清单（如 src/demoDebug/）</li>
<li>构建类型清单（如 src/debug/）</li>
<li>产品定制清单（如 src/demo/）</li>
</ul>
<p>如果使用的是定制维度，清单优先级将与每个维度在 flavorDimensions 属性中的列示顺序(由高到低)对应。</p>
<h1 id="合并冲突启发式算法"><a href="#合并冲突启发式算法" class="headerlink" title="合并冲突启发式算法"></a>合并冲突启发式算法</h1><h2 id="默认合并规则"><a href="#默认合并规则" class="headerlink" title="默认合并规则"></a>默认合并规则</h2><img src="/2018/05/24/Android/AndroidManifest合并原理/merge.png">
<h3 id="编码原则：不依赖于默认属性值"><a href="#编码原则：不依赖于默认属性值" class="headerlink" title="编码原则：不依赖于默认属性值"></a>编码原则：不依赖于默认属性值</h3><p>高优先级清单实际上依赖于属性的默认值而不需要声明，则可能会导致意外结果。</p>
<p>例如，高优先级清单不声明android:launchMode 属性，则会使用 “standard” 的默认值；但如果低优先级清单声明此属性具有其他值，该值将应用于合并清单（替代默认值）。因此，您应该按期望明确定义每个属性。（每个属性的默认值都会记录在 <a href="https://developer.android.com/guide/topics/manifest/manifest-intro?hl=zh-cn" target="_blank" rel="noopener">Manifest reference</a> 中）。</p>
<h2 id="合并工具为减少合并冲突的特殊规则"><a href="#合并工具为减少合并冲突的特殊规则" class="headerlink" title="合并工具为减少合并冲突的特殊规则"></a>合并工具为减少合并冲突的特殊规则</h2><ul>
<li><code>&lt;manifest&gt;</code>元素的属性绝不合并—仅使用优先级最高的清单中的属性。</li>
<li><code>&lt;uses-feature&gt;</code>元素 <code>&lt;uses-library&gt;</code>元素<code>android:required</code>属性 使用 <strong>OR</strong> 合并，因此如果出现冲突，系统将应用 “true” 并始终包括某个清单所需的功能或库。</li>
<li><code>&lt;uses-sdk&gt;</code>元素始终使用较高优先级的清单中的值，但以下情况有些特殊：<ul>
<li>minSdkVersion，低优先级清单的值 较高<ul>
<li>默认，使用 低优先级清单的值</li>
<li>应用 overrideLibrary 合并规则，使用 较高优先级的清单中的值</li>
</ul>
</li>
<li>targetSdkVersion，低优先级清单的值 较低<ul>
<li>合并工具将使用高优先级清单中的值</li>
<li>但也会添加任何必要的系统权限，以确保所导入的库继续正常工作<ul>
<li>适用于 较高的 Android 版本需要更多权限限制的情况。 如需了解有关此行为的详细信息，请参阅有关隐式系统权限的部分。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>&lt;intent-filter&gt;</code>元素。 每个元素都被视为唯一元素，直接添加至合并清单中的常用父元素。</li>
</ul>
<h1 id="合并规则标记"><a href="#合并规则标记" class="headerlink" title="合并规则标记"></a>合并规则标记</h1><ul>
<li>是什么：是一个 XML 属性</li>
<li>作用：标记如何解决合并冲突和属性的首选项</li>
<li>作用域：整个元素或元素的特定属性</li>
<li>合并工具会在高优先级清单文件中寻找这些标记</li>
<li>所有标记均属于 Android <code>tools</code> 命名空间，必须先在 <code>&lt;manifest&gt;</code>元素中声明此命名空间</li>
</ul>
<h2 id="元素-节点标记"><a href="#元素-节点标记" class="headerlink" title="元素/节点标记"></a>元素/节点标记</h2><p><strong>tools:node=”xx”</strong></p>
<ul>
<li><strong>merge</strong> <ul>
<li>元素的默认行为</li>
<li>合并所有属性以及所有嵌套元素。 例如：<code>&lt;activity&gt;</code> 嵌套 <code>&lt;intent-filter&gt;</code></li>
</ul>
</li>
<li><strong>merge-only-attributes</strong><ul>
<li>仅合并属性，不合并嵌套元素</li>
</ul>
</li>
<li><strong>remove</strong></li>
</ul>
<h1 id="Manifest-merger-failed-解决"><a href="#Manifest-merger-failed-解决" class="headerlink" title="Manifest merger failed 解决"></a>Manifest merger failed 解决</h1><p>编译报错：</p>
<p><code>Manifest merger failed with multiple errors, see logs</code></p>
<p>用下面的命令查看详细日志，分析到底是什么东西冲突了</p>
<p><code>gradlew processDebugManifest --stacktrace</code></p>
<p>这个命令比 <code>./gradlew assembleDebug --stacktrace -info</code> 更加轻量（后者用于展示整个编译过程的错误详情）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; Task :app:processDebugManifest FAILED</span><br><span class="line">D:\aspjs\kinland\app\src\main\AndroidManifest.xml:14:5-67 Warning:</span><br><span class="line">        Element uses-permission#android.permission.INTERNET at AndroidManifest.xml:14:5-67 duplicated with element declared at AndroidManifest.xml:6:5-67</span><br><span class="line">D:\aspjs\kinland\app\src\main\AndroidManifest.xml:25:9-47 Error:</span><br><span class="line">        Attribute application@icon value=(@mipmap/ic_launcher_new) from AndroidManifest.xml:25:9-47</span><br><span class="line">        is also present at [com.github.**:v1.0.1] AndroidManifest.xml:13:9-43 value=(@mipmap/ic_launcher).</span><br><span class="line">        Suggestion: add &apos;tools:replace=&quot;android:icon&quot;&apos; to &lt;application&gt; element at AndroidManifest.xml:22:5-125:19 to override.</span><br><span class="line">D:\aspjs\kinland\app\src\main\AndroidManifest.xml:27:9-58 Error:</span><br><span class="line">        Attribute application@roundIcon value=(@mipmap/ic_launcher_round_new) from AndroidManifest.xml:27:9-58</span><br><span class="line">        is also present at [com.github.**] AndroidManifest.xml:15:9-54 value=(@mipmap/ic_launcher_round).</span><br><span class="line">        Suggestion: add &apos;tools:replace=&quot;android:roundIcon&quot;&apos; to &lt;application&gt; element at AndroidManifest.xml:22:5-125:19 to override.</span><br><span class="line"></span><br><span class="line">See http://g.co/androidstudio/manifest-merger for more information about the manifest merger.</span><br></pre></td></tr></table></figure>
<p>日志上可以看出来有两个字段冲突了，并且给出了提示，这里直接加上就好了，两个字段的话中间用逗号分隔</p>
<p><code>tools:replace=&quot;android:icon,android:roundIcon&quot;</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/24/Android/Android系统版本适配/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/24/Android/Android系统版本适配/" itemprop="url">Android系统版本适配</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-24T18:40:36+08:00">
                2018-05-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="FileProvider替代file-Uri"><a href="#FileProvider替代file-Uri" class="headerlink" title="FileProvider替代file://Uri"></a>FileProvider替代file://Uri</h1><p>不再允许在app中把file://Uri暴露给其他app，包括但不局限于通过Intent或ClipData 等方法</p>
<p>Android7 提供了FileProvider，使用它生成content://Uri来替代file://Uri。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>使用file://Uri会有一些风险，比如：</p>
<ul>
<li>文件是私有的，接收file://Uri的app无法访问该文件。</li>
<li>Android6.0引入运行时权限，如果接收file://Uri的app没有申请READ_EXTERNAL_STORAGE权限，在读取文件时会引发崩溃。</li>
</ul>
<h2 id="FileProvider"><a href="#FileProvider" class="headerlink" title="FileProvider"></a>FileProvider</h2><p>manifest application节点下</p>
<pre><code>&lt;provider
    android:authorities=&quot;${applicationId}.fileProvider&quot;
    android:exported=&quot;false&quot;
    android:grantUriPermissions=&quot;true&quot;&gt;
    &lt;meta-data
        android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;
        android:resource=&quot;@xml/provider_paths&quot;/&gt;
&lt;/provider&gt;
</code></pre><p>res/xml/provider_paths.xml 指定路径和转换规则</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;files-path name=&quot;cache_pdf&quot; path=&quot;cache/pdf/&quot;/&gt;
    &lt;external-files-path name=&quot;external_cache_pdf&quot; path=&quot;cache/pdf/&quot;/&gt;
    &lt;external-path name=&quot;external_image&quot; path=&quot;zywx/image/&quot;/&gt;
&lt;/paths&gt;
</code></pre><p>代码</p>
<pre><code>//Uri photoOutputUri = Uri.fromFile(photoOutputFile);
Uri photoOutputUri = FileProvider.getUriForFile(
                    mContext,
                    mActivity.getPackageName() + &quot;.fileprovider&quot;,
                    photoOutputFile);
            intent.putExtra(MediaStore.EXTRA_OUTPUT, photoOutputUri);
</code></pre><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>android.support.v4.content.FileProvider 类只可以在manifest中注册一次。就如同一个Activity只可以注册一次一样</p>
<pre><code>Error:
    Element provider#android.support.v4.content.FileProvider at AndroidManifest.xml:119:9-131:20 duplicated with element declared at AndroidManifest.xml:105:9-117:20
</code></pre><p>一些第三方sdk为了适配android 7 也添加了这个节点</p>
<p>解决方案：</p>
<ul>
<li>自定义类 继承自FileProvider</li>
<li>使用合并规则替换resource为我们的xml，然后把第三方sdk中的路径配置copy到provider_paths.xml<ul>
<li>如果 authorities 不一致，就是利用合并规则替换了，也会报错。因为第三方库java代码大概率写死了 authorities。<ul>
<li>代码不要写死 authorities，从manifest动态获取</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul>
<li><p>FileUriExposedException</p>
<pre><code>android.os.FileUriExposedException: file:///storage/emulated/0/Android/data/com.zy.course.dev/1467180514061025%23kefuchannelapp54752/test_22616/video/1527152182117.mp4 exposed beyond app through Intent.getData()
    at android.os.StrictMode.onFileUriExposed(StrictMode.java:1799)
    at android.net.Uri.checkFileUriExposed(Uri.java:2346)
</code></pre><ul>
<li>解决方案：使用FileProvider代替Uri.fromFile</li>
</ul>
</li>
</ul>
<ul>
<li>java.lang.SecurityException: Provider must not be exported<ul>
<li>解决方案：android:exported必须设置成false</li>
</ul>
</li>
</ul>
<ul>
<li>Attempt to invoke virtual method ‘android.content.res.XmlResourceParser android.content.pm.PackageItemInfo.loadXmlMetaData(android.content.pm.PackageManager, java.lang.String)’ on a null object reference<ul>
<li>解决方案：AndroidManifest.xml处的android:authorities必须跟 mActivity.getPackageName() + “.fileProvider” 一样</li>
</ul>
</li>
</ul>
<h1 id="AlarmManager"><a href="#AlarmManager" class="headerlink" title="AlarmManager"></a>AlarmManager</h1><h2 id="定时任务的最佳实践"><a href="#定时任务的最佳实践" class="headerlink" title="定时任务的最佳实践"></a>定时任务的最佳实践</h2><ul>
<li>Handler 依赖于 Handler 所在的线程的，如果线程结束，就起不到定时任务的效果；</li>
<li>Timer 手机关屏后长时间不使用，CPU 就会进入休眠模式。Timer 无法唤醒 CPU，定时任务就会失败</li>
<li>AlarmManager 依赖 Android 系统服务，具备唤醒机制</li>
</ul>
<p>AlarmManager实质是一个全局的定时器，是Android中常用的一种系统级别的提示服务，在指定时间或周期性发送<code>PendingIntent</code>广播  启动其它组件（包括Activity,Service,BroadcastReceiver）</p>
<h2 id="版本适配"><a href="#版本适配" class="headerlink" title="版本适配"></a>版本适配</h2><p>查阅 <a href="https://developer.android.google.cn/about/versions/android-4.4" target="_blank" rel="noopener">Android官网中关于 Android 4.4 变更</a>发现Google 为了追求系统省电，<code>set()</code> 或 <code>setRepeating()</code> 创建的闹铃将变得不准确。还要追求精准的闹钟定时任务，要使用 <code>setExact()</code> 方法</p>
<p><a href="https://developer.android.google.cn/about/versions/marshmallow/android-6.0-changes" target="_blank" rel="noopener">查阅 Android官网中关于 Android 6.0 变更</a> ，发现在 Android 6.0 中引入了低电耗模式和应用待机模式，标准 AlarmManager 闹铃（包括 <code>setExact()</code> 和 <code>setWindow()</code>）推迟到下一维护时段。<br>如果您需要设置在低电耗模式下触发的闹铃，请使用 <code>setAndAllowWhileIdle()</code> 或 <code>setExactAndAllowWhileIdle()</code>。触发闹铃的时间间隔都不能超过 9 分钟</p>
<pre><code>public static void setAlarmTimer(Context context, long triggerAtMillis,
                                 String action, int AlarmManagerType, int alarmId, String tutorTeacherName) {
    Intent myIntent = new Intent();
    myIntent.putExtra(&quot;tutorTeacherName&quot;, tutorTeacherName);//闹铃广播可以传递数据
    myIntent.setAction(action);
    PendingIntent pendingIntent = PendingIntent.getBroadcast(context, alarmId, myIntent, 0);
    AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);

    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {
        alarmManager.setExactAndAllowWhileIdle(AlarmManagerType, triggerAtMillis, pendingIntent);
    } else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
        alarmManager.setExact(AlarmManagerType, triggerAtMillis, pendingIntent);
    } else {
        alarmManager.set(AlarmManagerType, triggerAtMillis, pendingIntent);
    }
}

public static void cancelAlarmTimer(Context context, String action) {
    Intent myIntent = new Intent();
    myIntent.setAction(action);
    PendingIntent sender = PendingIntent.getBroadcast(context, 0, myIntent, 0);
    AlarmManager alarm = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
    alarm.cancel(sender);
}
</code></pre><p>广播接收者接收闹铃广播</p>
<pre><code>public class AlarmReceiver extends BroadcastReceiver {
    public final static String TIMER_ACTION_REPEATING = &quot;com.shensz.TIMER_ACTION_REPEATING&quot;;// 周期性的闹钟
    public final static String TIMER_ACTION = &quot;com.shensz.TIMER_ACTION&quot;;// 定时闹钟

    @Override
    public void onReceive(Context context, Intent intent) {
        if (intent.getAction().equals(TIMER_ACTION_REPEATING)) {
        } else if (intent.getAction().equals(TIMER_ACTION)) {
            String tutorTeacherName = intent.getStringExtra(&quot;tutorTeacherName&quot;);
            if (!TextUtils.isEmpty(tutorTeacherName)) {
                sendNotification(context, tutorTeacherName);
            }
        }
    }

}
</code></pre><p>注册广播接收者</p>
<pre><code>    &lt;receiver android:name=&quot;com.shensz.course.module.main.AlarmReceiver&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;com.shensz.TIMER_ACTION_REPEATING&quot; /&gt;
        &lt;action android:name=&quot;com.shensz.TIMER_ACTION&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
</code></pre><h2 id="int-type-和-long-triggerAtMillis"><a href="#int-type-和-long-triggerAtMillis" class="headerlink" title="int type 和 long triggerAtMillis"></a>int type 和 long triggerAtMillis</h2><p>这个需要注意文档的描述。不留神triggerAtMillis没有加上基准时间(根据type而不同)，就会发现广播都是马上触发(因为触发时间已过，所以马上发送广播)</p>
<p>type：闹钟类型</p>
<ul>
<li>ELAPSED_REALTIME：<ul>
<li>在指定的延时过后，发送广播，但不唤醒设备（闹钟在睡眠状态下不可用）。如果在系统休眠时闹钟触发，它将不会被传递，直到下一次设备唤醒。</li>
<li>延时是要把系统启动到现在的时间SystemClock.elapsedRealtime()(基准时间)算进去的。</li>
</ul>
</li>
<li>ELAPSED_REALTIME_WAKEUP：<ul>
<li>同上，唯一区别就是 会唤醒设备</li>
</ul>
</li>
<li>RTC：<ul>
<li>当系统调用System.currentTimeMillis()方法返回的值等于triggerAtTime时，发送广播，但不唤醒设备。<ul>
<li>可以设置系统时间触发闹铃广播</li>
</ul>
</li>
</ul>
</li>
<li>RTC_WAKEUP：<ul>
<li>同上，唯一区别就是 会唤醒设备</li>
</ul>
</li>
<li>POWER_OFF_WAKEUP：<ul>
<li>闹钟在手机关机状态下也能正常进行提示功能，所以是5个状态中用的最多的状态之一</li>
<li>该状态下闹钟也是用绝对时间，状态值为4；不过本状态好像受SDK版本影响，某些版本并不支持。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<pre><code>AlarmManager.RTC，System.currentTimeMillis()+10 * 60 * 1000
AlarmManager.ELAPSED_REALTIME，SystemClock.elapsedRealtime()+10 * 60 * 1000
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/Android/Android开发流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/Android/Android开发流程/" itemprop="url">Android开发流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T16:44:42+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p>需求预审 → 需求评审 → 需求分解</p>
<p>→ 需求开发 → 自测 → 静态代码检查   </p>
<p>→ 提测预发布包 →  QA测试验证  </p>
<p>→ 逐步放量灰度及异常数据观察→ hotfix修复灰度中的问题</p>
<p>→  全渠道发布经过灰度验证后的版本（灰度中的问题已修复）→  异常数据观察 </p>
<p>→ 版本总结</p>
<h2 id="需求分解："><a href="#需求分解：" class="headerlink" title="需求分解："></a>需求分解：</h2><p>1）根据需求文档<strong>分解需求</strong>，分清需求的<strong>优先级</strong>，评估需求<strong>工作量</strong></p>
<p>2）罗列需求的<strong>前置条件及关联方</strong>，联系关联方确定前置条件的<strong>交付时间</strong></p>
<p>3）对于<strong>不确定因素和风险点</strong>，需同步出来并作为预估<strong>版本交付时间</strong>的依据。</p>
<p>4）根据前面的工作，结合现有人力，安排需求分工，<strong>预估版本交付时间</strong></p>
<h2 id="需求开发："><a href="#需求开发：" class="headerlink" title="需求开发："></a>需求开发：</h2><p>每天关注版本<strong>进度是否正常</strong>，及时发现风险，争取资源解决</p>
<h2 id="QA测试验证："><a href="#QA测试验证：" class="headerlink" title="QA测试验证："></a>QA测试验证：</h2><p>1）提交云测平台进行安装卸载monkey测试</p>
<p>2）功能测试</p>
<p>3）视情况进行其他专项测试</p>
<p>从CI（<a href="http://ci.xxx.local/job/xxx_android_release/）中提取发布包，并将发版记录登记到Android卓越网校钉钉群" target="_blank" rel="noopener">http://ci.xxx.local/job/xxx_android_release/）中提取发布包，并将发版记录登记到Android卓越网校钉钉群</a> 里面。</p>
<h2 id="逐步放量灰度及异常数据观察"><a href="#逐步放量灰度及异常数据观察" class="headerlink" title="逐步放量灰度及异常数据观察"></a>逐步放量灰度及异常数据观察</h2><p>通过bugly提供的<strong>灰度功能进行逐步放量</strong>，并对异常数据（崩溃率、ANR率、错误率）进行观察</p>
<p>灰度更新策略 <a href="https://bugly.qq.com" target="_blank" rel="noopener">https://bugly.qq.com</a> </p>
<p>hotfix修复灰度中的问题</p>
<p>Hotfix使用说明</p>
<p><a href="https://bugly.qq.com" target="_blank" rel="noopener">https://bugly.qq.com</a></p>
<p>（bugly账号目前由 xxx 保管）</p>
<p>部分应用市场需要加固上传提审，可以通过 <a href="http://console.qcloud.com/legu" target="_blank" rel="noopener">http://console.qcloud.com/legu</a> 腾讯乐固加固应用。</p>
<h2 id="全渠道发布"><a href="#全渠道发布" class="headerlink" title="全渠道发布"></a>全渠道发布</h2><p>1）官网渠道</p>
<p>官网下载地址指向公司OSS地址，所以更新名为android-xxx-cn的bucket下的xxx_release.apk文件。</p>
<p>2）应用商店渠道</p>
<p>现在上线的商店有 应用宝/华为/小米/360/百度，相关账号，目前由 xxx 保管。</p>
<p>3）检查更新渠道</p>
<p>将bugly的灰度更新量提到不限下载量</p>
<h2 id="版本总结"><a href="#版本总结" class="headerlink" title="版本总结"></a>版本总结</h2><p>1）异常经验集的完善</p>
<p>2）总结开发过程中的不足及改进点</p>
<h1 id="质量保障体系"><a href="#质量保障体系" class="headerlink" title="质量保障体系"></a>质量保障体系</h1><p>避免问题-&gt;发现问题-&gt;排查问题-&gt;解决问题-&gt;补救问题</p>
<p>问题的定义：对于用户造成了影响，增加其不必要的使用成本的都叫做问题</p>
<p>1.避免问题</p>
<p><strong>异常处理经验集</strong>的丰富完善</p>
<p><strong>代码规范</strong></p>
<p>静态<strong>代码检查</strong></p>
<p>2.发现问题</p>
<p><strong>异常数据收集</strong></p>
<p><strong>灰度验证</strong>（提前发现问题，缩小问题影响面）</p>
<p>3.排查问题</p>
<p>数据<strong>统计打点</strong>，数据分析，还原用户操作路径</p>
<p>4.解决问题</p>
<p><strong>Hotfix</strong>(加速修复问题)</p>
<p>5.补救问题</p>
<p>观察问题<strong>是否造成用户流失</strong>，通过短信或推送等方式通知用户已解决问题，并观察数据</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/逆向/Android/Hook/Android-Hook原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/逆向/Android/Hook/Android-Hook原理/" itemprop="url">Android Hook原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T16:44:42+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.sanwho.com/248.html" target="_blank" rel="noopener">Android inline hook之原理分析篇 </a></p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">修改GOT</th>
<th style="text-align:left">inLine</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">实现难易</td>
<td style="text-align:left">比较容易，只需知道elf文件中调用外部符号的地址</td>
<td style="text-align:left">比较难，需要分析函数实现汇编码，保持堆栈平衡</td>
</tr>
<tr>
<td style="text-align:left">使用频率</td>
<td style="text-align:left">基本都是用此方式</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">功能强弱</td>
<td style="text-align:left">比较弱，只能hookGOT调用方式（通过java层调用API真实实现代码）</td>
<td style="text-align:left">很强大，能hookjni调用真实实现API的方式</td>
</tr>
<tr>
<td style="text-align:left">R11</td>
<td style="text-align:left">fp</td>
<td style="text-align:left">桢指针</td>
</tr>
<tr>
<td style="text-align:left">R12</td>
<td style="text-align:left">ip</td>
<td style="text-align:left">指令指针，内部过程调用寄存器</td>
</tr>
<tr>
<td style="text-align:left">R13</td>
<td style="text-align:left">sp</td>
<td style="text-align:left">栈指针</td>
</tr>
<tr>
<td style="text-align:left">R14</td>
<td style="text-align:left">lr</td>
<td style="text-align:left">返回地址，连接寄存器</td>
</tr>
<tr>
<td style="text-align:left">R15</td>
<td style="text-align:left">pc</td>
<td style="text-align:left">程序计数器</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/27/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><span class="page-number current">28</span><a class="page-number" href="/page/29/">29</a><span class="space">&hellip;</span><a class="page-number" href="/page/31/">31</a><a class="extend next" rel="next" href="/page/29/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="风" />
            
              <p class="site-author-name" itemprop="name">风</p>
              <p class="site-description motion-element" itemprop="description">随心而动，随刃而行</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">310</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">71</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">风</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
