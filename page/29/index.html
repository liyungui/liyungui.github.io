<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="随心而动，随刃而行">
<meta property="og:type" content="website">
<meta property="og:title" content="风">
<meta property="og:url" content="http://yoursite.com/page/29/index.html">
<meta property="og:site_name" content="风">
<meta property="og:description" content="随心而动，随刃而行">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="风">
<meta name="twitter:description" content="随心而动，随刃而行">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/29/"/>





  <title>风</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">风</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">技术博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/逆向/Android/Hook/android-hook框架/VirtualApp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/逆向/Android/Hook/android-hook框架/VirtualApp/" itemprop="url">VirtualApp</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T16:44:42+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://bbs.pediy.com/thread-216786.htm" target="_blank" rel="noopener">VirtualHook: 基于VirtualApp的Java代码hook工具</a></p>
<p>在ART模式下安装Xposed，不仅要求root权限，而且需要替换大量的系统库，因此其使用门槛大幅提高。</p>
<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p><a href="https://github.com/rk700/VirtualHook" target="_blank" rel="noopener">VirtualHook</a>是基于以下两个框架实现的：</p>
<ol>
<li><strong>VirtualApp</strong>，这是一套插件框架，允许应用以插件的方式运行在其构造的虚拟空间中，而无需实际安装应用。<strong>通过VirtualApp实现非root环境下注入窗口的添加</strong></li>
<li><strong>YAHFA</strong>，这是一套hook框架，实现了ART环境下的Java方法hook</li>
</ol>
<h2 id="VirtualApp"><a href="#VirtualApp" class="headerlink" title="VirtualApp"></a><a href="https://github.com/asLody/VirtualApp" target="_blank" rel="noopener">VirtualApp</a></h2><p>hook就是在应用运行过程中，注入外部的代码，从而改变原有的执行流程。</p>
<p>因此，应用中必须存在注入代码的窗口。</p>
<p>Xposed便是这样做的：它修改了系统库，对所有应用在启动时添加了注入窗口。但是，这就需要具有root权限。</p>
<p><a href="http://rk700.github.io/2017/03/15/virtualapp-basic/" target="_blank" rel="noopener">VirtualApp的工作原理</a>简而言之，它通过代理常用系统服务的方式，在系统服务层与应用层之间添加了一层虚拟空间，从而允许在不安装应用的情况下运行应用。特别地，VirtualApp本身并不需要root权限。</p>
<p>利用VirtualApp提供的虚拟空间，我们就可以实现很多事情了。应用启动时，会初始化Application，此时会在应用所在的进程中调用bindApplication()。而VirtualApp重写了相关代码，那么我们就可以在把注入代码的窗口放在这里，从而实现应用启动时，加载外部的hook代码。</p>
<p>所以，本文所说的非root权限hook应用，更准确来说，hook的是在VirtualApp中运行的应用。</p>
<h2 id="YAHFA-Yet-Another-Hook-Framework-for-ART"><a href="#YAHFA-Yet-Another-Hook-Framework-for-ART" class="headerlink" title="YAHFA (Yet Another Hook Framework for ART)"></a><a href="https://github.com/rk700/YAHFA" target="_blank" rel="noopener">YAHFA (Yet Another Hook Framework for ART)</a></h2><p>我们调研了几款hook框架，包括Xposed, AndFix和Legend，但发现如果在这里使用的话，多少都存在一定的问题：</p>
<ol>
<li>Xposed需要进行大量的代码变更，过于复杂，而且方法执行的额外开销会增多</li>
<li><a href="https://github.com/alibaba/AndFix" target="_blank" rel="noopener">AndFix</a>的代码量相对较小，但其进行了方法的全部替换，不支持原方法的调用；对于热修复来说也许影响不大，但对于逆向分析来说，很多时候我们是通过hook来插桩，所以原方法必须要备份以执行</li>
<li><a href="https://github.com/asLody/legend" target="_blank" rel="noopener">Legend</a>与AndFix的实现方式基本一致，但试用后发现存在某些方法解析失败的问题</li>
</ol>
<p>于是，我们重新设计实现了一套hook框架YAHFA，专门用于这里的代码hook。<a href="http://rk700.github.io/2017/03/30/YAHFA-introduction/" target="_blank" rel="noopener">关于YAHFA的具体工作原理，可见这篇介绍</a>。</p>
<p>至此，我们有了插件框架和hook框架，将其简单地集成，便得到了最终的hook工具，VirtualHook。其具有如下优点：</p>
<ol>
<li>支持ART模式，事实上也只支持ART，因为这就是其设计的出发点，DVM模式下用Xposed就OK了。</li>
<li>无需root权限。由于我们是通过VirtualApp为应用添加代码注入窗口，所以不需要修改系统本身的库，因此不需要root权限，安装难度降低。</li>
<li>轻量。YAHFA的工作目标，就是高效地运行hook。hook方法执行所带来的额外开销仅有2、3条机器指令，执行原方法时甚至没有额外的开销。</li>
<li>方便。由于是在VirtualApp中完成hook，因此添加或删除hook插件后，不需要像Xposed那样重启设备，只需要退出目标应用再重新进入即可。</li>
<li>精细。理论上来说，可以加载多个hook插件，甚至对不同应用使用不同hook插件。配合VirtualApp应用多开，能够更精细地控制hook的行为。</li>
</ol>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>将hook apk保存到设备SD卡的指定位置 <code>/sdcard/io.virtualhook/patch.apk</code> 以待加载。</p>
<p>随后启动VirutalHook，在VirutalHook中 添加并运行应用。</p>
<h1 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h1><p>由于VirtualHook是VirtualApp与YAHFA的集成，因此其适用范围就是两者的交集：目前支持的系统是<strong>Android 5.1和6.0</strong>，支持的架构是<strong>armeabi和x86</strong>。由于VirtualHook的<strong>出发点是便于安全研究</strong>，因此适配度不是其考虑的主要问题</p>
<p>特别地，对于加固应用的hook，目前使用上述的demoHookPlugin试验了360，腾讯，梆梆和爱加密。除了梆梆之外，其他加固的应用均可被hook（爱加密把非错误的日志打印全部重定向了，所以必须通过Log.e()打印日志）。<strong>梆梆加固的应用，在VirtualApp上无法运行</strong>，因此作为其下游的VirtualHook，目前对梆梆加固的应用也无法使用。希望能够有人研究解决这一问题。</p>
<p>VirtualApp中自带了对native方法进行hook的功能，看雪上已经有利用该功能进行应用脱壳的实践了。后续可以将native hook一并整合起来，使VirtualHook的功能更强大</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/逆向/Android/Hook/android-hook框架/ADBI--Native InLine/adbi-hook原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/逆向/Android/Hook/android-hook框架/ADBI--Native InLine/adbi-hook原理/" itemprop="url">adbi hook原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T16:44:42+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.csdn.net/roland_sun/article/details/36049307" target="_blank" rel="noopener">Android平台下hook框架adbi的研究（下） </a></p>
<h1 id="native函数hook原理"><a href="#native函数hook原理" class="headerlink" title="native函数hook原理"></a>native函数hook原理</h1><p><strong>native函数hook要解决两个问题</strong></p>
<ol>
<li>找到这个函数在内存中的位置</li>
<li>修改函数偷梁换柱。</li>
</ol>
<p>读取“/proc/&lt;进程号&gt;/maps”内存映射文件，找到函数库的起始位置和路径。</p>
<p>mprotect()为该库内存段加上可写（PROT_WRITE）属性</p>
<p>打开库文件，解析出符号表，从符号表中找到目标函数（其后是偏移地址，加上库起始地址就是内存地址），接下来就是判断Arm与Thumb指令集，hook了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/逆向/Android/Hook/android-hook框架/ADBI--Native InLine/adbi注入原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/逆向/Android/Hook/android-hook框架/ADBI--Native InLine/adbi注入原理/" itemprop="url">adbi 注入原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T16:44:42+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.csdn.net/roland_sun/article/details/34109569" target="_blank" rel="noopener">Android平台下hook框架adbi的研究（上）</a></p>
<p><a href="https://github.com/crmulliner/adbi" target="_blank" rel="noopener">adbi源代码</a></p>
<p>Linux可以利用ptrace()函数来attach到一个进程上，从而可以修改对应该进程的内存内容和寄存器的值</p>
<p>adbi（The Android Dynamic Binary Instrumentation Toolkit）是一个通用的框架，使得hook变得异常简单。</p>
<h1 id="进程注入基本实现原理"><a href="#进程注入基本实现原理" class="headerlink" title="进程注入基本实现原理"></a>进程注入基本实现原理</h1><p>利用ptrace()attach到一个进程上，然后在进程调用序列中插入一个调用dlopen()加载so文件（初始化函数中hook指定的函数）的步骤。</p>
<p>adbi工具集由两个主要模块组成，分别是用于注入.so文件的进程劫持工具（hijack tool）和一个修改函数入口的基础库。</p>
<p>接下来，我们还是通过阅读代码来分别了解这两个模块的实现原理，本篇我们先将重点放在劫持工具的实现上。</p>
<p><strong>注入进程需要解决两个问题</strong></p>
<ol>
<li>获得目标进程dlopen()函数的调用地址</li>
<li>插入一个调用dlopen()函数的步骤到目标进程的调用序列中。</li>
</ol>
<h2 id="1-获得目标进程dlopen-函数的调用地址"><a href="#1-获得目标进程dlopen-函数的调用地址" class="headerlink" title="1. 获得目标进程dlopen()函数的调用地址"></a>1. 获得目标进程dlopen()函数的调用地址</h2><pre><code>----main()-----------------------------------------------------------------------
//在当前进程中dlopen()加载libdl.so动态库，接着用dlsym()函数获得当前进程dlopen()函数的调用地址
//libdl.so动态库肯定早已加载到当前进程中了，这里再加载一次并不会真的再在内存中的另一个位置加载一次，而是返回已经加载过的地址
void *ldl = dlopen(&quot;libdl.so&quot;, RTLD_LAZY);  
if (ldl) {  
    dlopenaddr = dlsym(ldl, &quot;dlopen&quot;);  
    dlclose(ldl);  
}  

unsigned long int lkaddr; //本进程linker地址。linker是Android提供的动态链接器，不同于普通的Linux。dlopen()函数就是在linker里面定义的（bionic/linker/dlfcn.cpp中: soinfo libdl_info = {&quot;libdl.so&quot;）  
unsigned long int lkaddr2; //目标进程linker地址   
find_linker(getpid(), &amp;lkaddr);  
find_linker(pid, &amp;lkaddr2);  

dlopenaddr = lkaddr2 + (dlopenaddr - lkaddr); //同一台机器上的进程肯定用的是同一个linker，所以其内部的dlopen()函数和linker头的偏移量是固定的

----find_linker()-----------------------------------------------------------------------
static int find_linker(pid_t pid, unsigned long *addr) {  
    struct mm mm[1000];  
    unsigned long libcaddr;  
    int nmm;  
    char libc[256];  
    symtab_t s;  

    if (0 &gt; load_memmap(pid, mm, &amp;nmm)) {  
        printf(&quot;cannot read memory map\n&quot;);  
        return -1;  
    }  
    if (0 &gt; find_linker_mem(libc, sizeof(libc), &amp;libcaddr, mm, nmm)) {  
        printf(&quot;cannot find libc\n&quot;);  
        return -1;  
    }  

    *addr = libcaddr;  

    return 1;  
} 

      ----load_memmap()-----------------------------------------------------------------------
    static int load_memmap(pid_t pid, struct mm *mm, int *nmmp) {  
        char raw[80000]; // this depends on the number of libraries an executable uses  
        char name[MAX_NAME_LEN];  
        char *p;  
        unsigned long start, end;  
        struct mm *m;  
        int nmm = 0;  
        int fd, rv;  
        int i;  

        //打开文件(路径是“/proc/&lt;进程号&gt;/maps”)读出指定进程的内存映射信息，其格式大概如下：
        sprintf(raw, &quot;/proc/%d/maps&quot;, pid);  
        fd = open(raw, O_RDONLY);  
        if (0 &gt; fd) {  
            printf(&quot;Can&apos;t open %s for reading\n&quot;, raw);  
            return -1;  
        }  

        //逐行读取内存映射信息文件的内容
        memset(raw, 0, sizeof(raw));  /* Zero to ensure data is null terminated */                
        p = raw;  
        while (1) {  
            rv = read(fd, p, sizeof(raw)-(p-raw));  
            if (0 &gt; rv) {  
                return -1;  
            }  
            if (0 == rv)  
                break;  
            p += rv;  
            if (p-raw &gt;= sizeof(raw)) {  
                printf(&quot;Too many memory mapping\n&quot;);  
                return -1;  
            }  
        }  
        close(fd);  

        //逐行解析内存映射信息文件的内容。文件格式如下：
        40096000-40098000 r-xp 00000000 b3:16 109        /system/bin/app_process  
        40098000-40099000 r--p 00001000 b3:16 109        /system/bin/app_process  
        40099000-4009a000 rw-p 00000000 00:00 0   
        4009a000-400a9000 r-xp 00000000 b3:16 176        /system/bin/linker  
        400a9000-400aa000 r--p 0000e000 b3:16 176        /system/bin/linker  
        400aa000-400ab000 rw-p 0000f000 b3:16 176        /system/bin/linker  
        400ab000-400ae000 rw-p 00000000 00:00 0   
        400ae000-400b0000 r--p 00000000 00:00 0   
        400b0000-400b9000 r-xp 00000000 b3:16 855        /system/lib/libcutils.so  
        be846000-be867000 rw-p 00000000 00:00 0          [stack] 
        p = strtok(raw, &quot;\n&quot;);  
        m = mm;  
        while (p) {  
            /* parse current map line */  
            rv = sscanf(p, &quot;%08lx-%08lx %*s %*s %*s %*s %s\n&quot;,  
                &amp;start, &amp;end, name);  //解析出当前行的 起始地址，结束地址，和名称。

            p = strtok(NULL, &quot;\n&quot;);  //获取下一行

            if (rv == 2) {  //没有解析出名称(只有两个返回值)，就会用一个自定义的名称补上（“[memory]”）
                m = &amp;mm[nmm++];  
                m-&gt;start = start;  
                m-&gt;end = end;  
                strcpy(m-&gt;name, MEMORY_ONLY);  
                continue;  
            }  

            if (strstr(name, &quot;stack&quot;) != 0) {  //名字是“stack”，表明这段内存用于栈
                stack_start = start;  
                stack_end = end;  
            }  

            //将连续的并且名字相同的内存段合并一下.(从前面的格式中可以看出，会有几行都叫一个名字的情况)
            /* search backward for other mapping with same name */  
            for (i = nmm-1; i &gt;= 0; i--) {  
                m = &amp;mm[i];  
                if (!strcmp(m-&gt;name, name))  
                    break;  
            }  

            if (i &gt;= 0) {  
                if (start &lt; m-&gt;start)  
                    m-&gt;start = start;  
                if (end &gt; m-&gt;end)  
                    m-&gt;end = end;  
            } else {  
                /* new entry */  
                m = &amp;mm[nmm++];  
                m-&gt;start = start;  
                m-&gt;end = end;  
                strcpy(m-&gt;name, name);  
        }  

        *nmmp = nmm;  
        return 0;  
    } 

    ----find_linker_mem()-----------------------------------------------------------------------
    static int find_linker_mem(char *name, int len, unsigned long *start, struct mm *mm, int nmm) {  
        int i;  
        struct mm *m;  
        char *p;  
        for (i = 0, m = mm; i &lt; nmm; i++, m++) {  
            if (!strcmp(m-&gt;name, MEMORY_ONLY))  
                continue;  
            p = strrchr(m-&gt;name, &apos;/&apos;);  
            if (!p)  
                continue;  
            p++;  
            if (strncmp(&quot;linker&quot;, p, 6))  //找出名字以“linker”结尾(/system/bin/linker)的那段内存的起始地址。
                continue;  
        break;  
        }  
        if (i &gt;= nmm)  
        /* not found */  
            return -1;  

        *start = m-&gt;start;  
        strncpy(name, m-&gt;name, len);  
        if (strlen(m-&gt;name) &gt;= len)  
            name[len-1] = &apos;\0&apos;;  
        return 0;  
    }  
</code></pre><h2 id="2-插入一个调用dlopen-函数的步骤到目标进程的调用序列中"><a href="#2-插入一个调用dlopen-函数的步骤到目标进程的调用序列中" class="headerlink" title="2. 插入一个调用dlopen()函数的步骤到目标进程的调用序列中"></a>2. 插入一个调用dlopen()函数的步骤到目标进程的调用序列中</h2><pre><code>// Attach 
if (0 &gt; ptrace(PTRACE_ATTACH, pid, 0, 0)) {//被Attach的进程将成为当前进程的子进程，并且会暂停执行。
    printf(&quot;cannot attach to %d, error!\n&quot;, pid);
    exit(1);
}
waitpid(pid, NULL, 0);//等待被Attach的进程暂停运行才返回
ptrace(PTRACE_GETREGS, pid, 0, &amp;regs); //获得目标进程的所有寄存器的值
//unsigned int sc[]
sc[11] = regs.ARM_r0;  
sc[12] = regs.ARM_r1;  
sc[13] = regs.ARM_r2;  
sc[14] = regs.ARM_r3;  
sc[15] = regs.ARM_lr;  
sc[16] = regs.ARM_pc;  
sc[17] = regs.ARM_sp;  
sc[19] = dlopenaddr;
// push library name to stack  
//case &apos;l&apos;: n = strlen(optarg)+1; n = n/4 + (n%4 ? 1 : 0); 
//命令行-l参数后就是so库完整名称。ptrace()写入目标进程以4字节为单位 
libaddr = regs.ARM_sp - n*4 - sizeof(sc);  
sc[18] = libaddr; 
// write library name to stack  
if (0 &gt; write_mem(pid, (unsigned long*)arg, n, libaddr)) {  
    printf(&quot;cannot write library name (%s) to stack, error!\n&quot;, arg);  
    exit(1);  
}  
// write code to stack  
codeaddr = regs.ARM_sp - sizeof(sc);  
if (0 &gt; write_mem(pid, (unsigned long*)&amp;sc, sizeof(sc)/sizeof(long), codeaddr)) {  
    printf(&quot;cannot write code, error!\n&quot;);  
    exit(1);  
}

    ----write_mem()-----------------------------------------------------------------------
    /* Write NLONG 4 byte words from BUF into PID starting at address POS.  Calling process must be attached to PID. */  
    static int write_mem(pid_t pid, unsigned long *buf, int nlong, unsigned long pos) {  
        unsigned long *p;  
        int i;  

        for (p = buf, i = 0; i &lt; nlong; p++, i++)  
            if (0 &gt; ptrace(PTRACE_POKETEXT, pid, pos+(i*4), *p))  
                return -1;  
        return 0;  
    }

mprotect()给栈内存段设置可执行属性。
    adbi采用了另一种方法找目标进程mprotect()内存地址。
    思路是分析ELF文件libc.so来获得其中符号mprotect的值（其实就是mprotect()函数相对于文件头的偏移），再加上libc.so文件在内存中映射的起始地址，就是mprotect()函数真正的调用地址了
// calc stack pointer  
regs.ARM_sp = regs.ARM_sp - n*4 - sizeof(sc);  

// call mprotect() to make stack executable  
regs.ARM_r0 = stack_start; // want to make stack executable  
regs.ARM_r1 = stack_end - stack_start; // stack size  
regs.ARM_r2 = PROT_READ|PROT_WRITE|PROT_EXEC; // protections  

regs.ARM_lr = codeaddr; // points to loading and fixing code  
regs.ARM_pc = mprotectaddr; // execute mprotect()

ptrace(PTRACE_SETREGS, pid, 0, &amp;regs);  
ptrace(PTRACE_DETACH, pid, 0, SIGCONT); //deAttach,让目标进程恢复运行 
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/逆向/Android/Hook/android-hook框架/Cydia-- Native Dalvik FrameWork/CydiaSubstrate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/逆向/Android/Hook/android-hook框架/Cydia-- Native Dalvik FrameWork/CydiaSubstrate/" itemprop="url">CydiaSubstrate</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T16:44:42+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Cydia Substrate可以修改任何主进程的代码，不管是用Java还是C/C++（native代码）编写的。而Xposed（开源）只支持 HOOK app_process中的java函数，因此Cydia Substrate是一款强大而实用的HOOK工具</p>
<p>Cydia Substrate</p>
<pre><code>参考自： 
    Android HOOK工具Cydia Substrate使用详解 http://mobile.51cto.com/aprogram-454091.htm
    周圣韬 Android上玩玩Hook：Cydia Substrate实战 http://www.csdn.net/article/2015-08-07/2825405 
Cydia Substrate原名MobileSubstrate（类库中都是以MS开头），
作者为大名鼎鼎的Jay Freeman（saurik）
Cydia Substrate框架对于inline Hook(框架实现都是通过该方式)的操作目前还是存在一些bug，
    使用的时候可能会出现崩溃的现象，
    部分使用了国内定制ROM的设备在使用Cydia Substrate框架时会造成设备无法重新启动或无法Hook的现象。
    无法重启可以按住音量+ 键 跳过hook插件，进入系统。
</code></pre><p>1.安装substrate.apk，点击”Link Substrate Files”（连接本地的Substrate服务文件），<br>    这一步是需要Root权限的，连接后还需要重启设备才能够生效<br>    <a href="http://www.cydiasubstrate.com/download/com.saurik.substrate.apk" target="_blank" rel="noopener">http://www.cydiasubstrate.com/download/com.saurik.substrate.apk</a></p>
<p>2.创建空Android工程。复制jar和so到libs文件夹中。<br>    其中的substrate.h头文件与lib文件夹下的so文件<br>        主要是substrate-api.jar<br>        .h和so是提供在使用NDK进行原生Hook程序开发中的函数支持库<br>    <a href="http://asdk.cydiasubstrate.com/zips/cydia_substrate-r2.zip" target="_blank" rel="noopener">http://asdk.cydiasubstrate.com/zips/cydia_substrate-r2.zip</a></p>
<p>3.Manifest文件配置 权限和hook类（入口）<br>（1）需要指定权限：cydia.permission.SUBSTRATE<br>        manifest下 <uses-permission android:name="cydia.permission.SUBSTRATE"><br>（2）添加meta-data标签，指定自定义的hook类<br>        application下 <meta-data android:name="com.saurik.substrate.main" android:value=".Main"><br>            name 固定，value就是我们自定义的hook类完整类名（包含包名）</meta-data></uses-permission></p>
<p>4.自定义hook类<br>    public class Main {<br>        static void initialize() { //插件加载时回调 static方法initialize<br>             MS.hookClassLoad(“android.content.res.Resources”, new MS.ClassLoadHook() { //hook 类加载<br>                public void classLoaded(Class&lt;?&gt; resources) { //类被加载时回调<br>                    Method getColor;<br>                    try {<br>                        getColor = resources.getMethod(“getColor”, Integer.TYPE);<br>                    } catch (NoSuchMethodException e) {<br>                        getColor = null;<br>                    }</p>
<pre><code>                if (getColor != null) {
                    final MS.MethodPointer old = new MS.MethodPointer(); //原方法指针。可以在任何时候运行原方法（被hook方法）

                    MS.hookMethod(resources, getColor, new MS.MethodHook() {
                        public Object invoked(Object resources, Object... args)
                            throws Throwable
                        {
                            int color = (Integer) old.invoke(resources, args);
                            return color &amp; ~0x0000ff00 | 0x00ff0000; //改变系统颜色
                        }
                    }, old);
                }
            }
        });
    }
}

也可以用以下代码实现hook
MS.hookMethod(resources, getColor, new MS.MethodAlteration&lt;Resources, Integer&gt;() {
    public Integer invoked(Resources resources, Object... args)
        throws Throwable
    {
        return invoke(resources, args) &amp; ~0x0000ff00 | 0x00ff0000;
    }
});
</code></pre><p>5.安装apk，重启手机，生效。</p>
<p>关键api<br>    void hookClassLoad(String className, MS.ClassLoadHook hook); Hook一个指定的Class<br>    void hookMethod(Class _class, Member member, MS.MethodHook methodhHook, MS.MethodPointer old);<br>    void hookMethod(Class _class, Member member, MS.MethodAlteration alteration);好用，稳定<br>        _class,需要hook的方法所属类<br>        member,需要hook的方法(或构造函数). 注意：不能HOOK字段 (在编译的时候会进行检测).<br>        methodhHook,MethodHook实例，其包含的invoked方法会被调用，用以代替被hook方法中的代码<br>        old,原方法指针，指向原方法（随时用该指针调用方法）<br>        alteration，MethodAlteration实例，其包含的invoked方法会被调用，用以代替被hook方法中的代码<br>            比MethodHook更好用稳定，在该方法直接调用invoke方法就是调用原方法<br>                不用自己定义 MS.MethodPointer old 指向原方法（随时用该指针调用方法）<br>    <t> T moveUnderClassLoader(ClassLoader loader, T object);   使用ClassLoder重载对象(少用)</t></p>
<p>6.补充<br>“卧槽”洗脑病毒分析 <a href="http://www.2cto.com/Article/201505/400301.html" target="_blank" rel="noopener">http://www.2cto.com/Article/201505/400301.html</a><br>    表现：所有字变为 卧槽。<br>    分析：跟上例改变字体颜色原理相同，只是hook的设置字体的方法<br>        TextView.setText(CharSequence)<br>    复现：<br>        public class Main {<br>            public static void initialize() {<br>                MS.hookClassLoad(“android.widget.TextView”, new MS.ClassLoadHook() {<br>                    @Override<br>                    public void classLoaded(Class arg0) {<br>                        Method smstest ;<br>                        try {<br>                           smstest=arg0.getMethod(“setText”, CharSequence.class);<br>                        } catch (SecurityException e) {<br>                            smstest=null;<br>                            e.printStackTrace();<br>                        } catch (NoSuchMethodException e) {<br>                            smstest=null;<br>                            e.printStackTrace();<br>                        }  </p>
<pre><code>               if(smstest!=null){        
                    final MS.MethodPointer old = new MS.MethodPointer();  
                    MS.hookMethod(arg0, smstest, new MS.MethodHook() {  
                       @Override 
                        public Object invoked(Object arg0, Object... arg1)throws Throwable {                                        
                            return old.invoke(arg0, &quot;爱破解，爱鬼哥&quot;);                                                                 
                        }                             
                    }, old);                          
                }                     
            }                
        });               
    }                                 
}  
</code></pre><p>周圣韬 Android上玩玩Hook：Cydia Substrate实战 <a href="http://www.csdn.net/article/2015-08-07/2825405" target="_blank" rel="noopener">http://www.csdn.net/article/2015-08-07/2825405</a><br>    开始实战（广告注入）<br>    针对Android操作系统的浏览器应用，Hook其首页Activity的onCreate方法（其他方法不一定存在，但是onCreate方法一定会有），<br>        (1)声明一个透明的广告的Activity<br>            为什么设置透明背景的Activity?<br>                就是为了使得弹出来的广告与浏览器融为一体，让用户感觉是浏览器弹出的广告，<br>                也是恶意广告程序为了防止自身被卸载掉的一些通用隐藏手段。<br>                这里演示的注入广告是通过Hook指定的Activity中的onCreate方法来启动一个广告Activity。<br>                如果启动的Activity带有恶意性，如将Activity做得与原Activity一模一样的钓鱼Activity，<br>                那么对于移动设备用户来说是极具欺骗性的。<br>            <!-- 透明无动画的广告Activity --><br>            <activity android:name="com.example.hookad.MainActivity" android:theme="@android:style/Theme.Translucent.NoTitleBar"><br>                <intent-filter><br>                    <action android:name="android.intent.action.VIEW"><br>                    <category android:name="android.intent.category.DEFAULT"><br>                    <!-- 广告的action,方便无context时启动  --><br>                    <action android:name="com.example.hook.AD"><br>                </action></category></action></intent-filter><br>            </activity><br>        (2)找到浏览器主页的Activity名称<br>            使用adb shell下使用dumpsys activity命令找到浏览器主页的Activity名称为<br>                com.android.browser.BrowserActivity<br>        (3)关键hook代码<br>            // 执行Hook前的onCreate方法，保证浏览器正常启动<br>            Object result =  old.invoke(object, args);<br>            // 没有Context。所以执行一个shell 启动我们的广告Activity<br>            CMD.run(“am start -a com.example.hook.AD”);</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/逆向/Android/Hook/android-hook框架/DDI--Dalvik InLine/ddi-原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/逆向/Android/Hook/android-hook框架/DDI--Dalvik InLine/ddi-原理/" itemprop="url">ddi 原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T16:44:42+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.csdn.net/roland_sun/article/details/38640297" target="_blank" rel="noopener">Android平台下Dalvik层hook框架ddi的研究</a> </p>
<p><a href="https://github.com/crmulliner/ddi" target="_blank" rel="noopener">ddi源码</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/逆向/Android/Hook/android-hook框架/xposed--Dalvik FrameWork/Xposed热更新hook目标方法后的行为代码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/逆向/Android/Hook/android-hook框架/xposed--Dalvik FrameWork/Xposed热更新hook目标方法后的行为代码/" itemprop="url">Xposed热更新hook目标方法后的行为代码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T16:44:42+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://github.com/githubwing/HotXposed" target="_blank" rel="noopener">Xposed热更新 hook目标方法后的行为代码</a></p>
<p>无法更新hook的目标，但可以更新hook目标后的行为。</p>
<p>比如 hook Activity的onCreate方法，toast Activity名称改为 logcat 打印Activity名称</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>参考android里classloader实现，发现findClass()最后都是调用了DexFile来loadClass。把需要写的逻辑代码单独放到一个dex里，然后使用DexFile加载</p>
<p>读取/sdcard/classes.dex文件，直接导入Hotfix类，调用他的invoke方法</p>
<img src="/2018/05/18/逆向/Android/Hook/android-hook框架/xposed--Dalvik%20FrameWork/Xposed热更新hook目标方法后的行为代码/DexFile-loadClass.jpg">
<img src="/2018/05/18/逆向/Android/Hook/android-hook框架/xposed--Dalvik%20FrameWork/Xposed热更新hook目标方法后的行为代码/DexFile-loadClass-2.jpg">

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/逆向/Android/Hook/android-hook框架/xposed--Dalvik FrameWork/xposed原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/逆向/Android/Hook/android-hook框架/xposed--Dalvik FrameWork/xposed原理/" itemprop="url">xposed原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T16:44:42+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.xuebuyuan.com/2141468.html" target="_blank" rel="noopener">Android Hook框架Xposed原理与源代码分析</a> </p>
<h1 id="xposed"><a href="#xposed" class="headerlink" title="xposed"></a>xposed</h1><p>Cydia Substrate可以修改任何主进程的代码，不管是用Java还是C/C++（native代码）编写的。</p>
<p>而Xposed（开源）只支持 HOOK app_process中的java函数</p>
<p>Xposed框架是一款可以在不修改APK的情况下影响程序运行（修改系统）的框架服务，<br>通过替换/system/bin/app_process程序控制zygote进程，使得app_process在启动过程中会加载XposedBridge.jar这个jar包，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持。</p>
<p>基于Xposed框架可以制作出许多功能强大的模块，且在功能不冲突的情况下同时运作。<br>此外，Xposed框架中的每一个库还可以单独下载使用，</p>
<pre><code>如Per APP Setting（为每个应用设置单独的dpi或修改权限）、
    Cydia、XPrivacy（防止隐私泄露）、
    BootManager（开启自启动程序管理应用）对原生Launcher替换图标等应用或功能均基于此框架。
</code></pre><p>Xposed框架是基于一个Android的本地服务应用XposedInstaller，与一个提供API 的jar文件来完成的。</p>
<h1 id="xposed安装"><a href="#xposed安装" class="headerlink" title="xposed安装"></a>xposed安装</h1><p>安装使用Xposed框架我们需要完成以下几个步骤：</p>
<h2 id="安装本地服务XposedInstalle-需要root权限"><a href="#安装本地服务XposedInstalle-需要root权限" class="headerlink" title="安装本地服务XposedInstalle(需要root权限)"></a>安装本地服务XposedInstalle(需要root权限)</h2><h3 id="下载-安装。"><a href="#下载-安装。" class="headerlink" title="下载 安装。"></a><a href="http://repo.xposed.info/module/de.robv.android.xposed.installer" target="_blank" rel="noopener">下载</a> 安装。</h3><h3 id="激活框架。"><a href="#激活框架。" class="headerlink" title="激活框架。"></a>激活框架。</h3><p>点击“安装/更新”就能完成框架的激活了。</p>
<p>部分设备如果不支持直接写入的话，选择“安装方式”为在Recovery模式下自动安装即可</p>
<p>由于国内的部分ROM对Xposed不兼容，Recovery模式可能会造成设备反复重启而无法正常启动</p>
<p>安装后会启动Xposed的app_process，所以安装过程中会存在设备多次重新启动</p>
<h1 id="xposed项目编码"><a href="#xposed项目编码" class="headerlink" title="xposed项目编码"></a>xposed项目编码</h1><h2 id="jar包依赖"><a href="#jar包依赖" class="headerlink" title="jar包依赖"></a>jar包依赖</h2><ul>
<li><p>下载API库 XposedBridgeApi-.jar。</p>
</li>
<li><p>复制到lib目录（注意是lib目录，不是Android提供的libs目录）</p>
</li>
</ul>
<p>如果直接将jar包放置到了libs目录下，很可能会产生<a href="http://forum.xda-developers.com/xposed/xposed-api-changelog-developer-news-t2714067" target="_blank" rel="noopener">错误</a>： </p>
<pre><code>“IllegalAccessError: Class ref in pre-verified class resolved to unexpected  implementation” 
</code></pre><p>估计Xposed作者在其框架内部也引用了BridgeApi，这样操作避免重复引用。</p>
<h2 id="Manifest设置"><a href="#Manifest设置" class="headerlink" title="Manifest设置"></a>Manifest设置</h2><p>在AndroidManifest.xml文件中meta-data配置 插件名称与Api版本号</p>
<pre><code>application  下
&lt;meta-data  
    android:name=&quot;xposedmodule&quot;  
    android:value=&quot;true&quot; /&gt;  

&lt;!-- 模块描述 载入model之后显示的描述信息--&gt;
&lt;meta-data  
    android:name=&quot;xposeddescription&quot;  
    android:value=&quot;一个登陆劫持的样例&quot; /&gt;  

&lt;!-- 最低版本号 --&gt;
&lt;meta-data  
    android:name=&quot;xposedminversion&quot;  
    android:value=&quot;30&quot; /&gt;  
</code></pre><h2 id="自定义hook类"><a href="#自定义hook类" class="headerlink" title="自定义hook类"></a>自定义hook类</h2><pre><code>package com.example.loginhook
public class Main implements IXposedHookLoadPackage { //加载包的时候回调  
    public void handleLoadPackage(final LoadPackageParam lpparam) throws Throwable {  

        // 包名不是 com.example.login 的应用 不hook
        if (!lpparam.packageName.equals(&quot;com.example.login&quot;)) return;  

         // Hook MainActivity中的isCorrectInfo(String,String)方法  
        XposedHelpers.findAndHookMethod(&quot;com.example.login.MainActivity&quot;, lpparam.classLoader, &quot;isCorrectInfo&quot;, String.class,  
        String.class, new XC_MethodHook() {  

            @Override  
            protected void beforeHookedMethod(MethodHookParam param) throws Throwable {  
                XposedBridge.log(&quot;开始劫持了~&quot;);  
                XposedBridge.log(&quot;参数1 = &quot; + param.args[0]);  
                XposedBridge.log(&quot;参数2 = &quot; + param.args[1]);  
            }  

            @Override  
            protected void afterHookedMethod(MethodHookParam param) throws Throwable {  
                XposedBridge.log(&quot;劫持结束了~&quot;);  
                XposedBridge.log(&quot;参数1 = &quot; + param.args[0]);  
                XposedBridge.log(&quot;参数2 = &quot; + param.args[1]);  

            }  
        });    
    }  
}
</code></pre><h2 id="assets-xposed-init-声明主入口类"><a href="#assets-xposed-init-声明主入口类" class="headerlink" title="assets/xposed_init 声明主入口类."></a>assets/xposed_init 声明主入口类.</h2><p>这里我们的主入口类为 com.example.loginhook.Main</p>
<h2 id="编译，安装xposed模块"><a href="#编译，安装xposed模块" class="headerlink" title="编译，安装xposed模块"></a>编译，安装xposed模块</h2><p>XpasedInstaller–模块选项中勾选待启用的模块让其正常的生效</p>
<p>重启Android设备，进入XposedInstaller查看日志模块</p>
<h1 id="关键api"><a href="#关键api" class="headerlink" title="关键api"></a>关键api</h1><p>hook主类入口接口</p>
<pre><code>void handleLoadPackage(final LoadPackageParam lpparam) hook包加载 IXposedHookLoadPackage
void initCmdApp(StartupParam startupParam) hook java程序初始化 IXposedHookCmdInit
void handleInitPackageResources(InitPackageResourcesParam resparam) hook包资源初始化 IXposedHookInitPackageResources
void initZygote(StartupParam startupParam) hook Zygote初始化 IXposedHookZygoteInit
</code></pre><p>XposedHelpers hook方法等操作api</p>
<pre><code>Unhook findAndHookMethod(String className, ClassLoader classLoader, String methodName, Object... parameterTypesAndCallback)
</code></pre><h1 id="xposed模块模块检测"><a href="#xposed模块模块检测" class="headerlink" title="xposed模块模块检测"></a>xposed模块模块检测</h1><h2 id="proc-smaps-文件分析"><a href="#proc-smaps-文件分析" class="headerlink" title="/proc//smaps 文件分析"></a>/proc/<pid>/smaps 文件分析</pid></h2><p>进程 加载 dex，so文件 占用的内存</p>
<pre><code>app dex maps
Pss        Rss        Size        name    other
2269 kB        11284 kB        11536 kB        /data/dalvik-cache/arm/system@framework@boot.art    
42 kB        72 kB        88 kB        /data/app/com.zy.course.dev-1/oat/arm/base.odex    
0 kB        28 kB        15556 kB        /data/app/cn.cyt.cracker007-1/oat/arm/base.odex
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/逆向/Android/Hook/android-hook框架/xposed--Dalvik FrameWork/小米系统miui使用xposed框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/逆向/Android/Hook/android-hook框架/xposed--Dalvik FrameWork/小米系统miui使用xposed框架/" itemprop="url">小米系统miui使用xposed框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T16:44:42+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.miui.com/thread-2973594-1-1.html" target="_blank" rel="noopener">解除系统对XPosed框架限制</a>    </p>
<p>从9月23日开始，XPosed框架被系统限制，许多XP模块童鞋捉急。</p>
<p>然而，高手在民间，不过几日，先是论坛许多miui优化包都放出XP框架可用，说明已破解，但从他们的包内确实找不出关键点。</p>
<p>又一日，网友『尛』便爆出解决方法，赶脚试试，果然奏效，在这里再次感谢『尛』。</p>
<p>发这帖是对 『尛』帖子的诠释，以下操作步骤仅为我的见解，不排除有比我更好的方法，希望能帮助到大家，祝基友国庆刷机愉快！</p>
<p>先说主要的：</p>
<ol>
<li><p>请到官方17日的包内提取两个文件：app_process 和 libandroid_runtime.so</p>
<pre><code>其位置分别在：system/Bin下 和 system/Lib/下（为什么要17日的包？因为17日的包好找，不是内测的基友也可以下载到哦）
</code></pre></li>
<li><p>下载你想刷的官方的最新包。</p>
</li>
<li><p>把提取的 app_process 和 libandroid_runtime.so 文件替换到新下载包的同目录下（就是提取时的目录），直接覆盖确认。</p>
<pre><code>替换文件在PC上操作，不要解压rom包。双击rom包，拖曳文件到相应位置直接覆盖替换，无需改权限什么的。
</code></pre></li>
<li><p>刷机–成功！（注意：请使用论坛雯雯的rec2.8.5刷入，使用官方REC可能因签名问题失败)</p>
<pre><code>推荐使用第三方rec刷包(雯雯2.8.5，论坛置顶，这个REC刷官方rom和ota都能成功，真乃刷机神器！)。
</code></pre><p>楼主机型 ：2014011    HM1STD    红米1S3G移动版<br>其他机型自测，据我观察论坛大部分机型几乎都可使用。</p>
</li>
</ol>
<p><strong>注意：请不要在手机系统上通过RE管理器直接替换文件，否则100%变砖！</strong></p>
<p>我note 4g联通增强版就是在万恶的百度贴吧看教程用RE替换，然后变砖的。增强版刷机后资料全丢</p>
<pre><code>http://en.miui.com/forum.php?mod=viewthread&amp;tid=176904&amp;highlight=Xposed Fix for Xposed restrictions on MIUI 7. KitKat Only (4.4.x)
</code></pre><p>英国miui论坛提供的一个xposed apk，兼容4.4.x。note 4g联通增强版测试成功</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/电脑使用/mac/联想t420安装黑苹果/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/电脑使用/mac/联想t420安装黑苹果/" itemprop="url">联想t420安装黑苹果</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T13:29:46+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MBR和GPT分区"><a href="#MBR和GPT分区" class="headerlink" title="MBR和GPT分区"></a>MBR和GPT分区</h1><p>Intel 6系列主板之后，就开始提供UEFI BIOS支持，正式支持GPT硬盘分区表，一举取代了此前的MBR分区表格式</p>
<p>新平台用户（Intel 6系以后/AMD 900系列以后和A系列）来说，都强烈推荐使用GPT分区表格式</p>
<p>Windows Vista以上已经都支持读取和使用GPT分区表。而对于Windows 8以上的用户，换用GPT后开机启动速度也可以进一步得到显著提升。</p>
<h2 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h2><p><strong>MBR的全称是Master Boot Record（主引导记录）</strong></p>
<p>是存在于驱动器开始部分的一个特殊的启动扇区。这个扇区包含了已安装的操作系统的启动加载器和驱动器的逻辑分区信息。</p>
<p>主引导扇区是硬盘的第一扇区。它由三个部分组成，主引导记录MBR、硬盘分区表DPT和硬盘有效标志</p>
<p>启动加载器，是一小段代码，用于加载驱动器上其他分区上更大的加载器。Linux系统位于MBR里的通常会是GRUB加载器。</p>
<p>MBR最大支持2.2TB磁盘，只支持最多4个主分区(再多分区只能设为逻辑分区)</p>
<h2 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h2><p><strong>GPT的全称是Globally Unique Identifier Partition Table（GUID分区表）</strong></p>
<p>GPT首要的任务就是突破2.2T分区的限制，最大支持18EB的分区。</p>
<p>它的推出是和UEFI BIOS相辅相成的</p>
<h3 id="ESP"><a href="#ESP" class="headerlink" title="ESP"></a>ESP</h3><p><strong>ESP的全称是EFI system partition（EFI系统分区）</strong></p>
<p>GPT格式的硬盘必须有一个esp分区，esp分区装的是系统引导(windows就是boot64.efi这个文件),开机启动就是从这个分区开始的</p>
<h3 id="MSR分区"><a href="#MSR分区" class="headerlink" title="MSR分区"></a>MSR分区</h3><p><strong>MSR的全称是Microsoft Reserved Partition（Microsoft 保留分区）</strong></p>
<p>GPT上的 Windows操作系统（windows7以上）都要求有的分区。系统组件可以将 MSR 分区的部分分配到新的分区以供它们使用。</p>
<h1 id="UEFI-BIOS"><a href="#UEFI-BIOS" class="headerlink" title="UEFI BIOS"></a>UEFI BIOS</h1><p><strong>UEFI的全称是Unified Extensible Firmware Interface（统一可扩展固件接口）</strong></p>
<p>Windows Vista、7系统需要手动添加UEFI支持，可以找一份Windows 8或者10安装镜像，从安装文件中提取Bootmgfw.efi文件，重命名为BOOTX64.EFI，拷贝到win7安装文件的\EFI\Boot\下，如果没有BOOT文件夹就新建一个。</p>
<h1 id="HFS"><a href="#HFS" class="headerlink" title="HFS"></a>HFS</h1><p><strong>HFS的全称Hierarchical File System（分层文件系统）</strong></p>
<p>一种由苹果电脑开发，并使用在Mac OS上的文件系统。</p>
<h1 id="黑苹果神器ThinkPad-t420"><a href="#黑苹果神器ThinkPad-t420" class="headerlink" title="黑苹果神器ThinkPad t420"></a>黑苹果神器ThinkPad t420</h1><p>折腾黑苹果系统一弄就要好几天，太伤神了。</p>
<p>黑苹果神器ThinkPad t420 基本2个小时就可以搞定</p>
<p>原机自带的无线网卡不能使用，要更换一张。或者可以通过USB把wifi共享给电脑使用（当然也可以共享手机流量上网，但这儿只说wifi）。horndis已经支持Sierra 10.12，可到官网下载</p>
<p>带有双显卡的话只能驱动集成显卡或独立显卡的一个，不能实现自动切换（建议买集显版本）</p>
<p>Yosemite和Windows的时钟问题，把OSX的时区改成北京，启动到Windows在注册表里添加RealTimeIsUniversal键值为1，这样两个系统的时钟就都正常了。原因似乎是MacOSX会把CMOS时钟看做国际标准时间，而Windows默认会看作本地时间。</p>
<p>ThinkPad T系列经过好几代的发展，设计已经很成熟。</p>
<ul>
<li>常用的版本带2代的i5 CPU</li>
<li>支持最多16G的DDR3内存</li>
<li>支持mSATA接口固态硬盘</li>
<li>如果光驱位换成硬盘，最多支持安装3个硬盘。</li>
<li>可以支持3G移动上网卡。</li>
<li>接口丰富<ul>
<li>带有DisplayPort接口。我感觉DP比HDMI接口好太多了，可以方便支持2k高清显示器，hdmi的话情况会复杂很多。</li>
<li>4个usb 2.0，1394火线接口。</li>
<li>最大的缺点是没有USB3.0接口</li>
<li>好在有一个eSATA接口，速度也很快。</li>
<li>另有一个34mm的ExpressCard接口，可以接上usb 3.0的转接器。</li>
<li>内置读卡器、摄像头和指纹识别。</li>
<li>另有扩展底座接口，可以连接专用的扩展底座。</li>
</ul>
</li>
</ul>
<p>最大的优势之一还在于它的通用性。因为目前使用中的T420数量非常大，所以遇到什么问题，网上很多交流文章。</p>
<p>现在二手的T420非常便宜，价格在1500左右。购买时注意，市场上好些高配的四核i7机器据说都是换cpu的，因为听说原装没有四核机器。</p>
<h1 id="安装黑苹果"><a href="#安装黑苹果" class="headerlink" title="安装黑苹果"></a>安装黑苹果</h1><p>参考帖子：<a href="https://bbs.feng.com/forum.php?mod=viewthread&amp;tid=8854857&amp;extra=page%3D1&amp;mobile=no" target="_blank" rel="noopener">T420 UEFI+单硬盘GPT+Yosemite/El Capitan原版+clover基本完美</a></p>
<p>UEFI only启动，一块硬盘GPT分区，C盘装win7 oem版本系统，D盘分出来60G装了win10，最后装的Yosemite（之前下载的10.10.1安装包懒得再重新下了，装好之后直接升级为10.10.2）</p>
<p><a href="https://my.oschina.net/y010204025/blog/1499459" target="_blank" rel="noopener">link</a></p>
<p><a href="http://bbs.pcbeta.com/viewthread-1542110-1-1.html" target="_blank" rel="noopener">【授人以渔】UEFI+GPT+Clover OS X Yosemite原版单、双系统双版教程(正式版)</a></p>
<p><a href="http://bbs.pcbeta.com/viewthread-1599202-1-1.html" target="_blank" rel="noopener">【超级教程】黑苹果各个版本各种引导安装通用教材</a></p>
<h2 id="BIOS设置"><a href="#BIOS设置" class="headerlink" title="BIOS设置"></a>BIOS设置</h2><p>将硬盘模式设为AHCI、EFI only引导、有独显的关闭一下。</p>
<ul>
<li>Recommend update to BIOS v1.46</li>
<li>Recommend reset to defaults. Most defaults settings will work but check settings these:<ul>
<li>Set Config / Serial ATA (SATA) / SATA = AHCI</li>
<li>Set Security / Memory Protection / Execution Prevention = Enabled</li>
</ul>
</li>
<li>Disable Discrete Nvidia/Optimus (use integrated HD 3000 only - unless you really know what you are doing!)</li>
</ul>
<h2 id="制作USB安装盘"><a href="#制作USB安装盘" class="headerlink" title="制作USB安装盘"></a>制作USB安装盘</h2><p>1、下载Mac OS 建议下载原版10.10X或者<a href="https://support.apple.com/kb/DL1845?locale=zh_CN" target="_blank" rel="noopener">10.11.x</a></p>
<p>2、使用TransMac 11(试用版即可)将系统写入Ｕ盘</p>
<pre><code>USB盘符 右键 Restore with Disk Image 选择下载好的dmg文件
耐心等待写盘的完成
写入完成，系统弹出将其格式化，点击取消
cmd -- diskpart -- list disk 可以看到U盘已成GPT(GPT栏有星号)
</code></pre><p>3、替换<a href="https://github.com/tluck/Lenovo-T420-Clover/" target="_blank" rel="noopener">EFI</a>。将EFI文件夹复制到U盘根目录，选择适合屏幕分辨率的config.plist文件，重命名为config.plist.</p>
<p>(4)使用引导安装系统，(安装盘的ESP分区剩余容量必须大于200M，否则格式化磁盘的时候会提示空间不足，格式化失败)</p>
<p>(5)安装完成后继续把EFI文件复制到本地硬盘的ESP，这时你的系统已经可以正常引导和运行</p>
<h1 id="多系统引导解决方案"><a href="#多系统引导解决方案" class="headerlink" title="多系统引导解决方案"></a>多系统引导解决方案</h1><p>安装了4个os，分别是win10、Mac os、Ubuntu、凤凰os（android-x86）</p>
<p>电脑是UEFI引导的，所以我选用的引导为：Clover，可以实现多系统的引导，传统方式要简单一些，直接使用easybcd编辑即可。</p>
<p>Clover相当于是一个简单的系统了，从这个系统里面又引导其他系统，很高级，如果你足够厉害，可以自己去研究。</p>
<p>好，进入正题，我的装系统的步骤依次是：win10-&gt;Mac os–&gt;Ubuntu-&gt;Android</p>
<p>1、efi安装win10，引导会自动配置在esp分区。</p>
<p>2、安装Mac os黑苹果，引导不会自动配置引导。需要手动操作：</p>
<p>（1）将win10引导备份，esp分区内的/EFIMicrosoft文件夹，然后删除</p>
<p>（2）将Clover引导放进esp，开机引导进入clover，选择mac进去，挂载esp分区，将win10文件夹放入/EFI文件夹</p>
<p>（3）重启进入clover，你会发现win10和mac引导已经解决。</p>
<p>3、安装Ubuntu，注意使用EFI引导进入安装，会自动在Efi文件夹新建Ubuntu文件夹，重启会自动进grub引导（也就是Ubuntu引导）在bios里面调节即可，将UEFI OS设置为第一项。此时可以引导3个系统。</p>
<p>4、安装凤凰os，默认安装即可，他也会在EFI新建文件夹，但是开机引导到Clover看不到它，于是考虑使用Ubuntu的gurb引导将其添加进来。</p>
<p>在安卓引导文件夹，找到配置文件，grub.cfg，将图片中的代码复制</p>
<img src="/2018/05/18/电脑使用/mac/联想t420安装黑苹果/img.png">
<p>凤凰os配置文件<br>进入ububun图系统，找到menuentry的位置，将上面的代码也粘贴过去，然后保存即可，重启进入Clover接着选择ubuntu引导，会看到多了凤凰os和windows的引导</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/科学上网/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/科学上网/" itemprop="url">科学上网</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T10:25:42+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h1><ul>
<li>系统全局代理。系统中的软件，（无需配置）自动走 VPN 通道</li>
<li>不方便共享 VPN 的翻墙通道给【其它系统】</li>
<li>一般通过设置系统VPN或使用客户端软件(比如ShadowSocket)</li>
</ul>
<h2 id="Privoxy"><a href="#Privoxy" class="headerlink" title="Privoxy"></a>Privoxy</h2><p>跨系统共享 VPN 的翻墙通道</p>
<p>Privoxy 跟 VPN 安装到同一个操作系统中。</p>
<p>配置 Privoxy 的监听选项，把监听地址设置为 0.0.0.0（表示监听端口绑定到任意地址）</p>
<p>支持转发HTTP 和 SOCKS 两种</p>
<p>公司的共享服务器就是用这个辅助的</p>
<p><a href="https://program-think.blogspot.com/2014/12/gfw-privoxy.html" target="_blank" rel="noopener">详细教程参考</a></p>
<h1 id="代理式"><a href="#代理式" class="headerlink" title="代理式"></a>代理式</h1><ul>
<li>容易跨系统共享翻墙通道</li>
<li>一般都是通过设置浏览器代理或使用浏览器插件</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/28/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><span class="page-number current">29</span><a class="page-number" href="/page/30/">30</a><a class="page-number" href="/page/31/">31</a><a class="extend next" rel="next" href="/page/30/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="风" />
            
              <p class="site-author-name" itemprop="name">风</p>
              <p class="site-description motion-element" itemprop="description">随心而动，随刃而行</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">308</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">71</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">风</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
