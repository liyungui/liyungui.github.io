<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="随心而动，随刃而行">
<meta property="og:type" content="website">
<meta property="og:title" content="风">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="风">
<meta property="og:description" content="随心而动，随刃而行">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="风">
<meta name="twitter:description" content="随心而动，随刃而行">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>风</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">风</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">技术博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/27/java基础/enum 使用的副本/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/27/java基础/enum 使用的副本/" itemprop="url">enum使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-27T15:46:53+08:00">
                2019-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="emun也是class"><a href="#emun也是class" class="headerlink" title="emun也是class"></a>emun也是class</h2><p>经过反编译知道，enum也是被编译成了一个class文件。</p>
<pre><code>public final class RoomType extends java.lang.Enum{ }
</code></pre><p>如果命名意义明确，enum可以单独作为一个类。</p>
<h2 id="枚举项的值默认为从0开始递增的int值"><a href="#枚举项的值默认为从0开始递增的int值" class="headerlink" title="枚举项的值默认为从0开始递增的int值"></a>枚举项的值默认为从0开始递增的int值</h2><pre><code>enum MyEnum{
    FIRST_ELEMENT,
    SECOND_ELEMENT,
}
ordinal()返回值的序列号，从0开始
</code></pre><h2 id="自定义枚举项的值"><a href="#自定义枚举项的值" class="headerlink" title="自定义枚举项的值"></a>自定义枚举项的值</h2><pre><code>enum FruitEnum {
    APPLE(1), ORANGE(2); //调用构造函数来构造枚举项

    private int value = 0;

    private FruitEnum(int value) { //必须是private的构造方法，否则编译错误
        this.value = value;
    }

    public static FruitEnum valueOf(int value) { //值(这里是int，可以使string等)到enum的转换函数
        switch (value) {
        case 1:
            return APPLE;
        case 2:
            return ORANGE;
        default:
            return null;
        }
    }

    public int value() { //enum到值的转换函数
        return this.value;
    }
}

如果是int到enum自然排序转换，还可以调用values()(系统api，返回enum数组)
public enum RoomType {
    Single(&quot;single&quot;), Group(&quot;group&quot;);

    String value;

    RoomType(String value) {
        this.value = value;
    }

    public String getValue() {
        return value;
    }

    public static RoomType fromInt(int i) {//参数只能是索引
        return values()[i];
    }
}
RoomType.fromInt(0) 返回的是第一个enum项Single
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/27/java基础/注解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/27/java基础/注解/" itemprop="url">注解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-27T15:45:53+08:00">
                2019-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>注释是给人看的提示信息</li>
<li>注解是给程序看的提示信息</li>
</ul>
<p>注解就像程序中的一个小标记,我们可以根据有没有这个标记,有这个标记属性的值是什么,来控制我们程序进行不同的处理</p>
<h2 id="注解3种基本类型"><a href="#注解3种基本类型" class="headerlink" title="注解3种基本类型"></a>注解3种基本类型</h2><pre><code>a.标记注释    --没有变量，只有名称标识。例如 @annotation
b.单一值注释  --在标记注释的基础上提供一段数据。如 @annotation(&quot;data&quot;)
                只需设置一个属性值（只有一个属性，或者其他属性都有默认值），使用时可省略属性名
c.完整注释    --可以包括多个数据成员，每个数据成员由名称和值构成。 @annotation(val1=&quot;data1&quot;,val2=&quot;data2&quot;)
</code></pre><p>java定义的一些注解:</p>
<pre><code>@Override: 限定重写父类方法, 该注解只能用于方法
@Deprecated: 用于表示某个程序元素(类, 方法等)已过时
@SuppressWarnings: 抑制编译器警告. 
</code></pre><h2 id="自定义注解-interface"><a href="#自定义注解-interface" class="headerlink" title="自定义注解 @interface"></a>自定义注解 @interface</h2><p><strong>定义属性</strong></p>
<ul>
<li>在自定义注解中声明属性,像接口中定义方法</li>
<li>可以通过default关键字来声明默认值</li>
<li>属性的类型必须是:<ul>
<li>String</li>
<li>八种基本类型</li>
<li>枚举类型</li>
<li>其他注解类型</li>
<li>Class类型</li>
<li>这些类型的一维数组</li>
</ul>
</li>
</ul>
<p><strong>赋值属性</strong></p>
<p>如果注解中只有一个属性且属性名value需要被赋值,赋值时 value= 可以被省略,直接给值即可</p>
<p><strong>元注解修饰</strong></p>
<pre><code>@Retention: 用于指定该 Annotation 可以保留的域, 
    RetentionPolicy.SOURCE: 编译器直接丢弃这种策略的注释
        @Override、@SuppressWarnings等，这类注解就是用于标识，可以用作一些检验
    RetentionPolicy.CLASS: 编译器将把注解记录在 class 文件中. 当运行 Java 程序时, JVM 不会保留注解. 这是默认值
        在编译时根据注解标识，动态生成一些类或者生成一些xml。因为没有反射，效率和直接调用方法没什么区别
        使用这类注解的项目有：ParcelableGenerator、butterknife 、androidAnnotaion等。
    RetentionPolicy.RUNTIME:编译器将把注释记录在 class 文件中. 当运行 Java 程序时, JVM 会保留注解. 程序可以通过反射获取该注释
        见得最多，在运行时拿到类的Class对象，然后遍历其方法、变量，判断有无注解声明，然后做一些事情
@Target：指定注解用于什么地方. ElementType[]
    public enum ElementType { 
        TYPE, //Class, interface or enum declaration. 
        FIELD, //Field declaration. 
        METHOD, //Method declaration. 
        PARAMETER, //Parameter declaration. 
        CONSTRUCTOR, //Constructor declaration. 
        LOCAL_VARIABLE, //Local variable declaration. 
        ANNOTATION_TYPE, //Annotation type declaration. PACKAGE //Package declaration.
    }
@Documented: 被该元修饰的 Annotation 类将被 javadoc 工具提取成文档.
@Inherited: 被它修饰的 Annotation 将具有继承性.如果某个类使用了被 @Inherited 修饰的 Annotation, 则其子类将自动具有该注解
</code></pre><p><strong>实例</strong> 遍历类中声明的所有属性，找到存在ViewInject注解的属性并获取其value，然后去调用findViewById方法，最后把值设置给field</p>
<pre><code>@Target(ElementType.FIELD)  
@Retention(RetentionPolicy.RUNTIME)  
public @interface ViewInject  
{  
    int value();  
    int parentId() default 0;  
}

private static void injectViews(Activity activity) {  
    Class&lt;? extends Activity&gt; clazz = activity.getClass();  
    Field[] fields = clazz.getDeclaredFields();  
    // 遍历所有成员变量  
    for (Field field : fields)  
    {   
        ViewInject viewInjectAnnotation = field.getAnnotation(ViewInject.class);  
        if (viewInjectAnnotation != null){  
            int viewId = viewInjectAnnotation.value();  
            if (viewId != -1){  
                Log.e(&quot;TAG&quot;, viewId+&quot;&quot;);  
                // 初始化View  
                try {  
                    Method method = clazz.getMethod(&quot;findViewById&quot;, int.class);  
                    Object resView = method.invoke(activity, viewId);  
                    field.setAccessible(true);  
                    field.set(activity, resView);  
                } catch (Exception e) {  
                    e.printStackTrace();  
                }  
            }  
        }  
    }            
} 
</code></pre><p>(3)反射注解<br>    sun定义了 AnnotatedElement 接口,在这个几口中定义了反射注解的api,而Class Field Method Constructor Package … 都实现了这个接口,具有这些api<br>        getAnnotation(Class<t> annotationClass)<br>        isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) </t></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/27/java基础/线程锁/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/27/java基础/线程锁/" itemprop="url">线程锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-27T15:44:53+08:00">
                2019-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.cnblogs.com/qifengshi/p/6831055.html" target="_blank" rel="noopener">Java中锁分类</a></p>
<h1 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁/悲观锁"></a>乐观锁/悲观锁</h1><p>区别在于看待并发同步的角度/态度。</p>
<p><strong>悲观锁</strong>认为对于同一个数据的并发操作，一定是会发生修改的，不加锁的并发操作一定会出问题。</p>
<ul>
<li>适合写操作非常多的场景</li>
<li>悲观锁在Java中的使用，就是利用各种锁。</li>
</ul>
<p><strong>乐观锁</strong>则认为对于同一个数据的并发操作，是不会发生修改的，不加锁的并发操作是没有问题的。</p>
<ul>
<li>适合读操作非常多的场景</li>
<li>乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。</li>
</ul>
<h1 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁/非公平锁"></a>公平锁/非公平锁</h1><p><strong>公平锁</strong>是指多个线程按照申请锁的顺序来获取锁。</p>
<p><strong>非公平锁</strong>是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。</p>
<p><code>ReentrantLock(Re entrant Lock)</code>，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。通过AQS(AbstractQueuedSynchronizer)实现线程调度</p>
<p><code>Synchronized</code>，非公平锁。</p>
<h1 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h1><p>又名递归锁，是指同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。</p>
<p>可重入锁的一个好处是可一定程度避免死锁。</p>
<p><code>ReentrantLock</code> <code>Synchronized</code>,都是可重入锁。</p>
<pre><code>synchronized void setA() throws Exception{
    Thread.sleep(1000);
    setB();
}

synchronized void setB() throws Exception{
    Thread.sleep(1000);
}

如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁。
</code></pre><h1 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁/共享锁"></a>独享锁/共享锁</h1><p><strong>独享锁</strong>是指该锁一次只能被一个线程所持有。</p>
<p><strong>共享锁</strong>是指该锁可被多个线程所持有。</p>
<p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p>
<p><code>ReentrantLock</code>，独享锁。</p>
<p><code>Synchronized</code>，独享锁。</p>
<p><code>ReadWriteLock</code>，读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。</p>
<h1 id="互斥锁-同步锁-读写锁"><a href="#互斥锁-同步锁-读写锁" class="headerlink" title="互斥锁/同步锁/读写锁"></a>互斥锁/同步锁/读写锁</h1><p>上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。</p>
<p><strong>互斥锁</strong>：两个线程不能同时运行，一个线程运行完毕，另一个才能运行</p>
<ul>
<li>具有唯一性和排它性</li>
<li>无序</li>
</ul>
<p><strong>同步锁</strong>：也是不能同时运行，但是必须安照某种次序来运行</p>
<ul>
<li>一种特殊互斥</li>
<li>互斥的基础上</li>
<li>有序访问</li>
</ul>
<p><strong>读写锁</strong>:</p>
<p>1）多个读者可以同时进行读<br>2）写者必须互斥（只允许一个写者写，也不能读者写者同时进行）<br>3）写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）  </p>
<h1 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h1><p>其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。<br>我们以ConcurrentHashMap来说一下分段锁的含义以及设计思想，ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。<br>当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。<br>但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。<br>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</p>
<h1 id="偏向锁-轻量级锁-重量级锁"><a href="#偏向锁-轻量级锁-重量级锁" class="headerlink" title="偏向锁/轻量级锁/重量级锁"></a>偏向锁/轻量级锁/重量级锁</h1><p>这三种锁是指锁的状态，并且是针对Synchronized。</p>
<p>Java 5通过引入锁升级的机制来实现高效Synchronized。</p>
<p>这三种锁的状态是通过 <code>对象监视器在对象头中的字段</code> 来表明的。</p>
<p><strong>偏向锁</strong>是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</p>
<p><strong>轻量级锁</strong>是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p>
<p><strong>重量级锁</strong>是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p>
<h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><p>自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环(jvm默认是10次)的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p>
<p>自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时 才能进入临界区。如下</p>
<pre><code>public class SpinLock {

  private AtomicReference&lt;Thread&gt; sign =new AtomicReference&lt;&gt;();

  public void lock(){
    Thread current = Thread.currentThread();
    while(!sign .compareAndSet(null, current)){
    }
  }

  public void unlock (){
    Thread current = Thread.currentThread();
    sign .compareAndSet(current, null);
  }
}
</code></pre><p>使用了CAS原子操作，lock函数将owner设置为当前线程，并且预测原来的值为空。unlock函数将owner设置为null，并且预测值为当前线程。</p>
<p>当有第二个线程调用lock操作时由于owner值不为空，导致循环一直被执行，直至第一个线程调用unlock函数将owner设置为null，第二个线程才能进入临界区。</p>
<p>由于自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。如果线程竞争不激烈，并且保持锁的时间短，适合使用自旋锁。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/27/java基础/如何正确停止线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/27/java基础/如何正确停止线程/" itemprop="url">如何正确停止线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-27T15:42:53+08:00">
                2019-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>http://blog.csdn.net/liranke/article/details/8270543
</code></pre><p>关于如何正确停止线程，这篇文章(<a href="http://forward.com.au/javaProgramming/HowToStopAThread.html" target="_blank" rel="noopener">how to stop thread</a>)给出了一个很好的答案, 总结起来就下面3点（在停止线程时）：</p>
<ol>
<li><p>使用violate boolean变量来标识线程是否停止</p>
</li>
<li><p>停止线程时，需要调用停止线程的interrupt()方法，因为线程有可能在wait()或sleep(), 提高停止线程的即时性</p>
</li>
<li><p>对于blocking IO的处理，尽量使用InterruptibleChannel来代替blocking IO</p>
</li>
</ol>
<p>核心如下：</p>
<pre><code>private volatile Thread myThread;

public void stopMyThread() {
    Thread tmpThread = myThread;
    myThread = null;
    if (tmpThread != null) {
        tmpThread.interrupt();
    }
}

public void run() {
    if (myThread == null) {
       return; // stopped before started.
    }
    try {
        // all the run() method&apos;s code goes here
        ...
        // do some work

        Thread.yield(); // let another thread have some time perhaps to stop this one.

        if (Thread.currentThread().isInterrupted()) {
           throw new InterruptedException(&quot;Stopped by ifInterruptedStop()&quot;);
        }

        // do some more work
        ...
    } catch (Throwable t) {
       // log/handle all errors here
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/27/java基础/日期时间类和格式化输出/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/27/java基础/日期时间类和格式化输出/" itemprop="url">日期时间类和格式化输出</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-27T15:42:53+08:00">
                2019-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>JAVA下的日期时间类和格式化输出 http://jiankeafei.iteye.com/blog/230928
</code></pre><p>SimpleDateFormat的格式：</p>
<p>   在实例化SimpleDateFormat时，采用”yyyy-MM-dd HH:mm:ss”这样的构造参数，可以对输出的格式进行设置。而字符串中的字母代表的含义如下：</p>
<pre><code>G 年代标志符
y 年
M 月
d 日
h 时 在上午或下午 (1~12)
H 时 在一天中 (0~23)
m 分
s 秒
S 毫秒
E 星期
D 一年中的第几天
F 一月中第几个星期几
w 一年中第几个星期
W 一月中第几个星期
a 上午 / 下午 标记符 
k 时 在一天中 (1~24)
K 时 在上午或下午 (0~11)
z 时区
</code></pre><p>  除了上述具有实际含义的字母之外，还可以配合诸如：空格、：、-等进行格式化设置。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/27/java基础/匿名内部类只能访问final修饰的外部变量/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/27/java基础/匿名内部类只能访问final修饰的外部变量/" itemprop="url">匿名内部类只能访问final修饰的外部变量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-27T15:41:53+08:00">
                2019-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>匿名内部类用法</p>
<pre><code>public class TryUsingAnonymousClass {
    public void useMyInterface() {
        final Integer number = 123;
        System.out.println(number);

        MyInterface myInterface = new MyInterface() {
            @Override
            public void doSomething() {
                System.out.println(number);
            }
        };
        myInterface.doSomething();

        System.out.println(number);
    }
}
</code></pre><p>编译后的结果</p>
<pre><code>class TryUsingAnonymousClass$1
        implements MyInterface {
    private final TryUsingAnonymousClass this$0;
    private final Integer paramInteger;

    TryUsingAnonymousClass$1(TryUsingAnonymousClass this$0, Integer paramInteger) {
        this.this$0 = this$0;
        this.paramInteger = paramInteger;
    }

    public void doSomething() {
        System.out.println(this.paramInteger);
    }
}
</code></pre><ul>
<li>匿名内部类最终用会编译成一个单独的类</li>
<li>被该类使用的变量会以构造函数参数的形式传递给该类</li>
<li>如果变量 不定义成final的，在匿名内部类被可以被修改，进而造成和外部的不一致的问题，为了避免这种不一致的情况，Java 规定匿名内部类只能访问final修饰的外部变量。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/27/java基础/反射final成员变量/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/27/java基础/反射final成员变量/" itemprop="url">反射final成员变量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-27T15:41:53+08:00">
                2019-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>利用反射对修饰符为final的成员变量进行修改 http://my.oschina.net/dxqr/blog/215504
</code></pre><h2 id="非final成员变量"><a href="#非final成员变量" class="headerlink" title="非final成员变量"></a>非final成员变量</h2><pre><code>class Entity {
    public int i = 1;
}    

try {
    Entity e = new Entity();
    System.out.println(&quot;before: &quot; + e.i);

    Field f = Entity.class.getDeclaredField(&quot;i&quot;);
    f.setInt(e, 2);
    // 或者 f.set(e, 2);// java会自动装箱拆箱
    System.out.println(&quot;after: &quot; + e.i);
} catch (Exception e) {
    e.printStackTrace();
}
</code></pre><h2 id="final成员变量"><a href="#final成员变量" class="headerlink" title="final成员变量"></a>final成员变量</h2><pre><code>class Entity {
    public final int i = 1;
}
</code></pre><p>反射会报异常:</p>
<pre><code>java.lang.IllegalAccessException: Can not set final int field com.test.Entity.i to (int)2
</code></pre><p>修改成员变量的final修饰符,使其变为public int i = 1;具体方法如下:</p>
<pre><code>try {
    Entity e = new Entity();
    System.out.println(&quot;before: &quot; + e.i);

    Field f = Entity.class.getDeclaredField(&quot;i&quot;);

    Field modifiersField = Field.class.getDeclaredField(&quot;modifiers&quot;);
    modifiersField.setAccessible(true);
    System.out.println(f.getModifiers()); // 输出17:表示修饰符为:public final
    modifiersField.setInt(f, f.getModifiers() &amp; ~Modifier.FINAL);
    System.out.println(f.getModifiers());// 输出1:表示修饰符已经被修改为:public

    f.setAccessible(true);
    f.setInt(e, 2);
    System.out.println(&quot;after: &quot; + e.i);//输出还是1.没修过成功
} catch (Exception e) {
    e.printStackTrace();
}
</code></pre><p>发现还是没有修改成功。会不会跟是基本数据类型有关？修改成员变量的数据类型为 Integer</p>
<pre><code>class Entity {
    public final Integer i = 1;
}
</code></pre><p>然后再执行,发现结果已经被修改了</p>
<p><strong>final成员变量，对象数据类型可以修改,基本数据类型不能修改</strong></p>
<p><strong>final成员变量，final String s = new String(“a”); 可以修改,final String s = “a” 不能修改</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/27/java基础/数组转list陷阱/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/27/java基础/数组转list陷阱/" itemprop="url">数组list陷阱</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-27T15:41:53+08:00">
                2019-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>String[] artistTypes = getResources().getStringArray(R.array.artist_type);
List&lt;String&gt; list = Arrays.asList(artistTypes); 
</code></pre><p>上面代码是毫无问题的。</p>
<pre><code>String[] artistTypes = getResources().getStringArray(R.array.artist_type);
ArrayList&lt;String&gt; list = (ArrayList&lt;String&gt;) Arrays.asList(artistTypes); 
</code></pre><p>运行报错。java.util.Arrays$ArrayList cannot be cast to java.util.ArrayList</p>
<p>这就说明，Arrays.asList转出来的是Arrays$ArrayList（内部类），只是和java.util.ArrayList名字相同。</p>
<p>为什么转为List不报错呢？因为Arrays$ArrayList实现了List接口</p>
<pre><code>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements Cloneable, Serializable, RandomAccess {

public class Arrays {
    private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements
            List&lt;E&gt;, Serializable, RandomAccess {
</code></pre><p>研究过程发现</p>
<pre><code>Arrays.asList转出来的是Arrays$ArrayList继承AbstractList。remove，add等method在AbstractList中是默认throw UnsupportedOperationException而且不作任何操作。
java.util.Arrays$ArrayList继承了静态数组 大小 固定不变的特性。
</code></pre><p>找了很久，找到下面的解决方法</p>
<pre><code>List myList = new ArrayList(); 
String[] myStringArray = new String[] {&quot;Java&quot;, &quot;is&quot;, &quot;Cool&quot;};
Collections.addAll(myList, myStringArray);
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/27/java基础/泛型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/27/java基础/泛型/" itemprop="url">泛型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-27T15:40:53+08:00">
                2019-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.csdn.net/harvic880925/article/details/49872903" target="_blank" rel="noopener">夯实JAVA基本之一 —— 泛型详解(1):基本使用</a></p>
<p><a href="http://blog.csdn.net/harvic880925/article/details/49883589" target="_blank" rel="noopener">夯实JAVA基本之一——泛型详解(2)：高级进阶</a></p>
<h1 id="泛型的优点"><a href="#泛型的优点" class="headerlink" title="泛型的优点"></a>泛型的优点</h1><p>java为什么引入泛型：</p>
<ul>
<li>类型安全。 在编译的时候检查类型安全</li>
<li>消除强制类型转换。所有的强制转换都是自动和隐式的</li>
<li>潜在的性能收益。 泛型为以后较大的优化带来可能。由于泛型的实现方式，支持泛型（几乎）不需要 JVM 或类文件更改，所有工作都在编译器中完成</li>
</ul>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li><p>只存在编译期（.class文件也存储着泛型信息），运行期间已经去泛型化了。</p>
</li>
<li><p>接口Type下有：final class <code>Class&lt;T&gt;</code>; interface <code>ParameterizedType</code></p>
</li>
<li><p>静态块，静态属性，静态方法 不能使用泛型。</p>
</li>
<li>定义格 <t> &lt;T,S&gt; &lt;T,S extends T&gt;</t></li>
<li><p>字母规范</p>
<pre><code>E — Element，常用在java Collection里，如：List&lt;E&gt;,Iterator&lt;E&gt;,Set&lt;E&gt;
K,V — Key，Value，代表Map的键值对
N — Number，数字
T — Type，类型，如String，Integer等等
</code></pre></li>
</ul>
<h1 id="一、基本使用"><a href="#一、基本使用" class="headerlink" title="一、基本使用"></a>一、基本使用</h1><h2 id="1-泛型类"><a href="#1-泛型类" class="headerlink" title="1.泛型类"></a>1.泛型类</h2><ul>
<li>直接在类名后面定义泛型参数</li>
<li>父类定义的类型参数不能被子类继承。</li>
<li>T表示派生自Object类的类，比如String（String在类中怎么用，那T在类中就可以怎么用！）</li>
</ul>
<p>所以下面的：定义变量，作为返回值，作为参数传入的定义就很容易理解了。</p>
<pre><code>class Point&lt;T&gt;{// 在类上定义泛型  
    private T x ; //作为成员变量         
    private T y ;        
    public void setX(T x){//作为参数  
        this.x = x ;  
    }  
    public void setY(T y){  
        this.y = y ;  
    }  
    public T getX(){//作为返回值  
        return this.x ;  
    }  
    public T getY(){  
        return this.y ;  
    }  
};

使用
Point&lt;Integer&gt; p = new Point&lt;Integer&gt;() ; 




public class TestClassDefine&lt;T, S extends T&gt; {
     ....  
}
</code></pre><h2 id="2-泛型接口"><a href="#2-泛型接口" class="headerlink" title="2.泛型接口"></a>2.泛型接口</h2><pre><code>interface Info&lt;T&gt;{        // 在接口上定义泛型    
    public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型    
    public void setVar(T x);  
}

使用方法一：非泛型类
class InfoImpl implements Info&lt;String&gt;{   // 定义泛型接口的子类。 
                                         //    为父类泛型赋值，泛型放在InfoImpl会造成无法正确识别泛型类型（如覆盖的父类方法参数返回值泛型错误）
    private String var ;                // 定义属性  
    public InfoImpl(String var){        // 通过构造方法设置属性内容  
        this.setVar(var) ;  
    }  
    @Override  
    public void setVar(String var){  
        this.var = var ;  
    }  
    @Override  
    public String getVar(){  
        return this.var ;  
    }  
}

使用方法二：泛型类。泛型类InfoImpl&lt;T&gt;把泛型变量T传给了Info&lt;T&gt;(泛型赋值泛型)，这说明接口和泛型类使用的都是同一个泛型变量
class InfoImpl&lt;T&gt; implements Info&lt;T&gt;{   // 定义泛型接口的子类  
    private T var ;             // 定义属性  
    public InfoImpl(T var){     // 通过构造方法设置属性内容  
        this.setVar(var) ;    
    }  
    public void setVar(T var){  
        this.var = var ;  
    }  
    public T getVar(){  
        return this.var ;  
    }  
}  
</code></pre><h2 id="3-泛型方法（返回值泛型，称为泛型方法）"><a href="#3-泛型方法（返回值泛型，称为泛型方法）" class="headerlink" title="3.泛型方法（返回值泛型，称为泛型方法）"></a>3.泛型方法（返回值泛型，称为泛型方法）</h2><pre><code>public class StaticFans {  // 在返回值处定义泛型
    public static  &lt;T&gt; void StaticMethod(T a){//静态函数    
        Log.d(&quot;harvic&quot;,&quot;StaticMethod: &quot;+a.toString());  
    }  

    public  &lt;T&gt; void OtherMethod(T a){   //普通函数  
        Log.d(&quot;harvic&quot;,&quot;OtherMethod: &quot;+a.toString());  
    }  

    public static &lt;T&gt; List&lt;T&gt; parseArray(String response,Class&lt;T&gt; object){  //进阶：返回值中存在泛型
        List&lt;T&gt; modelList = JSON.parseArray(response, object);  
        return modelList;  
    }
}  

使用方法一 :隐式为泛型赋值，代码不利阅读和维护（看不出调用的是一个泛型函数）
StaticFans.StaticMethod(&quot;adfdsa&quot;); //yin

使用方法二 :显式为泛型赋值，强烈推荐   
StaticFans.&lt;String&gt;StaticMethod(&quot;adfdsa&quot;);

如果仅仅是想实现多态，请优先使用通配符解决。
 public &lt;T&gt; void testGenericMethodDefine2(List&lt;T&gt; s){
     ...
 }
 应改为
 public void testGenericMethodDefine2(List&lt;？&gt; s){
     ...
 }
</code></pre><h2 id="4-Class-lt-T-gt-传递泛型的Class对象"><a href="#4-Class-lt-T-gt-传递泛型的Class对象" class="headerlink" title="4. Class&lt;T&gt; 传递泛型的Class对象"></a>4. <code>Class&lt;T&gt;</code> 传递泛型的Class对象</h2><p>Class<t>也是一泛型，它是传来用来装载类的class对象的</t></p>
<pre><code>public final class Class&lt;T&gt; implements Serializable, GenericDeclaration, Type, AnnotatedElement {  
    …………  
} 
</code></pre><p>实例：Gson解析</p>
<pre><code>public static &lt;T&gt; List&lt;T&gt; parseArray(String response,Class&lt;T&gt; object){  //进阶：返回值中存在泛型
    List&lt;T&gt; modelList = JSON.parseArray(response, object);  
    return modelList;  
} 
</code></pre><h2 id="5-泛型数组"><a href="#5-泛型数组" class="headerlink" title="5. 泛型数组"></a>5. 泛型数组</h2><pre><code>public static &lt;T&gt; T[] fun1(T...arg){  // 泛型数组   
       return arg ;            // 返回泛型数组    
} 


public static void main(String args[]){  //使用  
       Integer i[] = fun1(1,2,3,4,5,6) ;  
       Integer[] result = fun1(i) ;  
} 


3.通配符 ？
    在Java集合框架中，对于参数值是未知类型的容器类，只能读取其中元素，不能向其中添加元素，
    因为，其类型是未知，所以编译器无法识别添加元素的类型和容器的类型是否兼容，唯一的例外是NULL
</code></pre><h1 id="二、泛型边界-界限-绑定：extends"><a href="#二、泛型边界-界限-绑定：extends" class="headerlink" title="二、泛型边界/界限/绑定：extends"></a>二、泛型边界/界限/绑定：extends</h1><ul>
<li><p>class Point<t> 内部，变量T x 只能调用Object所具有的函数，因为编译器根本不知道T具体是什么类型（编译器唯一能确定的是，T肯定是Object的子类）</t></p>
</li>
<li><p>如果我希望在泛型类内部能调用一些其他的方法，就需要用到类型绑定（其实就是给泛型参数添加一个界限）</p>
<pre><code>&lt;T extends BoundingType&gt; 
</code></pre></li>
<li><p>这里的extends不是类继承里的那个extends！两个根本没有任何关联。</p>
</li>
<li><p>这里extends后的BoundingType可以是类，也可以是接口。</p>
</li>
<li><p>两个作用</p>
<ol>
<li>限定可以填充的泛型 </li>
<li>使用泛型变量T时，可以使用BoundingType内部的函数</li>
</ol>
</li>
</ul>
<h2 id="1-extends-类"><a href="#1-extends-类" class="headerlink" title="1. extends 类"></a>1. extends 类</h2><pre><code>class Fruit {  
    private String name;  

    public String getName() {  
        return name;  
    }  
    public void setName(String name) {  
        this.name = name;  
    }  
}  

public static &lt;T extends Fruit&gt; String getFruitName(T t){  
    return t.getName();  
} 

class Banana extends Fruit{  
    public Banana(){  
        setName(&quot;bababa&quot;);  
    }  
}  
class Apple extends Fruit{  
    public Apple(){  
        setName(&quot;apple&quot;);  
    }  
}

String name_1 = getFruitName(new Banana());  
String name_2 = getFruitName(new Apple());  
Log.d(TAG,name_1);  
Log.d(TAG,name_2); 
</code></pre><h2 id="2-extends-接口"><a href="#2-extends-接口" class="headerlink" title="2. extends 接口"></a>2. extends 接口</h2><pre><code>public interface Comparable&lt;T&gt; {  
    public boolean compareTo(T i);  
}  

public static &lt;T extends Comparable&gt;  T min(T...a){  //添加上extends Comparable之后，就可以Comparable里的函数了  
    T smallest = a[0];  
    for(T item:a){  
        if (smallest.compareTo(item)){  //compareTo对比的是同一种类型
            smallest = item;  
        }  
    }  
    return smallest;  
} 

实现一个派生自Comparable接口的类 StringCompare
把T也填充为StringCompare类型，因为 compareTo的参数必须是与调用者自身是同一类型
public class StringCompare implements Comparable&lt;StringCompare&gt; {  
    private String mStr;  

    public StringCompare(String string){  
        this.mStr = string;  
    }  

    @Override  
    public  boolean compareTo(StringCompare str) {  
        if (mStr.length() &gt; str.mStr.length()){  
            return true;  
        }  
        return false;  
    }  
}  

使用min函数
StringCompare result = min(new  StringCompare(&quot;123&quot;),new StringCompare(&quot;59897&quot;));  
Log.d(TAG,&quot;min:&quot;+result.mStr)
</code></pre><h2 id="3-extends-多边界"><a href="#3-extends-多边界" class="headerlink" title="3. extends 多边界"></a>3. extends 多边界</h2><pre><code>public static &lt;T extends Fruit&amp;Serializable&gt; String getFruitName(T t){  
    return t.getName();  
} 
</code></pre><h1 id="三、无边界通配符：？"><a href="#三、无边界通配符：？" class="headerlink" title="三、无边界通配符：？"></a>三、无边界通配符：<code>？</code></h1><pre><code>Point&lt;?&gt; point; 
point = new Point&lt;Integer&gt;(3,3);  
point = new Point&lt;Float&gt;(4.3f,4.3f); 
</code></pre><ul>
<li><p><code>？</code> 与 <code>T</code> 的区别</p>
<ul>
<li>他们俩没有任何联系！！！！！</li>
<li><p>泛型变量T只能在类，接口，函数中声明以后，才能使用。</p>
<pre><code>public class Box&lt;T&gt; {  
   public T get(){  
       …………  
   };  
   public void put(T element){  
       …………  
   };  
}
</code></pre></li>
<li><p>无边界通配符？则只是填充方式的一种！！！只能用于填充泛型变量T，表示通配任何类型！！！！</p>
<pre><code>Box&lt;?&gt; box;   //无边界通配符填充  
Box&lt;String&gt; stringBox; //其它类型填充   
</code></pre></li>
<li><p>无边界通配符？只能用于填充泛型变量T,不能用于定义变量</p>
<p>  Box&lt;?&gt; box;<br>  box = new Box<string>();  //正确<br>  box = new Box&lt;？&gt;();  //错误</string></p>
</li>
</ul>
</li>
<li><p>无边界通配符 是 泛型实例 缺省填充类型</p>
<p>  构造泛型实例时，如果省略了填充类型，则默认填充为无边界通配符！</p>
<pre><code>//这两个是对等的：
Point point3 = new Point(new Integer(23),new Integer(23));  
Point&lt;?&gt; point3 = new Point(new Integer(23),new Integer(23));  
</code></pre><p>  平时可能没注意，反射时，我们一直在用缺省泛型填充类型这个小技巧</p>
<pre><code>Class class1 = Animal.class;  
Class&lt;?&gt; class2= Animal.class; 
Class&lt;Animal&gt; class2= Animal.class; //正规写法
</code></pre></li>
</ul>
<h2 id="四、-无边界通配符：？-的-边界-界限-绑定-–-extends-super"><a href="#四、-无边界通配符：？-的-边界-界限-绑定-–-extends-super" class="headerlink" title="四、 无边界通配符：？ 的 边界/界限/绑定 – extends super"></a>四、 无边界通配符：<code>？</code> 的 边界/界限/绑定 – <code>extends</code> <code>super</code></h2><h2 id="1-extends-XXX-填充为XXX或XXX的子类（上边界，包括边界）"><a href="#1-extends-XXX-填充为XXX或XXX的子类（上边界，包括边界）" class="headerlink" title="1. ? extends XXX 填充为XXX或XXX的子类（上边界，包括边界）"></a>1. <code>? extends XXX</code> 填充为XXX或XXX的子类（上边界，包括边界）</h2><pre><code>Point&lt;? extends Number&gt; point;
point = new Point&lt;Integer&gt;(3,3);  
point = new Point&lt;Number&gt;(); //正确。说明包括边界自身
point = new Point&lt;String&gt;(&quot;&quot;,&quot;&quot;);  //报错
</code></pre><ul>
<li><p>利用&lt;? extends Number&gt;定义的变量，<code>能取不能存</code></p>
<pre><code>Point&lt;? extends Number&gt; point;
point = new Point&lt;Integer&gt;(3,3);
Number n = point.getX();
point.setX(new Integer(4)); //报错
</code></pre><ul>
<li>Point&lt;? extends Number&gt; point，Point的泛型变量T 填充为 &lt;? extends Number&gt;，这是一个 未知类型！！！</li>
<li>编译器，只要能确定通配符类型，就会允许，如果无法确定通配符的类型，就会报错</li>
<li>取，编译器能确定的是T肯定是Number的子类</li>
<li>存，编译器不能用一个未知类型来设置内部成员变量值</li>
</ul>
</li>
</ul>
<h2 id="2-super-XXX-填充为XXX或XXX的父类（下边界，包括边界）"><a href="#2-super-XXX-填充为XXX或XXX的父类（下边界，包括边界）" class="headerlink" title="2. ? super XXX 填充为XXX或XXX的父类（下边界，包括边界）"></a>2. <code>? super XXX</code> 填充为XXX或XXX的父类（下边界，包括边界）</h2><ul>
<li><p>利用&lt;? super Manager&gt;定义的变量，<code>能存不能取</code></p>
<pre><code>class Employee {  
}  
class Manager extends Employee {  
}
class CEO extends Manager {  
}   

List&lt;? super Manager&gt; list;  
list = new ArrayList&lt;Employee&gt;();  
//存  
list.add(new Employee()); //编译错误  
list.add(new Manager());  
list.add(new CEO());  
Object object = list.get(0);//取出来的是Object，毫无意义
</code></pre><ul>
<li>List&lt;? super Manager&gt; list，List的泛型变量T 填充为 &lt;? super Manager&gt;，这是一个 未知类型！！！</li>
<li>编译器，只要能确定通配符类型，就会允许，如果无法确定通配符的类型，就会报错</li>
<li>存，编译器能确定的是Manager、CEO肯定是&lt;? super Manager&gt;的子类，所以肯定是可以add进去的。但Employee不一定是&lt;? super Manager&gt;的子类</li>
<li>取，编译器能确定的是&lt;? super Manager&gt;肯定是Manger的父类；但不能确定到底是什么具体类型。但必然是Object的子类！</li>
</ul>
</li>
</ul>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><ul>
<li>? extends 通配符（上边界，能取不能存，取出来保存为上边界类型）</li>
<li>? super 通配符（下边界，能存不能取，能存下边界及下边界子类，取出来保存为上边界类型（这里没有，所以是Object，取到Object类型毫无意义））</li>
<li>如果该数据类型里你既想存，又想取，那就别用通配符。</li>
</ul>
<p>三、获取泛型类型</p>
<pre><code>T.class是获取不到泛型类型的（所以gson提供了TypeToken来确定泛型）
但是类实例对象（包括子类实现父类方法）是可以争取识别出泛型类型的
    public class LoginHandler extends NetHandler&lt;LoginResultBean&gt; {
        public void doOnSuccess(CommonResponseBean&lt;LoginResultBean&gt; bean) {}
    }

1.构造函数中显示地传入泛型类的Class类型
    public class Foo&lt;T&gt;{
         public Class&lt;T&gt; type;

         public Foo(Class&lt;T&gt; clazz){
            this.type = clazz;
         }
    }

2.foo.getClass().getGenericSuperclass().getActualTypeArguments()[0]
</code></pre><p>TypeToken</p>
<pre><code>List&lt;Person&gt; people = gson.fromJson(jsonData, new TypeToken&lt;List&lt;Person&gt;&gt;(){}.getType());
</code></pre><p>源码</p>
<pre><code>public class TypeToken&lt;T&gt; {
    final Class&lt;? super T&gt; rawType;
    final Type type;
    final int hashCode;

//这里的空参构造方法权限修饰符是protected,那木只有其子类可访问，预示着要使用子类构造。
    protected TypeToken() {
        this.type = getSuperclassTypeParameter(this.getClass());//这里传入的子类，后面2行不用看
        this.rawType = Types.getRawType(this.type);
        this.hashCode = this.type.hashCode();
    }

   ...

    static Type getSuperclassTypeParameter(Class&lt;?&gt; subclass) {
        Type superclass = subclass.getGenericSuperclass();//获取到子类的父类Type
        if(superclass instanceof Class) {
            throw new RuntimeException(&quot;Missing type parameter.&quot;);
        } else {
            ParameterizedType parameterized = (ParameterizedType)superclass;//将Type类型向下转型为参数化类型ParameterizedType
            return Types.canonicalize(parameterized.getActualTypeArguments()[0]);//这里getActualTypeArguments()返回的是一个数组，由于只有一个泛型参数,直接[0]。
        }
    }    
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/27/java基础/线程池/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/27/java基础/线程池/" itemprop="url">线程池</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-27T11:31:53+08:00">
                2019-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h2><ul>
<li>重用线程池中的线程，避免频繁地创建和销毁线程带来的性能消耗；</li>
<li>有效控制线程的最大并发数量，防止线程过大导致抢占资源造成系统阻塞；</li>
<li>可以对线程进行一定地管理</li>
<li>解耦作用；线程的创建和执行完全分开，方便维护。</li>
</ul>
<p>阿里巴巴Java开发手册关于线程和线程池有这么两段话</p>
<img src="/2019/03/27/java基础/线程池/线程池.png">
<ul>
<li>不能显示创建线程(new Thread)，需要使用线程池对线程进行管理</li>
<li>不允许使用官方提供的四种线程池，而是需要通过自行创建的方式去创建线程池，更加理解线程池的允许规则</li>
</ul>
<h1 id="线程池原理-ThreadPoolExecutor"><a href="#线程池原理-ThreadPoolExecutor" class="headerlink" title="线程池原理 ThreadPoolExecutor"></a><a href="https://juejin.im/post/5c99c29ee51d4559bb5c6541#heading-5" target="_blank" rel="noopener">线程池原理 ThreadPoolExecutor</a></h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>corePoolSize</strong>：核心线程的数量<ul>
<li>默认不会被回收掉</li>
<li>设置了allowCoreTimeOut为true，核心线程闲置超时，也会被回收。</li>
<li>核心线程和非核心线程本质上并没有什么区别</li>
</ul>
</li>
<li><strong>maximumPoolSize</strong> ：最大线程数量<ul>
<li>线程池能容纳的最大容量，上限被CAPACITY限制（2^29-1）（后续代码会看到）</li>
</ul>
</li>
<li><strong>keepAliveTime</strong>：闲置线程被回收的时间限制，也就是闲置线程的存活时间</li>
<li><strong>unit</strong> ：keepAliveTime的单位</li>
<li><strong>workQueue</strong> ：用于存放任务的队列</li>
<li><strong>threadFactory</strong> ：创建线程的工厂类</li>
<li><strong>handler</strong> 当任务执行失败时，使用handler通知调用者，代表拒绝的策略</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>一个公司，核心线程就是代表公司的内部核心员工，最大线程数量就是员工的最大数量，可能包含非正式员工，因为有一些试点或者简单的项目，需要一些外协人员来做，也就是非核心线程，那么当这些项目做完了或者失败了，公司为了节约用人成本，就遣散非核心员工，也就是闲置线程的存活时间。假如核心员工每个人都很忙，但是需求又一波接一波，那就任务排期，也就是任务队列(并不会直接创建非核心线程去执行任务，可以理解为需求任务首先是需要让内部核心员工去完成的，任务队列的优先级是高于非核心员工的，addWorker()，这里的传进去的boolean值，就代表着创建核心线程或者非核心线程)，当任务队列都满了时候，给非正式员工做，非正式员工也满负荷还要来需求？对不起，不接受，直接拒绝，这也就是handler对应的拒绝策略了</p>
<h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>
<p>AtomicInteger是一个原子操作类，保证线程安全</p>
<p>高3位表示5种线程池状态,低29位表示线程的最大数量</p>
<p>维护两个参数，workCount和runState。workCount表示有效的线程数量，runState表示线程池的运行状态。</p>
<ul>
<li><strong>RUNNING</strong>：运行状态，可以接受新任务并处理</li>
<li><strong>SHUTDOWN</strong>：关闭状态，不会接受新的任务了，但是会处理<strong>队列</strong>中还存在的任务</li>
<li><strong>STOP</strong>：停止状态，不会接受新的任务，也不处理队列任务，直接中断</li>
<li><strong>TIDYING</strong>：表示所有任务已经终止了</li>
<li><strong>TERMINATED</strong>：表示terminated()方法已经执行完成</li>
</ul>
<p>RUNNING：运行状态，可以接受新任务并处理<br>SHUTDOWN：关闭状态，不会接受新的任务了，但是会处理队列中还存在的任务<br>STOP：停止状态，不会接受新的任务，也不处理队列任务，直接中断<br><strong>TIDYING </strong>：表示所有任务已经终止了<br>TERMINATED：表示terminated()方法已经执行完成</p>
<img src="/2019/03/27/java基础/线程池/线程池状态.png">
<h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><h3 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">	<span class="comment">//如果当前线程数量小于核心线程数量，执行addWorker创建新线程执行command任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果当前是运行状态，将任务放入阻塞队列，double-check线程池状态</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">//如果再次check，发现线程池状态不是运行状态了，移除刚才添加进来的任务，并且拒绝改任务</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//处于运行状态，但是没有线程，创建线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//往线程池中创建新的线程失败，则reject任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当前线程数量小于核心线程数量<ul>
<li>addWorker创建新核心线程执行任务<ul>
<li>成功，return</li>
<li>失败，下一步</li>
</ul>
</li>
</ul>
</li>
<li>线程池是运行状态，且将任务放入队列成功<ul>
<li>再次检查线程池状态<ul>
<li>不是运行状态，且能够移除刚才添加的任务<ul>
<li>拒绝该任务</li>
</ul>
</li>
<li>线程数量为0<ul>
<li>创建非核心线程</li>
</ul>
</li>
</ul>
</li>
<li>失败，下一步</li>
</ul>
</li>
<li>addWorker创建新非核心线程执行任务<ul>
<li>失败<ul>
<li>拒绝该任务  </li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="double-check线程池状态"><a href="#double-check线程池状态" class="headerlink" title="double-check线程池状态"></a>double-check线程池状态</h4><p>在多线程的环境下，ctl.get()这个方法并不是一个原子操作，如果加入队列后，线程池状态改变了，不是RUNNING状态，那么这个任务将永远不会被执行，所以需要再次check，如果不是RUNNING状态，移除任务并拒绝任务</p>
<h3 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker()"></a>addWorker()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        <span class="comment">// 这里return false的情况有以下几种</span></span><br><span class="line">       	<span class="comment">//1.当前状态是stop及以上 2.当前是SHUTDOWN状态，但是firstTask不为空</span></span><br><span class="line">        <span class="comment">//3.当前是SHUTDOWN状态，但是队列中为空</span></span><br><span class="line">        <span class="comment">//从第一节我们知道，SHUTDOWN状态是不执行进来的任务的，但是会继续执行队列中的任务</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2层循环</p>
<ul>
<li>外部循环查询线程池状态<ul>
<li>如果当前是stop及之上的状态，直接return false</li>
<li>如果是SHUTDOWN状态，并且firstTask不为空或者队列中是空的，直接return false</li>
</ul>
</li>
<li>内部循环查询线程数量<ul>
<li>通过传递进来的boolean值，分别和核心线程以及最大线程数量进行对比，如果成立，worker数量+1，并且跳出循环。</li>
<li>跳出循环就是实际执行任务了，Worker就将工作线程和任务封装到了自己内部，我们可以将Worker看成就是一个工作线程</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>线程池中的细节比较多，大致做一下总结归纳</p>
<ul>
<li>线程池的构造参数决定了线程池的运行策略，需要理解每个参数的含义，因为每个参数的不同很大程度上决定了这个线程池的运行规则，这也是为什么阿里巴巴开发手册中提到通过自行创建的方式去创建线程池，而不是使用官方提供的4种线程池</li>
<li>线程池涉及多线程问题，状态改变比较频繁，在进行任务执行时，需要多次check线程池的状态，保证任务被执行的准确性</li>
<li>任务队列的优先级高于非核心线程，核心线程满的时候，会先把任务放进任务队列，其次开启非核心线程进行执行</li>
<li>核心线程和非核心线程本质上并没有什么区别，在核心线程设置allowCoreThreadTimeOut 属性为true时，最终也会因为超时而被销毁</li>
<li>线程池总览就是通过两个变量来整体控制整个流程，线程池的状态，线程池中线程数量，涉及的方法不是很多，但是循环比较多，需要理解每个循环的跳出条件以及对应的状态。</li>
</ul>
<h1 id="线程池使用"><a href="#线程池使用" class="headerlink" title="线程池使用"></a><a href="https://juejin.im/post/5b5e5fa96fb9a04fb900e1ce#heading-5" target="_blank" rel="noopener">线程池使用</a></h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul>
<li>shutDown()，关闭线程池，需要执行完已提交的任务；</li>
<li>shutDownNow()，关闭线程池，并尝试结束已提交的任务；</li>
<li>execute()，提交任务无返回值；</li>
<li>submit()，提交任务有返回值；</li>
</ul>
<h2 id="监控线程池"><a href="#监控线程池" class="headerlink" title="监控线程池"></a>监控线程池</h2><p>ThreadPoolExecutor 提供不少 api 可以获取线程池状态</p>
<p>也可以继承线程池扩展其中的几个函数来自定义监控逻辑(线程执行前、后、终止状态)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function">rotected <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程池隔离"><a href="#线程池隔离" class="headerlink" title="线程池隔离"></a>线程池隔离</h2><p>业务都依赖于同一个线程池,当其中一个业务因为各种不可控的原因消耗了所有的线程，导致线程池全部占满。其他的业务也就不能正常运转了，这对系统的打击是巨大的</p>
<p>通常的做法是按照<strong>业务</strong>进行划分</p>
<h3 id="hystrix-隔离"><a href="#hystrix-隔离" class="headerlink" title="hystrix 隔离"></a><a href="https://github.com/Netflix/Hystrix" target="_blank" rel="noopener">hystrix 隔离</a></h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>利用一个 Map 来存放不同业务对应的线程池</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="风" />
            
              <p class="site-author-name" itemprop="name">风</p>
              <p class="site-description motion-element" itemprop="description">随心而动，随刃而行</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">171</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">风</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
