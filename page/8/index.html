<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="随心而动，随刃而行">
<meta property="og:type" content="website">
<meta property="og:title" content="风">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="风">
<meta property="og:description" content="随心而动，随刃而行">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="风">
<meta name="twitter:description" content="随心而动，随刃而行">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/8/"/>





  <title>风</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">风</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">技术博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/03/直播/视频/Android视频录制app解决方案汇总/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/03/直播/视频/Android视频录制app解决方案汇总/" itemprop="url">Android视频录制app解决方案汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-03T14:52:14+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/直播/" itemprop="url" rel="index">
                    <span itemprop="name">直播</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.zybuluo.com/lichangadd/note/148109" target="_blank" rel="noopener">Android视频录制app解决方案汇总</a></p>
<p>现在视频App很多：蝌蚪音客、美拍、小影、还有最近火起来的小咖秀。</p>
<p>这类App的技术难点基本都是在音视频处理这一块</p>
<p>iOS对多媒体处理的支持还算比较丰富，Android差很多。</p>
<p>这里总结蝌蚪音客在多媒体处理上遇到的问题，供大家参考下。</p>
<h1 id="一、录制方视频-1：1"><a href="#一、录制方视频-1：1" class="headerlink" title="一、录制方视频(1：1)"></a>一、录制方视频(1：1)</h1><p>现在市面上的视频应用的视频尺基本全部都是1：1的，这对于Android开发者来说就是一个比较棘手的问题，Android原生Recorder类并不支持视频比例的设置。</p>
<p>所以只能想其他办法，目前常用的办法大致可以分为2种：</p>
<h2 id="a-摒弃原生接口，使用FFmpeg或OpenCV等方式进行录制"><a href="#a-摒弃原生接口，使用FFmpeg或OpenCV等方式进行录制" class="headerlink" title="a. 摒弃原生接口，使用FFmpeg或OpenCV等方式进行录制"></a>a. 摒弃原生接口，使用FFmpeg或OpenCV等方式进行录制</h2><ul>
<li><p><strong>缺点</strong></p>
<p>  对开发者技术要求较高，FFmpeg和OpenCV<strong>移植麻烦</strong>，<strong>多机型兼容复杂</strong> 并且要求开发者一定程度的<strong>C语言功底</strong></p>
</li>
<li><p><strong>最难解决的问题是性能问题</strong></p>
<p>  FFmeg和OpenCV都是开源方案，如果要真正达实用级别往往还<strong>需要优化定制</strong>，这对于熟练于做Android展现的开发者来说完全就是一个新的领域。蝌蚪音客就尝试过这种方案，结果视频的码率只能做到15fps左右，这明显是不够的。</p>
</li>
</ul>
<h2 id="b-使用原生API录制，遮罩1：1视觉效果"><a href="#b-使用原生API录制，遮罩1：1视觉效果" class="headerlink" title="b. 使用原生API录制，遮罩1：1视觉效果"></a>b. 使用原生API录制，遮罩1：1视觉效果</h2><ul>
<li><p>在录制界面使用遮罩的方式给用户一种1：1的错觉。</p>
</li>
<li><p>在预览视频时，使用FFmpeg进行视频裁剪。</p>
</li>
</ul>
<p><strong>如果团队没有驾驭FFmpeg的能力，个人建议使用这种方式。</strong></p>
<p>视频录制功能来说相对简单，而且裁剪命令优化后基本可以可以做到视频预览一遍也就基本裁剪完毕(<strong>耗时&gt;=视频时长</strong>，真心伤)。</p>
<h1 id="二、本地视频压缩"><a href="#二、本地视频压缩" class="headerlink" title="二、本地视频压缩"></a>二、本地视频压缩</h1><p><strong>本地视频压缩除了FFmpeg之外目前还没有了解到有其他方案</strong></p>
<p>但是压缩命令的优化可是一门学问，使用 <code>x264</code> 还是 <code>mpeg4</code>，<code>码率</code>，<code>分辨率</code>，<code>帧频</code>，<code>文件大小</code> 等都会影响到 <code>压缩速度</code> 而且差别相当大。</p>
<p>在android平台运行效率实在蛋疼，测试压缩一个mp4，<strong>耗时&gt;=视频时长x6</strong>。网络说在CentOS服务器上跑都是 耗时=视频时长</p>
<h1 id="三、m3u8解决方案"><a href="#三、m3u8解决方案" class="headerlink" title="三、m3u8解决方案"></a>三、m3u8解决方案</h1><p>绝对不建议创业公司<strong>自己编写播放器，绝对无底洞</strong>，还不如直接使用MP4文件格式。</p>
<p>m3u8国内比较出名的是 <strong>vitamio</strong>，还有一些韩国人的技术方案。但是vitamio的<strong>开源版本感觉很久没有更新</strong>，而且商业版本的授权动则几十万</p>
<p><strong>推荐使用百度媒体云的m3u8的解决方案</strong>，代码家的AnimeTaste使用的就是这个，完全免费，项目质量还算稳定。但是<strong>只能做成单例</strong>，如果想集成到listview中，需要费点事。</p>
<h1 id="四、视频滤镜、水印"><a href="#四、视频滤镜、水印" class="headerlink" title="四、视频滤镜、水印"></a>四、视频滤镜、水印</h1><ul>
<li><p>水印 </p>
<p>  <strong>FFmpeg</strong> 在视频处理的过程中可以并行处理水印。</p>
</li>
<li><p>视频滤镜</p>
<p>  赶紧花钱招大牛吧。</p>
<p>  据说小影的开发Leader在视频处理领域里沉浸了20多年。</p>
<p>  目前这部分笔者还是在了解阶段，目前看到的方案有使用GPUImage进行处理的，但是无奈对图像处理的知识掌握的太少，迟迟没有动手。</p>
</li>
</ul>
<h1 id="五、趣拍云"><a href="#五、趣拍云" class="headerlink" title="五、趣拍云"></a>五、<a href="https://www.qupaicloud.com/" target="_blank" rel="noopener">趣拍云</a></h1><p>阿里百川和趣拍合作推出，包括 短视频sdk 和 直播sdk。收费不便宜</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/03/直播/视频/视频播放/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/03/直播/视频/视频播放/" itemprop="url">视频播放</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-03T14:52:14+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/直播/" itemprop="url" rel="index">
                    <span itemprop="name">直播</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android视频播放器的选择"><a href="#Android视频播放器的选择" class="headerlink" title="Android视频播放器的选择"></a><a href="https://appkfz.com/2017/08/27/ijkplayer-sutdy-1/" target="_blank" rel="noopener">Android视频播放器的选择</a></h1><ul>
<li><p><strong>MediaPlayer</strong></p>
<ul>
<li>原生实现</li>
<li>只使用硬解播放，基只支持本地和HTTP协议的视频播放，扩展性很差，只适合最简单的视频播放需求</li>
</ul>
</li>
<li><p><strong>VideoView</strong></p>
<p>  将MediaPlayer，SurfaceView封装</p>
</li>
<li><p><strong><a href="https://github.com/google/ExoPlayer" target="_blank" rel="noopener">ExoPlayer</a></strong></p>
<ul>
<li>提供了更好的扩展性和定制能力</li>
<li>加入了对DASH和HLS等直播协议的支持</li>
<li>但也只支持硬码<ul>
<li>如果项目中只需要支持对H264格式的视频播放，以及流媒体协议比较常规（比如HTTP，HLS），基于ExoPlayer定制也是不错的选择。</li>
</ul>
</li>
</ul>
</li>
<li><p>ijkplayer</p>
<ul>
<li>Bilibili公司开源的播放器实现</li>
<li>整合了FFMpeg, ExoPlayer, MediaPlayer，EXOPlayer等多种实现</li>
<li>提供了类似于MediaPlayer的API</li>
<li>实现软硬解码自由切换</li>
<li>自定义TextureView实现</li>
<li>得益于FFMpeg的能力，也能支持多种流媒体协议（RTSP，RTMP，HLS等），多种视频编码格式（h264, mpeg4, mjpeg)，具有很高的灵活性，可以定制实现自己特色的播放器（比如支持视频缩放，视频翻转等）。</li>
</ul>
</li>
</ul>
<h1 id="视频旋转角度问题"><a href="#视频旋转角度问题" class="headerlink" title="视频旋转角度问题"></a>视频旋转角度问题</h1><p>视频是带有旋转角度信息的。</p>
<p>播放时，需要获取角度并相应设置播放角度，才能正常播放视频</p>
<p>获取视频元信息的开源库 - <a href="https://github.com/wseemann/FFmpegMediaMetadataRetriever" target="_blank" rel="noopener">FFmpegMediaMetadataRetriever</a></p>
<p><strong>MediaPlaer已经处理好旋转角度问题</strong></p>
<p><a href="http://blog.csdn.net/jdsjlzx/article/details/51884784" target="_blank" rel="noopener">ijkplayer没有处理，需要开发者自行处理</a> 或 <a href="https://github.com/pili-engineering/PLDroidPlayer/issues/444" target="_blank" rel="noopener">参考PLDroidPlayer issues</a></p>
<p>实际测试中（MP4格式）发现没有回调MEDIA_INFO_VIDEO_ROTATION_CHANGED</p>
<pre><code>private PLMediaPlayer.OnInfoListener mOnInfoListener = new PLMediaPlayer.OnInfoListener() {
        @Override
        public boolean onInfo(PLMediaPlayer plMediaPlayer, int what, int extra) {
            Log.d(TAG, &quot;onInfo: &quot; + what + &quot;, &quot; + extra);
            switch (what) {
                case PLMediaPlayer.MEDIA_INFO_VIDEO_ROTATION_CHANGED:
                    Log.d(TAG, &quot;MEDIA_INFO_VIDEO_ROTATION_CHANGED: &quot; + extra);
                    if(extra==90) {
                       //设置播放视频角度
                    mVideoView.setDisplayOrientation(270);
                    }
                    break;
            }
            return false;
        }
    };
</code></pre><h1 id="VideoView视频播放等比缩放"><a href="#VideoView视频播放等比缩放" class="headerlink" title="VideoView视频播放等比缩放"></a><a href="http://jingyan.baidu.com/article/9f7e7ec080ecb36f2815541d.html" target="_blank" rel="noopener">VideoView视频播放等比缩放</a></h1><p>不同分辨率下不同size的视频资源会被拉伸变形</p>
<p>解决方案：</p>
<ul>
<li><p>setOnPreparedListener获取视频宽高，根据屏幕宽高进行等比缩放</p>
<pre><code>videoView.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {
    @Override
    public void onPrepared(MediaPlayer mediaPlayer) {
        videoWidth = mediaPlayer.getVideoWidth();
        videoHeight = mediaPlayer.getVideoHeight();
        //根据屏幕宽高进行等比缩放
        viv.setLayoutParams(calculateVideoViewParam());
        viv.start();
    }
});
</code></pre></li>
<li><p>onConfigurationChanged监听横竖屏切换，视频进行等比缩放</p>
<pre><code>public void onConfigurationChanged(Configuration newConfig) {
    if (newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE) {
        Log.e(&quot;info&quot;, &quot;横屏&quot;);
        isLandScape = true;
    } else {
        Log.e(&quot;info&quot;, &quot;竖屏&quot;);
        isLandScape = false;
    }
    RelativeLayout.LayoutParams params = calculateVideoViewParam();
    videoView.setMeasure(params.width, params.height);
    videoView.getHolder().setFixedSize(params.width, params.height);
    videoView.requestLayout();
    videoView.refreshDrawableState();
    videoView.setLayoutParams(params);
    super.onConfigurationChanged(newConfig);
}
</code></pre></li>
<li><p>自定义videoView，实现根据视频宽高等比缩放</p>
<pre><code>public void setMeasure(int width, int height) {
    this.width = width;  
    this.height = height;    
} 

protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec){        
    super.onMeasure(widthMeasureSpec, heightMeasureSpec); 
    // 默认高度，为了自动获取到focus
    int width = MeasureSpec.getSize(widthMeasureSpec);   
    int height = width;
    // 这个之前是默认的拉伸图像      
      if (this.width &gt; 0 &amp;&amp; this.height &gt; 0){          
          width = this.width;          
          height = this.height;      
      }     
       setMeasuredDimension(width, height);   
}  
</code></pre></li>
<li><p>改变videoView大小的方法不是太清楚。</p>
<pre><code>//方法一
videoView.setMeasure(params.width, params.height);
videoView.getHolder().setFixedSize(params.width, params.height);
videoView.requestLayout();

//方法二
videoView.setLayoutParams(params);
</code></pre></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/03/直播/视频/跨平台视频编码参数推荐/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/03/直播/视频/跨平台视频编码参数推荐/" itemprop="url">跨平台视频编码参数推荐</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-03T14:52:14+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/直播/" itemprop="url" rel="index">
                    <span itemprop="name">直播</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.joyinpower.com/blog/?p=142" target="_blank" rel="noopener">清晰、小容量、跨平台视频 编码参数 推荐</a></p>
<p>假定优酷的“高清”视频的清晰度是做了详尽的用户调研的结果</p>
<p>根据开发指南提供的数据，Android和iOS同时支持并推荐使用的视频格式为 H.264 Baseline Profile。</p>
<p>Android的开发指南，提供了SD Low、SD High、HD 720p三种推荐参数</p>
<p>用QQ播放器中的转码功能，将源视频进行了转码，并在smartisan T1手机上进行了测试，结果如下：</p>
<p>源视频格式为wmv，10分55秒，495M</p>
<p>HD：265M<br>SD High Quality：63.2M<br>SD Low Quality：15.9M  太模糊</p>
<p>优酷上面，同样是10分50秒的视频，“高清”的版本只有42M</p>
<p>分析了一下优酷的视频</p>
<p>我们最终选择的是：H.264 Baseline Profile格式，码率384k，帧率15fps，分辨率480×272(16:9)，音频码率32k。这样10分钟的视频大概在35M左右。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/03/直播/音频/Android声音采集降噪增益回声消除/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/03/直播/音频/Android声音采集降噪增益回声消除/" itemprop="url">Android声音采集降噪增益回声消除</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-03T14:52:14+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/直播/" itemprop="url" rel="index">
                    <span itemprop="name">直播</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.jianshu.com/p/2cb75a71009f" target="_blank" rel="noopener">Android手机直播（三）声音采集</a></p>
<p><a href="https://github.com/LaiFeng-Android/SopCastComponent" target="_blank" rel="noopener">项目github</a></p>
<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="麦克风降噪"><a href="#麦克风降噪" class="headerlink" title="麦克风降噪"></a>麦克风降噪</h2><p><img src="http://upload-images.jianshu.io/upload_images/924057-0c83cc87d86f846f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>底部的麦是用来提供清晰通话，而顶部的麦是用来消除噪音</p>
<p>两个麦克风所拾取的背景噪声音量是基本相同的，而记录的人声会有6dB左右的音量差。顶端麦收集噪声后，通过解码生成补偿信号后就可以用来消除噪音了</p>
<h2 id="回声消除"><a href="#回声消除" class="headerlink" title="回声消除"></a>回声消除</h2><p>回声消除就是在麦克风录制外音的时候去除掉手机自身播放出来的声音，这样就将对方的声音从采集的声音中过滤出去，从而就避免了回声的产生<br><img src="http://upload-images.jianshu.io/upload_images/924057-395c4cb4f1deb4ff.png?imageMogr2/auto-orient/strip" alt=""></p>
<h1 id="二、声音采集"><a href="#二、声音采集" class="headerlink" title="二、声音采集"></a>二、声音采集</h1><p>想要将声音用计算机语言表述，则必须将声音进行数字化。</p>
<p>将声音数字化，最常见的方式是通过脉冲编码调制PCM(Pulse Code Modulation) 。</p>
<p>抽样、量化、编码三个过程中三个参数：<strong>采样频率、采样位数和声道数</strong></p>
<h1 id="三、Android声音录制"><a href="#三、Android声音录制" class="headerlink" title="三、Android声音录制"></a>三、Android声音录制</h1><h2 id="音频源"><a href="#音频源" class="headerlink" title="音频源"></a>音频源</h2><pre><code>/** 默认声音 **/
public static final int DEFAULT = 0;

/** 麦克风声音 */
public static final int MIC = 1;

/** 通话上行声音 */
public static final int VOICE_UPLINK = 2;

/** 通话下行声音 */
public static final int VOICE_DOWNLINK = 3;

/** 通话上下行声音 */
public static final int VOICE_CALL = 4;

/** 根据摄像头转向选择麦克风*/
public static final int CAMCORDER = 5;

/** 对麦克风声音进行声音识别，然后进行录制 */
public static final int VOICE_RECOGNITION = 6;

/** 对麦克风中类似ip通话的交流声音进行识别，默认会开启回声消除和自动增益 */
public static final int VOICE_COMMUNICATION = 7;

/** 录制系统内置声音 */
public static final int REMOTE_SUBMIX = 8;
</code></pre><h2 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h2><p>几种常见的采样率：</p>
<pre><code>8000, 11025, 16000, 22050, 44100, 48000
</code></pre><p>Android官方文档要求所有的手机需要对44100Hz的采样率进行支持，可是国内极其少数的手机依然不支持44100Hz的采样率</p>
<p>在设置采样率之前需要对手机对设置的采样率是否支持进行<strong>检测</strong></p>
<pre><code>for (int rate : new int[] {8000, 11025, 16000, 22050, 44100}) {  // add the rates you wish to check against
    int bufferSize = AudioRecord.getMinBufferSize(rate, AudioFormat.CHANNEL_CONFIGURATION_DEFAULT, AudioFormat.ENCODING_PCM_16BIT);
    if (bufferSize &gt; 0) {
        // buffer size is valid, Sample rate supported
    }
}
</code></pre><h2 id="采样位数"><a href="#采样位数" class="headerlink" title="采样位数"></a>采样位数</h2><p><strong>ENCODING_PCM_16BIT</strong> 可以保证兼容所有Android手机。</p>
<h2 id="声道"><a href="#声道" class="headerlink" title="声道"></a>声道</h2><p><strong>AudioFormat.CHANNEL_CONFIGURATION_MONO（单声道）</strong> 可以保证兼容所有Android手机。</p>
<h1 id="四、Android回声消除"><a href="#四、Android回声消除" class="headerlink" title="四、Android回声消除"></a>四、Android回声消除</h1><p>三种方式进行处理：</p>
<ol>
<li><p>通过<strong>VOICE_COMMUNICATION</strong>模式进行录音，自动实现回声消除；<strong>效果最好，兼容性也较好</strong></p>
<ul>
<li>将AudioManager设置模式为MODE_IN_COMMUNICATION</li>
<li><p>将麦克风打开。</p>
<pre><code>AudioManager audioManager = (AudioManager)mContext.getSystemService(Context.AUDIO_SERVICE);
audioManager.setMode(AudioManager.MODE_IN_COMMUNICATION);
audioManager.setSpeakerphoneOn(true);
</code></pre></li>
<li><p>音频采样率必须设置8000或者16000</p>
</li>
<li>通道数必须设为1个</li>
</ul>
</li>
<li><p>利用Android自身带的<strong>AcousticEchoCanceler</strong>进行回声消除处理；<strong>很少手机支持</strong></p>
<ul>
<li>录制声音的时候可以通过AudioRecord得到AudioSessionId，</li>
<li>创建AudioTrack的时候也可以传入一个AudioSessionId，</li>
<li>将这个统一的AudioSessionId传入AcousticEchoCanceler，AcousticEchoCanceler进行回声消除</li>
</ul>
</li>
<li><p>使用第<strong>三方库</strong>（Speex、Webrtc）进行回声消除处理；<strong>理论上兼容性最好，但是设置合适的延时间隔很难</strong></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/03/直播/音频/Media Playback/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/03/直播/音频/Media Playback/" itemprop="url">Media Playback</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-03T14:52:14+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/直播/" itemprop="url" rel="index">
                    <span itemprop="name">直播</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Handling-audio-focus"><a href="#Handling-audio-focus" class="headerlink" title="Handling audio focus"></a>Handling audio focus</h1><p>android 2.2(API 8) 开始引入 <code>audio focus</code>协作机制 来管理音频播放</p>
<h2 id="audio-focus协作机制"><a href="#audio-focus协作机制" class="headerlink" title="audio focus协作机制"></a><code>audio focus</code>协作机制</h2><ul>
<li>获得焦点，播放</li>
<li>失去焦点，停止/暂停播放</li>
<li>仅是建议协作，以获得更好用户体验；但非强制，有的APP可能不遵守</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>public int AudioManager.requestAudioFocus(OnAudioFocusChangeListener listener, int streamType, int durationHint)

public interface OnAudioFocusChangeListener {
    public void onAudioFocusChange(int focusChange);
}
</code></pre><p><strong>the type of focus change</strong>, one of </p>
<ul>
<li>AUDIOFOCUS_GAIN  </li>
<li>AUDIOFOCUS_LOSS</li>
<li>AUDIOFOCUS_LOSS_TRANSIENT   短暂丢失</li>
<li>AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK  短暂丢失，你可以不停止播放，而是降低音量就可以</li>
</ul>
<h1 id="Handle-Changes-in-the-Audio-Output-Hardware"><a href="#Handle-Changes-in-the-Audio-Output-Hardware" class="headerlink" title="Handle Changes in the Audio Output Hardware"></a>Handle Changes in the Audio Output Hardware</h1><h1 id="Handling-the-AUDIO-BECOMING-NOISY-Intent"><a href="#Handling-the-AUDIO-BECOMING-NOISY-Intent" class="headerlink" title="Handling the AUDIO_BECOMING_NOISY Intent"></a>Handling the AUDIO_BECOMING_NOISY Intent</h1><p>当蓝牙断开或耳机拔出，系统会自动使用扬声器播放，这在某些场景会造成噪音惊喜。万幸系统会发出 <code>ACTION_AUDIO_BECOMING_NOISY</code> 广播</p>
<pre><code>private class NoisyAudioStreamReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        if (AudioManager.ACTION_AUDIO_BECOMING_NOISY.equals(intent.getAction())) {
            // Pause the playback
        }
    }
}

private IntentFilter intentFilter = new IntentFilter(AudioManager.ACTION_AUDIO_BECOMING_NOISY);

private void startPlayback() {
    registerReceiver(myNoisyAudioStreamReceiver(), intentFilter);
}

private void stopPlayback() {
    unregisterReceiver(myNoisyAudioStreamReceiver);
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/03/直播/音频/PCM音频降噪/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/03/直播/音频/PCM音频降噪/" itemprop="url">PCM音频降噪</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-03T14:52:14+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/直播/" itemprop="url" rel="index">
                    <span itemprop="name">直播</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.jianshu.com/p/77a363960711" target="_blank" rel="noopener">PCM音频处理</a></p>
<p>对于降噪前后的对比，从三个方面进行评价：<strong>时域，频域，个人听觉感受</strong>。</p>
<p>音频处理软件：<strong>Audacity</strong>（简单分析降噪效果）</p>
<h1 id="Speex音频降噪模块"><a href="#Speex音频降噪模块" class="headerlink" title="Speex音频降噪模块"></a>Speex音频降噪模块</h1><p>Speex是很强大的开源编解码库，也包含一些降噪，自动增益，回音消除等模块功能</p>
<p>Opus是Speex的更优替代方案，但是Opus没有降噪去噪模块</p>
<p>支持的采样率有3种：<strong>8K，16K，44K</strong></p>
<p>采样送进去降噪的数据需要控制在<strong>20ms</strong>，也就是（20*采样率/1000）个采样点。</p>
<p>Speex的降噪原理：设置音频数据的阀值，过滤掉低于阀值分贝的声音</p>
<ul>
<li>优点：简单，使用Speex编解码库时可以直接使用</li>
<li>缺点：会把声音细节抹掉</li>
<li>效果：<ul>
<li>时域，效果不明显</li>
<li>频域，效果不明显</li>
<li>实际听的效果，降噪后，背景的沙沙声有所减弱，但是总体效果还是不佳</li>
</ul>
</li>
</ul>
<h1 id="WebRTC音频降噪模块"><a href="#WebRTC音频降噪模块" class="headerlink" title="WebRTC音频降噪模块"></a>WebRTC音频降噪模块</h1><p>谷歌出品，必属精品</p>
<p>webrtc的音频处理模块分为降噪ns和nsx，回音消除aec，回声控制acem，音频增益agc，静音检测部分</p>
<p>支持三种采样率，<strong>8K，16K和32K</strong>，如果超过32K，则需要重采样成符合要求的采样率</p>
<p>采样送进去降噪的数据需要控制在<strong>10ms</strong>，也就是（10*采样率/1000）个采样点。</p>
<pre><code>根据前辈的说法
    32K数据需要使用滤波函数将音频数据分为高频和低频两个部分进行降噪，降噪后再合并为降噪后数据
    8K和16K数据，不需要分为高频低频这个步骤，作为低频数据输入，输出也是通过低频数据返回
</code></pre><ul>
<li>效果：<ul>
<li>时域，音量较低的数据基本被抹平，但是不影响波形清晰</li>
<li>频域，频率峰值明显加强，1500Hz到3500Hz区域，能量普遍下降</li>
<li>实际听的效果的，降噪后，背景的沙沙声基本没有，但是音量也有所下降，直观感觉上比Speex好一些</li>
</ul>
</li>
</ul>
<h1 id="根据PCM文件的音量进行阀值限制"><a href="#根据PCM文件的音量进行阀值限制" class="headerlink" title="根据PCM文件的音量进行阀值限制"></a>根据PCM文件的音量进行阀值限制</h1><p>以二进制方式打开，PCM数据其实就是音量数据</p>
<p>如果把音量小的声音默认为噪声，则可以通过把音量小的数值替换为0，来实现降噪。但是这个方法的缺点也是明显的，会把很多的比较小的细节声音直接去掉了。</p>
<p><strong>音量计算公式dB = 20×log(data)</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/03/直播/音频/android录音和播放/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/03/直播/音频/android录音和播放/" itemprop="url">android录音和播放</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-03T14:52:14+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/直播/" itemprop="url" rel="index">
                    <span itemprop="name">直播</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="录音"><a href="#录音" class="headerlink" title="录音"></a>录音</h1><p> 必须在AndroidManifest中设置相应的权限：android:name=”android.permission.RECORD_AUDIO” </p>
<p> Android提供了两个API用于实现录音功能</p>
<h2 id="AudioRecord"><a href="#AudioRecord" class="headerlink" title="AudioRecord"></a>AudioRecord</h2><pre><code>主要是实现边录边播（AudioRecord+AudioTrack）以及对音频的实时处理（如会说话的汤姆猫、语音）
优点：语音的实时处理，可以用代码实现各种音频的封装
缺点：输出是PCM语音数据，如果保存成音频文件，是不能够被播放器播放的，所以必须先写代码实现数据编码以及压缩
示例：使用AudioRecord类录音，并实现WAV格式封装。录音20s，输出的音频文件大概为3.5M左右（已写测试代码）
    主要api：audioRecord.startRecording()，audioRecord.read，audioRecord.stop()，audioRecord.release()
    开始录制
    int sampleRateInHz= 44100;  //44.1KHz,普遍使用的频率   
    int channelConfig = AudioFormat.CHANNEL_IN_STEREO;
    int audioFormat = AudioFormat.ENCODING_PCM_16BIT;
     // 获得缓冲区字节大小  
    int bufferSizeInBytes = AudioRecord.getMinBufferSize(sampleRateInHz, channelConfig, audioFormat);
    int audioSource = MediaRecorder.AudioSource.MIC;
    // 创建AudioRecord对象  
    audioRecord = new AudioRecord(audioSource, sampleRateInHz, channelConfig, audioFormat, bufferSizeInBytes);
    audioRecord.startRecording();
    // 开启线程将音频流写入文件  
    new Thread(new AudioRecordThread()).start();  

    class AudioRecordThread implements Runnable {  
        @Override 
        public void run() {  
            writeDateTOFile();//往文件中写入裸数据  
            copyWaveFile(AudioName, NewAudioName);//给裸数据加上头文件  
        }  
    } 
    private void writeDateTOFile() {  
        // new一个byte数组用来存一些字节数据，大小为前面获得的缓冲区大小  
        byte[] audiodata = new byte[bufferSizeInBytes];  
        FileOutputStream fos = null;  
        int readsize = 0;  
        try {  
            File file = new File(AudioName);  //AudioName为sd卡根目录下test.raw
            if (file.exists()) {  
                file.delete();  
            }  
            fos = new FileOutputStream(file);// 建立一个可存取字节的文件  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
        while (isRecord == true) {  
            readsize = audioRecord.read(audiodata, 0, bufferSizeInBytes);  
            if (AudioRecord.ERROR_INVALID_OPERATION != readsize &amp;&amp; fos != null) {  
                try {  
                    fos.write(audiodata);  
                } catch (IOException e) {  
                    e.printStackTrace();  
                }  
            }  
        }  
        try {
            if(fos != null)
                fos.close();// 关闭写入流  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    } 
    private void copyWaveFile(String inFilename, String outFilename) {  
        FileInputStream in = null;  
        FileOutputStream out = null;  
        long totalAudioLen = 0;  
        long totalDataLen = totalAudioLen + 36;  //wave头44字节，36实在不懂
        long longSampleRate = sampleRateInHz;  //上面的44100
        int channels = 2;  
        long byteRate = 16 * sampleRateInHz * channels / 8;  
        byte[] data = new byte[bufferSizeInBytes];  
        try {  
            in = new FileInputStream(inFilename);  
            out = new FileOutputStream(outFilename);  
            totalAudioLen = in.getChannel().size();  
            totalDataLen = totalAudioLen + 36;  
            WriteWaveFileHeader(out, totalAudioLen, totalDataLen,  
                    longSampleRate, channels, byteRate);  
            while (in.read(data) != -1) {  
                out.write(data);  
            }  
            in.close();  
            out.close();  
        } catch (FileNotFoundException e) {  
            e.printStackTrace();  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
    private void WriteWaveFileHeader(FileOutputStream out, long totalAudioLen,  
        long totalDataLen, long longSampleRate, int channels, long byteRate)  
        throws IOException {  
        byte[] header = new byte[44];  //wave文件头44字节
        header[0] = &apos;R&apos;; // RIFF/WAVE header  
        header[1] = &apos;I&apos;;  
        header[2] = &apos;F&apos;;  
        header[3] = &apos;F&apos;;  
        header[4] = (byte) (totalDataLen &amp; 0xff);  
        header[5] = (byte) ((totalDataLen &gt;&gt; 8) &amp; 0xff);  
        header[6] = (byte) ((totalDataLen &gt;&gt; 16) &amp; 0xff);  
        header[7] = (byte) ((totalDataLen &gt;&gt; 24) &amp; 0xff);  
        header[8] = &apos;W&apos;;  
        header[9] = &apos;A&apos;;  
        header[10] = &apos;V&apos;;  
        header[11] = &apos;E&apos;;  
        header[12] = &apos;f&apos;; // &apos;fmt &apos; chunk  
        header[13] = &apos;m&apos;;  
        header[14] = &apos;t&apos;;  
        header[15] = &apos; &apos;;  
        header[16] = 16; // 4 bytes: size of &apos;fmt &apos; chunk  
        header[17] = 0;  
        header[18] = 0;  
        header[19] = 0;  
        header[20] = 1; // format = 1  
        header[21] = 0;  
        header[22] = (byte) channels;  
        header[23] = 0;  
        header[24] = (byte) (longSampleRate &amp; 0xff);  
        header[25] = (byte) ((longSampleRate &gt;&gt; 8) &amp; 0xff);  
        header[26] = (byte) ((longSampleRate &gt;&gt; 16) &amp; 0xff);  
        header[27] = (byte) ((longSampleRate &gt;&gt; 24) &amp; 0xff);  
        header[28] = (byte) (byteRate &amp; 0xff);  
        header[29] = (byte) ((byteRate &gt;&gt; 8) &amp; 0xff);  
        header[30] = (byte) ((byteRate &gt;&gt; 16) &amp; 0xff);  
        header[31] = (byte) ((byteRate &gt;&gt; 24) &amp; 0xff);  
        header[32] = (byte) (2 * 16 / 8); // block align  
        header[33] = 0;  
        header[34] = 16; // bits per sample  
        header[35] = 0;  
        header[36] = &apos;d&apos;;  
        header[37] = &apos;a&apos;;  
        header[38] = &apos;t&apos;;  
        header[39] = &apos;a&apos;;  
        header[40] = (byte) (totalAudioLen &amp; 0xff);  
        header[41] = (byte) ((totalAudioLen &gt;&gt; 8) &amp; 0xff);  
        header[42] = (byte) ((totalAudioLen &gt;&gt; 16) &amp; 0xff);  
        header[43] = (byte) ((totalAudioLen &gt;&gt; 24) &amp; 0xff);  
        out.write(header, 0, 44);  
    } 
    停止录制
    audioRecord.stop();  
    audioRecord.release();//释放资源  
    audioRecord = null;  
</code></pre><h2 id="MediaRecorder"><a href="#MediaRecorder" class="headerlink" title="MediaRecorder"></a>MediaRecorder</h2><pre><code>已经集成了录音、录像、编码、压缩等，支持少量的录音音频格式，大概有.aac（API = 16以上） .amr .3gp
优点：大部分已经集成，直接调用相关接口即可，代码量小
缺点：无法实时处理音频；输出的音频格式不是很多，例如没有输出mp3格式文件
示例：使用MediaRecorder类录音，输出amr格式文件。录音20s，输出的音频文件大概为33K（已写测试代码）
    开始录制
    mRecorder = new MediaRecorder();
    mRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);
    mRecorder.setOutputFormat(MediaRecorder.OutputFormat.DEFAULT);//Android默认就是amr
    mRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.DEFAULT);
    mRecorder.setOutputFile(outputFilePath);
    try {
        mRecorder.prepare();
    } catch (Exception e) {
        e.printStackTrace();
    } 
    mRecorder.start();
    停止录制
    mRecorder.stop();
    mRecorder.release();
    mRecorder = null;

    开始播放
    mPlayer = new MediaPlayer();
    try {
        mPlayer.setDataSource(fileName);
        mPlayer.prepare();
        mPlayer.start();
    } catch (IOException e) {
        e.printStackTrace();
    }
    停止播放
    mPlayer.stop();
    mPlayer.release();
    mPlayer = null;
</code></pre><h1 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h1><h2 id="MediaPlayer音频视频播放"><a href="#MediaPlayer音频视频播放" class="headerlink" title="MediaPlayer音频视频播放"></a>MediaPlayer音频视频播放</h2><p>MediaPlayer支持：AAC、AMR、FLAC、MP3、MIDI、OGG、PCM、WAV等格式 </p>
<p>资源占用量较高、延迟时间较长、不支持多个音频同时播放等</p>
<h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><pre><code>public void startPlay(String fileName) {
    mPlayer = new MediaPlayer();
    try {
        mPlayer.setDataSource(fileName);
        mPlayer.prepare();
        mPlayer.start();
    } catch (IOException e) {
        e.printStackTrace();
    }
}

public void stopPlay() {
    mPlayer.stop();
    mPlayer.release();
    mPlayer = null;
}
</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>MediaPlayer 的使用介绍（翻译官方文档，详细） http://blog.csdn.net/songshizhuyuan/article/details/32900965
</code></pre><h4 id="MediaPlayer"><a href="#MediaPlayer" class="headerlink" title="MediaPlayer"></a>MediaPlayer</h4><pre><code>这个类包含用于播放声音和视频的主要API
</code></pre><p>Raw下的元数据</p>
<pre><code>//直接创建，不需要设置setDataSource
mMediaPlayer=MediaPlayer.create(this, R.raw.audio);
mMediaPlayer.start();
</code></pre><h4 id="AudioManager"><a href="#AudioManager" class="headerlink" title="AudioManager"></a>AudioManager</h4><pre><code>这个类用于管理音源，并在设备上的音频输出。
</code></pre><h4 id="处理音频焦点"><a href="#处理音频焦点" class="headerlink" title="处理音频焦点"></a>处理音频焦点</h4><p>音频焦点是合作性。也就是说，应用程序应该尽量配合，以符合音频焦点的指引，但规则不是由系统执行。如果应用程序失去音讯焦点后，大声播放音乐，系统也不会阻止。</p>
<pre><code>http://blog.csdn.net/dadoneo/article/details/8252933
</code></pre><p>AudioFocus的申请与释放</p>
<p>安卓2.2(api8)开始 新增 <code>AudioManager.requestAudioFocus（）</code></p>
<p>AudioFocus被抢占与重新获得</p>
<pre><code>http://www.android100.org/html/201510/08/188724.html
</code></pre><h4 id="外放、听筒、耳机-模式切换"><a href="#外放、听筒、耳机-模式切换" class="headerlink" title="外放、听筒、耳机 模式切换"></a>外放、听筒、耳机 模式切换</h4><pre><code>AudioManager audioManager = (AudioManager) this.getSystemService(Context.AUDIO_SERVICE);
audioManager.setMicrophoneMute(false);
audioManager.setSpeakerphoneOn(true);//使用扬声器外放，即使已经插入耳机
audioManager.setMode(AudioManager.STREAM_MUSIC);
</code></pre><h2 id="SoundPool"><a href="#SoundPool" class="headerlink" title="SoundPool"></a>SoundPool</h2><p>支持多个音频文件同时播放(组合音频也是有上限的)，延时短，比较适合短促、密集的场景，是游戏开发中音效播放的福音。</p>
<p><code>SoundPool(int maxStreams, int streamType, int srcQuality)</code></p>
<p>区分2个概念</p>
<ol>
<li>soundID：加载音乐资源时的返回值，int load(String path, int priority),这个int返回值就是soundID </li>
<li>streamID：播放时返回的值，即play()方法的返回值</li>
</ol>
<p>这两个值都很重要，需要缓存下来</p>
<p>某些采样频率会导致播放错误(不能播放，只能播放部分)</p>
<h2 id="AsyncPlayer"><a href="#AsyncPlayer" class="headerlink" title="AsyncPlayer"></a>AsyncPlayer</h2><p>AsyncPlayer就是对MediaPlayer的一次简单的封装，对MediaPlaer所有的操作都在新开线程中执行。不影响调用线程任何操作。</p>
<p>AsyncPlayer只适合简单的异步播放，不能控制进度，只能开始或停止播放。如果再次调用play()方法，AsyncPlayer会停止当前播放，开始新的播放。</p>
<h2 id="AudioTrack播放音频"><a href="#AudioTrack播放音频" class="headerlink" title="AudioTrack播放音频"></a>AudioTrack播放音频</h2><p>AudioTrack属于更偏底层的音频播放，MediaPlayerService的内部就是使用了AudioTrack。</p>
<p>AudioTrack用于单个音频播放和管理，相比于MediaPlayer具有：精炼、高效的优点。</p>
<p>更适合实时产生播放数据的情况，如加密的音频，<br>MediaPlayer是束手无策的，AudioTrack却可以。</p>
<p>AudioTrack用于播放PCM(PCM无压缩的音频格式)音乐流的回放，<br>如果需要播放其它格式音频，需要响应的解码器，<br>这也是AudioTrack用的比较少的原因，需要自己解码音频。</p>
<h3 id="AudioTreack的2种播放模式"><a href="#AudioTreack的2种播放模式" class="headerlink" title="AudioTreack的2种播放模式"></a>AudioTreack的2种播放模式</h3><h4 id="静态模式—static"><a href="#静态模式—static" class="headerlink" title="静态模式—static"></a>静态模式—static</h4><p>数据一次性交付给接收方。好处是简单高效，只需要进行一次操作就完成了数据的传递;缺点当然也很明显，对于数据量较大的音频回放，显然它是无法胜任的，因而通常只用于播放铃声、系统提醒等对内存小的操作</p>
<h4 id="流模式streaming"><a href="#流模式streaming" class="headerlink" title="流模式streaming"></a>流模式streaming</h4><p>流模式和网络上播放视频是类似的，即数据是按照一定规律不断地传递给接收方的。理论上它可用于任何音频播放的场景，不过我们一般在以下情况下采用：</p>
<ul>
<li><p>音频文件过大</p>
</li>
<li><p>音频属性要求高，比如采样率高、深度大的数据</p>
</li>
<li><p>音频数据是实时产生的，这种情况就只能用流模式了</p>
</li>
</ul>
<p>通过write(byte[], int, int), write(short[], int, int)<br>write(float[], int, int, int)等方法推送解码数据到AudioTrack</p>
<h2 id="Ringtone和RingtoneManager"><a href="#Ringtone和RingtoneManager" class="headerlink" title="Ringtone和RingtoneManager"></a>Ringtone和RingtoneManager</h2><p>Ringtone为铃声、通知和其他类似声音提供快速播放的方法</p>
<p>RingtoneManager提供系统铃声列表检索方法，Ringtone实例需要从RingtoneManager获取</p>
<h3 id="RingtoneManager"><a href="#RingtoneManager" class="headerlink" title="RingtoneManager"></a>RingtoneManager</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="comment">// 两个构造方法</span></span><br><span class="line">RingtoneManager(Activity activity)</span><br><span class="line">RingtoneManager(Context context)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. <span class="comment">// 获取指定声音类型(铃声、通知、闹铃等)的默认声音的Uri</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Uri <span class="title">getDefaultUri</span><span class="params">(<span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">3. <span class="comment">// 获取系统所有Ringtone的cursor</span></span></span><br><span class="line"><span class="function">Cursor <span class="title">getCursor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">4. <span class="comment">// 获取cursor指定位置的Ringtone uri</span></span></span><br><span class="line"><span class="function">Uri <span class="title">getRingtoneUri</span><span class="params">(<span class="keyword">int</span> position)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">5. <span class="comment">// 判断指定Uri是否为默认铃声</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDefault</span><span class="params">(Uri ringtoneUri)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">6. <span class="comment">//获取指定uri的所属类型</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultType</span><span class="params">(Uri defaultRingtoneUri)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">7. <span class="comment">//将指定Uri设置为指定声音类型的默认声音</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setActualDefaultRingtoneUri</span><span class="params">(Context context, <span class="keyword">int</span> type, Uri ringtoneUri)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="JetPlayer播放音频"><a href="#JetPlayer播放音频" class="headerlink" title="JetPlayer播放音频"></a>JetPlayer播放音频</h2><p>用于播放 ”.jet”文件</p>
<p>JET常用于控制游戏的声音特效，采用MIDI（Musical Instrument Digital Interface）格式。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>对于延迟度要求不高，并且希望能够更全面的控制音乐的播放，MediaPlayer比较适合

声音短小，延迟度小，并且需要几种声音同时播放的场景，适合使用SoundPool

对于简单的播放，不需要复杂控制的播放，可以给使用AsyncPlayer，所有操作均在子线程不阻塞UI

播放大文件音乐，如WAV无损音频和PCM无压缩音频，可使用更底层的播放方式AudioTrack。它支持流式播放，可以读取(可来自本地和网络)音频流，却播放延迟较小。 
ps：据我测试AudioTrack直接支持WAV和PCM，其他音频需要解码成PCM格式才能播放。(其他无损格式没有尝试，有兴趣可以使本文提供的例子测试一下)

.jet的音频比较少见(有的游戏中在使用)，可使用专门的播放器JetPlayer播放

对于系统类声音的播放和操作，Ringtone更适合(RingtoneManager)
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/03/直播/音频/pcm 转 amr/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/03/直播/音频/pcm 转 amr/" itemprop="url">pcm 转 amr</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-03T14:52:14+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/直播/" itemprop="url" rel="index">
                    <span itemprop="name">直播</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.csdn.net/honeybaby201314/article/details/50379040" target="_blank" rel="noopener">pcm 转 amr</a></p>
<p><a href="https://www.zybuluo.com/DevWiki/note/115307" target="_blank" rel="noopener">Android中Pcm文件转Amr文件</a></p>
<p>Android系统自带的AmrInputStream类可以转换pcm到amr</p>
<h1 id="思路一、反射调用"><a href="#思路一、反射调用" class="headerlink" title="思路一、反射调用"></a>思路一、反射调用</h1><ul>
<li>通过Android系统自带的AmrInputStream类转换，因为它被隐藏了，只有通过反射来操作。</li>
<li>手动加上 <code>amr文件头</code>，<code>byte[] header = new byte[]{0x23, 0x21, 0x41, 0x4D, 0x52, 0x0A};</code></li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code> /**
 * 通过反射调用android系统自身AmrInputStream类进行转换
 * @param inPath 源文件
 * @param outPath 目标文件
 */
public void systemPcm2Amr(String inPath,String outPath){
    try {
        FileInputStream fileInputStream = new FileInputStream(inPath);
        FileOutputStream fileoutputStream = new FileOutputStream(outPath);
        // 获得Class
        Class&lt;?&gt; cls = Class.forName(&quot;android.media.AmrInputStream&quot;);
        // 通过Class获得所对应对象的方法
        Method[] methods = cls.getMethods();
        // 输出每个方法名
        byte[] header = new byte[]{0x23, 0x21, 0x41, 0x4D, 0x52, 0x0A};
        fileoutputStream.write(header);
        Constructor&lt;?&gt; con = cls.getConstructor(InputStream.class);
        Object obj = con.newInstance(fileInputStream);
        for (Method method : methods) {
            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();
            if (&quot;read&quot;.equals(method.getName())
                    &amp;&amp; parameterTypes.length == 3) {
                byte[] buf = new byte[1024];
                int len = 0;
                while ((len = (int) method.invoke(obj, buf, 0, 1024)) &gt; 0) {
                    fileoutputStream.write(buf, 0, len);
                }
                break;
            }
        }
        for (Method method : methods) {
            if (&quot;close&quot;.equals(method.getName())) {
                method.invoke(obj);
                break;
            }
        }
        fileoutputStream.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>查看源码可知，AmrInputStream 转码默认 PCM 的采样率是 8000 Hz，所以要<strong>保证录制时采样率是8000Hz</strong>，否则amr音频会有快放和慢放的效果</p>
<pre><code>public class AmrInputStream extends InputStream {      
    ... 
    // frame is 20 msec at 8.000 khz  
    private final static int SAMPLES_PER_FRAME = 8000 * 20 / 1000;  
</code></pre><p>在华为机型上，反射调用特别的慢，容易AR</p>
<h1 id="思路二、复制类文件到工程"><a href="#思路二、复制类文件到工程" class="headerlink" title="思路二、复制类文件到工程"></a>思路二、复制类文件到工程</h1><p>不用反射，更加高效</p>
<p>工程下新建包 <code>android.media</code>。因为调用Android自带的Pcm转amr的库:media_jni.so需要这个包名</p>
<p>复制AmrInputStream类到该包下</p>
<pre><code>public final class AmrInputStream extends InputStream {
    static {
        System.loadLibrary(&quot;media_jni&quot;);
    }
    private final static String TAG = &quot;AmrInputStream&quot;;
    // frame is 20 msec at 8.000 khz
    private final static int SAMPLES_PER_FRAME = 8000 * 20 / 1000;
    // pcm input stream
    private InputStream mInputStream;
    // native handle
    private int mGae;
    // result amr stream
    private byte[] mBuf = new byte[SAMPLES_PER_FRAME * 2];
    private int mBufIn = 0;
    private int mBufOut = 0;
    // helper for bytewise read()
    private byte[] mOneByte = new byte[1];
    /**
     * Create a new AmrInputStream, which converts 16 bit PCM to AMR
     * @param inputStream InputStream containing 16 bit PCM.
     */
    public AmrInputStream(InputStream inputStream) {
        mInputStream = inputStream;
        mGae = GsmAmrEncoderNew();
        GsmAmrEncoderInitialize(mGae);
    }
    @Override
    public int read() throws IOException {
        int rtn = read(mOneByte, 0, 1);
        return rtn == 1 ? (0xff &amp; mOneByte[0]) : -1;
    }
    @Override
    public int read(byte[] b) throws IOException {
        return read(b, 0, b.length);
    }
    @Override
    public int read(byte[] b, int offset, int length) throws IOException {
        if (mGae == 0) throw new IllegalStateException(&quot;not open&quot;);
        // local buffer of amr encoded audio empty
        if (mBufOut &gt;= mBufIn) {
            // reset the buffer
            mBufOut = 0;
            mBufIn = 0;
            // fetch a 20 msec frame of pcm
            for (int i = 0; i &lt; SAMPLES_PER_FRAME * 2; ) {
                int n = mInputStream.read(mBuf, i, SAMPLES_PER_FRAME * 2 - i);
                if (n == -1) return -1;
                i += n;
            }
            // encode it
            mBufIn = GsmAmrEncoderEncode(mGae, mBuf, 0, mBuf, 0);
        }
        // return encoded audio to user
        if (length &gt; mBufIn - mBufOut) length = mBufIn - mBufOut;
        System.arraycopy(mBuf, mBufOut, b, offset, length);
        mBufOut += length;
        return length;
    }
    @Override
    public void close() throws IOException {
        try {
            if (mInputStream != null) mInputStream.close();
        } finally {
            mInputStream = null;
            try {
                if (mGae != 0) GsmAmrEncoderCleanup(mGae);
            } finally {
                try {
                    if (mGae != 0) GsmAmrEncoderDelete(mGae);
                } finally {
                    mGae = 0;
                }
            }
        }
   }
    @Override
    protected void finalize() throws Throwable {
        if (mGae != 0) {
            close();
            throw new IllegalStateException(&quot;someone forgot to close AmrInputStream&quot;);
        }
    }
    //
    // AudioRecord JNI interface
    //
    private static native int GsmAmrEncoderNew();
    private static native void GsmAmrEncoderInitialize(int gae);
    private static native int GsmAmrEncoderEncode(int gae,
           byte[] pcm, int pcmOffset, byte[] amr, int amrOffset) throws IOException;
    private static native void GsmAmrEncoderCleanup(int gae);
    private static native void GsmAmrEncoderDelete(int gae);
}
</code></pre><p>复制AmrEncoder类</p>
<pre><code>public class AmrEncoder {
    public static void pcm2Amr(String pcmPath , String amrPath) {
        FileInputStream fis;
        try {
            fis = new FileInputStream(pcmPath);
            pcm2Amr(fis, amrPath);
            fis.close();
        } catch (FileNotFoundException e1) {
            e1.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    public static void pcm2Amr(InputStream pcmStream, String amrPath) {
        try {
            AmrInputStream ais = new AmrInputStream(pcmStream);
            OutputStream out = new FileOutputStream(amrPath);
            byte[] buf = new byte[4096];
            int len = -1;
            /*
             * 下面的AMR的文件头,缺少这几个字节是不行的
             */
            out.write(0x23);
            out.write(0x21);
            out.write(0x41);
            out.write(0x4D);
            out.write(0x52);
            out.write(0x0A);   
            while((len = ais.read(buf)) &gt;0){
                out.write(buf,0,len);
            }
            out.close();
            ais.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }       
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/03/直播/音频/学乎录音实现方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/03/直播/音频/学乎录音实现方式/" itemprop="url">学乎录音实现方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-03T14:52:14+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/直播/" itemprop="url" rel="index">
                    <span itemprop="name">直播</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>学乎录音实现</p>
<h1 id="学乎录音实现方式探索历程"><a href="#学乎录音实现方式探索历程" class="headerlink" title="学乎录音实现方式探索历程"></a>学乎录音实现方式探索历程</h1><p>尝试过 MedicaRecord,AudioRecord录音，lame库编码为MP3(<a href="https://github.com/liyungui/MP3LameRecord" target="_blank" rel="noopener">MP3LameRecord</a>)，webrtc降噪(<a href="https://github.com/liyungui/PCMNoiseSupression" target="_blank" rel="noopener">PCMNoiseSupression</a>)</p>
<p>经过实践测试，发现音效最好(音量大，噪音小)的实现方式是：AudioRecord录制，使用Android系统自带的pcm转arm</p>
<h2 id="关键细节"><a href="#关键细节" class="headerlink" title="关键细节"></a>关键细节</h2><pre><code>AudioManager audioManager = (AudioManager) App.getApplication().getSystemService(Context.AUDIO_SERVICE);
audioManager.setMode(AudioManager.MODE_IN_COMMUNICATION);
audioManager.setSpeakerphoneOn(true);

// 获得缓冲区字节大小
bufferSizeInBytes = AudioRecord.getMinBufferSize(AUDIO_SAMPLE_RATE,
        AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT);

// 创建AudioRecord对象
recorder = new AudioRecord(AUDIO_INPUT, AUDIO_SAMPLE_RATE,
        AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT, bufferSizeInBytes);
voiceFilePath = PathUtil.getInstance().getVoicePath() + File.separator + getPCMFileName(&quot;&quot;);
file = new File(voiceFilePath);
recorder.startRecording();
isRecording = true;// 让录制状态为true
// 开启音频文件写入线程
new Thread(new AudioRecordThread()).start();

private void writeDateTOFile(String AudioName) {
    // new一个byte数组用来存一些字节数据，大小为缓冲区大小
    byte[] audiodata = new byte[bufferSizeInBytes];
    FileOutputStream fos = null;
    int readsize = 0;
    try {
        File file = new File(AudioName);
        if (file.exists()) {
            file.delete();
        }
        fos = new FileOutputStream(file);// 建立一个可存取字节的文件

        while (isRecording) {
            readsize = recorder.read(audiodata, 0, bufferSizeInBytes);
            if (AudioRecord.ERROR_INVALID_OPERATION != readsize &amp;&amp; fos != null) {
                try {
                    fos.write(audiodata);

                    getVolumeDB(readsize, audiodata);
                } catch (Exception e) {
                    if (e != null) {
                        e.printStackTrace();
                    }
                }
            }
        }

        if (fos != null)
            fos.close();// 关闭写入流
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre><p>pcm 转 amr实现细节参考另一篇笔记。反射调用在华为机型上容易ANR，要把系统类文件复制到工程中使用，性能好</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/03/直播/音频/微信语音编码-silk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/03/直播/音频/微信语音编码-silk/" itemprop="url">微信语音编码-silk</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-03T14:52:14+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/直播/" itemprop="url" rel="index">
                    <span itemprop="name">直播</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android微信语音聊天记录及文本聊天记录-数据库破解-silk-整理"><a href="#Android微信语音聊天记录及文本聊天记录-数据库破解-silk-整理" class="headerlink" title="Android微信语音聊天记录及文本聊天记录 数据库破解 silk 整理"></a><a href="http://blog.csdn.net/voler_HJL/article/details/53788126" target="_blank" rel="noopener">Android微信语音聊天记录及文本聊天记录 数据库破解 silk 整理</a></h1><p><strong>微信语音文件存储位置</strong></p>
<pre><code>根目录 -》tencent -》MicroMsg -》名字很长又很乱的那个文件夹 -》voice2 
</code></pre><p><strong>播放</strong></p>
<p>.amr后缀，但它并不是真正的.amr文件，amr播放器是播放不了的 </p>
<p>其实是silk v3格式，QQ的语音文件也是这种格式 </p>
<h1 id="微信语音文件的格式转换"><a href="#微信语音文件的格式转换" class="headerlink" title="微信语音文件的格式转换"></a><a href="http://www.jianshu.com/p/71137d5acf78" target="_blank" rel="noopener">微信语音文件的格式转换</a></h1><p>起初，iOS 只是去掉了文件头的 amr，添上就能还原为 amr 了；Android 则是原生的 amr。</p>
<p>微信6.0 之后开始采用 silk 编码来传输语音，必须用 slik v3 解码器</p>
<p>这方面许多人做过工作，罗列一下：</p>
<h2 id="个人"><a href="#个人" class="headerlink" title="个人"></a>个人</h2><p><strong>kn007</strong>: </p>
<p><a href="https://kn007.net/topics/decoding-qq-wechat-silk-v3-encoded-audio-to-mp3-or-other-formats/" target="_blank" rel="noopener">解码转换QQ微信的SILK v3编码音频为MP3或其他格式</a></p>
<p><a href="https://kn007.net/topics/batch-convert-silk-v3-audio-files-to-mp3-in-windows/" target="_blank" rel="noopener">Windows下批量转换Silk v3音频文件为MP3格式</a></p>
<p><a href="https://kn007.net/topics/update-silk2mp3-to-official-version/" target="_blank" rel="noopener">更新了Silk2MP3</a></p>
<p><strong>snakeninny</strong>：</p>
<p><a href="http://bbs.iosre.com/t/topic/3199" target="_blank" rel="noopener">从微信中提取语音文件，并转换成文字的全自动化解决方案</a></p>
<p><strong>hangcom</strong>：《iOS应用逆向工程》的作者，之前还开发了朋友圈导出。</p>
<p><a href="https://zhuanlan.zhihu.com/p/21783890" target="_blank" rel="noopener">微信语音文件的解析</a></p>
<p><strong>杨树下的狐狸</strong>：Android 方案</p>
<p><a href="https://www.zhihu.com/question/19909162/answer/80640430" target="_blank" rel="noopener">微信的语音聊天记录可以从手机提取出来保存到PC上么？ - 知乎</a></p>
<p><strong>cxun</strong>：整体解决方案</p>
<p>（暂时失效）<a href="http://www.cnblogs.com/cxun/p/4338643.html" target="_blank" rel="noopener">微信聊天记录查看器（程序+源码）</a></p>
<h2 id="商用"><a href="#商用" class="headerlink" title="商用"></a>商用</h2><p>iTools：可以转换 aud 到 wav</p>
<p>楼月微信聊天记录导出恢复助手：同上</p>
<p>其他还有：Silk 手机音频播放器、Silk 转换工具、WeBack 等等。</p>
<h1 id="Skype-Silk-与Opus的关系"><a href="#Skype-Silk-与Opus的关系" class="headerlink" title="Skype Silk 与Opus的关系"></a><a href="http://tiger-beach.blogspot.com/2014/04/skype-silk-opus.html" target="_blank" rel="noopener">Skype Silk 与Opus的关系</a></h1><p>Skype自2009年1月以来一直采用自己的SILK音频编码解码器，但是从2012年起过渡到新的Opus标准。</p>
<p>Opus标准已经获互联网工程任务组（IETF）批准，标准格式为RFC 6716。</p>
<p>Opus支持6kbps到510kbps的可变比特率。</p>
<p>它是一个有损声音编码的格式，适用于网络上的实时声音传输。</p>
<p>由于是一个开放格式，Opus在使用上没有任何专利限制。</p>
<p>Opus合并了Xiph.org的CELT低延时音频编解码器和Skype的SILK语音编解码器，专为互联网音频设计，可用于替代现有的私有音频编解码器</p>
<p>由 Xiph.Org、Mozilla、微软、Broadcom、Octasic和Google联合开发。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/31/">31</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="风" />
            
              <p class="site-author-name" itemprop="name">风</p>
              <p class="site-description motion-element" itemprop="description">随心而动，随刃而行</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">310</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">71</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">风</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
