<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="随心而动，随刃而行">
<meta property="og:type" content="website">
<meta property="og:title" content="风">
<meta property="og:url" content="http://yoursite.com/page/12/index.html">
<meta property="og:site_name" content="风">
<meta property="og:description" content="随心而动，随刃而行">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="风">
<meta name="twitter:description" content="随心而动，随刃而行">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/12/"/>





  <title>风</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">风</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">技术博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/01/直播/直播技术/直播技术一-开篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/01/直播/直播技术/直播技术一-开篇/" itemprop="url">直播技术一-开篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-01T16:02:14+08:00">
                2019-08-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/直播/" itemprop="url" rel="index">
                    <span itemprop="name">直播</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="直播技术大纲"><a href="#直播技术大纲" class="headerlink" title="直播技术大纲"></a>直播技术大纲</h1><p>（一）采集</p>
<p>（二）处理</p>
<p>（三）编码和封装</p>
<p>（四）推流和传输</p>
<p>（五）延迟优化</p>
<p>（六）现代播放器原理</p>
<p>（七）SDK 性能测试模型</p>
<h1 id="直播流程"><a href="#直播流程" class="headerlink" title="直播流程"></a>直播流程</h1><img src="/2019/08/01/直播/直播技术/直播技术一-开篇/stream.png">
<h2 id="采集"><a href="#采集" class="headerlink" title="采集"></a>采集</h2><p>iOS 系统因为软硬件种类不多，硬件适配性较好，所以比较简单。Android 则不同，市面上硬件机型非常多，难以做到一个库适配所有硬件。PC 端的采集也跟各种摄像头驱动有关，推荐使用目前市面上最好用的 PC 端开源免费软件 OBS。</p>
<h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>视频音频处理，美颜、水印、混音等</p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>编码主要难点有两个：</p>
<ol>
<li>处理硬件兼容性问题。</li>
<li>在高 fps、低 bitrate 和音质画质之间找到平衡。</li>
</ol>
<p>iOS 端硬件兼容性较好，可以直接采用硬编。而 Android 的硬编的支持则难得多，需要支持各种硬件机型，推荐使用软编。</p>
<h2 id="推流和传输"><a href="#推流和传输" class="headerlink" title="推流和传输"></a>推流和传输</h2><p>传输涉及到很多端：主播端 – 服务端 – CDN – 观众端。</p>
<p>传统的 CDN 在新时代显得心有余力不足。实现稳定高速的推流上传需要自己做一个直播专属的实时流网络</p>
<h2 id="转码"><a href="#转码" class="headerlink" title="转码"></a>转码</h2><p>为了让主播推上来的流<strong>适配各个平台端各种不同协议</strong>，需要在服务端做一些流处理工作，比如转码成不同格式支持不同协议如 RTMP、HLS 和 FLV，一路转多路流来适配各种不同的网络状况和不同分辨率的终端设备。</p>
<p>同时，为了配合一些运营需求，比如一些监管部门的要求，需要内容识别如鉴黄的功能。</p>
<h2 id="解码和渲染"><a href="#解码和渲染" class="headerlink" title="解码和渲染"></a>解码和渲染</h2><p>解码和渲染，也即音视频的播放，目前 iOS 端的播放兼容性较好，在延迟可接受的情况下使用 HLS 协议是最好的选择。Android 的硬件解码和编码一样也存在兼容性问题，目前比较好的开源播放器是基于 ffplay 的 <strong>ijkplayer</strong></p>
<p>重点：播放器的原理，以及现代视频播放器的基本架构</p>
<h1 id="直播场景化解决方案"><a href="#直播场景化解决方案" class="headerlink" title="直播场景化解决方案"></a>直播场景化解决方案</h1><p>直播场景如社交直播和游戏直播</p>
<p>背后的技术方案不仅涉及到直播基础服务，还可能涉及到和场景相关的其它技术，如聊天、点赞和弹幕的支持</p>
<h1 id="直播云整体架构设计图"><a href="#直播云整体架构设计图" class="headerlink" title="直播云整体架构设计图"></a>直播云整体架构设计图</h1><img src="/2019/08/01/直播/直播技术/直播技术一-开篇/七牛直播云整体架构设计图.png">
<h1 id="参考-amp-扩展"><a href="#参考-amp-扩展" class="headerlink" title="参考&amp;扩展"></a>参考&amp;扩展</h1><ul>
<li><a href="https://blog.qiniu.com/archives/6606" target="_blank" rel="noopener">《视频直播技术详解》系列之一：开篇</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/31/直播/视频/视频相关基础概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/31/直播/视频/视频相关基础概念/" itemprop="url">视频相关基础概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-31T14:52:14+08:00">
                2019-07-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/视频/" itemprop="url" rel="index">
                    <span itemprop="name">视频</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h1><p>分辨率是以横向和纵向的像素数量来衡量的，表示平面图像的精细程度。</p>
<p>视频精细程度并不只取决于视频分辨率，还取决于屏幕分辨率。</p>
<p>1080P 的 <strong>P</strong> 指 <strong>Progressive scan</strong>（逐行扫描），即垂直方向像素点，也就是 “高”，所以 1920X1080 叫 1080P， 不叫 1920P。</p>
<p>当 720P 的视频在 1080P 屏幕上播放时，需要将图像放大，<strong>放大操作也叫上采样</strong>。</p>
<p>上采样几乎都是采用内插值方法，即在原有图像的像素点之间采用合适的插值算法插入新的元素，所以图像放大也称为图像插值。</p>
<p>当 1080P 的视频在 720P 屏幕上播放时，需要将图像缩小，<strong>缩小操作也叫下采样</strong>。</p>
<p>下采样的定义为：对于一个样值序列，间隔几个样值取样一次，得到新序列。</p>
<h1 id="GOP"><a href="#GOP" class="headerlink" title="GOP"></a>GOP</h1><p>Group of Pictures</p>
<p>图像组或画面组，一个GOP就是一组连续的画面</p>
<p>GOP策略影响<strong>编码质量</strong></p>
<p><strong>GOP 越长，理论上画面越高清</strong>。但是生成 HLS 直播时，最小切割粒度也是一个 GOP，所以针对交互直播，通常不建议 GOP 设置太长。直播一般 2 个关键帧间隔即可（也就是 2s）。</p>
<p>在H264中图像以GOP图像组为单位进行组织，一个GOP图像组是一段图像编码后的数据流，以I帧开始</p>
<h2 id="I、P、B-帧"><a href="#I、P、B-帧" class="headerlink" title="I、P、B 帧"></a>I、P、B 帧</h2><p>MPEG编码将画面（即帧）分为I、P、B三种。</p>
<p>帧内压缩生成I帧，帧间压缩生成B帧和P帧</p>
<ul>
<li><strong>I</strong> <strong>关键帧</strong> 是内部编码帧。压缩率是7（跟JPG差不多）</li>
<li><strong>P</strong>  <strong>参考帧</strong> 是前向预测帧。压缩率是20<ul>
<li>参考之前的I帧编码的，只包含差异部分编码（体积很小）</li>
<li>P 帧没有完整画面数据，只有与前一帧的画面差别的数据</li>
<li>解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。</li>
<li>P 帧是参考帧(后面P帧/前后的B帧的参考帧),它可能造成解码错误的扩散;</li>
</ul>
</li>
<li><strong>B</strong> 是双向预测内插帧。压缩率是50（比较耗CPU）<ul>
<li>参考前后的帧编码的，只包含差异部分编码（体积很小）</li>
<li>B 帧记录的是本帧与前后帧的差别</li>
<li>解码时需要用前后画面叠加本帧定义的差别，生成最终的画面。</li>
<li>B 帧不是参考帧,不会造成解码错误的扩散。</li>
</ul>
</li>
</ul>
<p>简单地讲，I帧是一个完整的画面，而P帧和B帧记录的是相对于I帧的变化。</p>
<p>没有I帧，P帧和B帧就无法解码，这就是MPEG格式难以精确剪辑的原因，也是我们之所以要微调头和尾的原因。</p>
<h3 id="花屏和跳跃"><a href="#花屏和跳跃" class="headerlink" title="花屏和跳跃"></a>花屏和跳跃</h3><p>丢失掉了“关键帧”，随后的几帧图像无法正常地解码，因此产生“花屏”现象。</p>
<p>从技术的角度，怎么解决“花屏”现象呢？</p>
<p>当我们在视频传输过程中，通过帧序号发现丢帧后，可以跳过随后的非“关键帧”，直到遇到下一个关键帧再送入解码。这样的确可以解决“花屏”现象，但是由于跳跃了很多帧，因此会出现视频图像的不连续情况（即“跳跃”现象）。</p>
<h2 id="IDR"><a href="#IDR" class="headerlink" title="IDR"></a>IDR</h2><p>IDR（Instantaneous Decoding Refresh）–即时解码刷新。</p>
<p>一个序列的第一个图像叫做 IDR 图像（立即刷新图像），IDR 图像都是 I 帧图像。H.264 引入 IDR 图像是为了<strong>解码的重同步</strong>，当解码器解码到 IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。</p>
<h2 id="MPEG-2-帧结构"><a href="#MPEG-2-帧结构" class="headerlink" title="MPEG-2 帧结构"></a>MPEG-2 帧结构</h2><p>MPEG-2压缩的帧结构有两个参数，</p>
<ul>
<li>GOP<ul>
<li>一般可按编码方式从1－15；</li>
<li>两个I帧之间的间隔</li>
</ul>
</li>
<li>I帧和P帧之间B帧的数量<ul>
<li>一般是1－2个。</li>
<li>多少帧里出现一次P帧</li>
</ul>
</li>
</ul>
<h1 id="比特率"><a href="#比特率" class="headerlink" title="比特率"></a>比特率</h1><p>比特率即码率，在多媒体领域，指单位时间播放音频或视频的比特数，可以理解成吞吐量或带宽。</p>
<p>单位为 bps , 即 bits per second，每秒传输的数据量</p>
<p>在一个视频中，不同时段画面的复杂程度是不同的，比如高速变化的场景和几乎静止的场景，所需的数据量也是不同的，若都使用同一种比特率是不太合理的，所以引入了动态比特率。</p>
<h2 id="动态比特率"><a href="#动态比特率" class="headerlink" title="动态比特率"></a>动态比特率</h2><p>简称为 <strong>VBR</strong>，即 Variable Bit Rate，比特率可以随着图像复杂程度的不同而随之变化。</p>
<p>图像内容简单的片段采用较小的码率，图像内容复杂的片段采用较大的码率，这样既保证了播放质量，又兼顾了数据量的限制。</p>
<p>比如 RMVB 视频文件，其中的 VB 就是指 VBR，表示采用动态比特率编码方式，达到播放质量与体积兼得的效果。</p>
<h2 id="静态比特率"><a href="#静态比特率" class="headerlink" title="静态比特率"></a>静态比特率</h2><p>简称为 <strong>CBR</strong>，即 Constant Bit Rate，比特率恒定。</p>
<p>图像内容复杂的片段质量不稳定，图像内容简单的片段质量较好。</p>
<p>除 VBR 和 CBR 外，还有 <strong>CVBR</strong>（Constrained VariableBit Rate） 、<strong>ABR</strong> (Average Bit Rate) 等等。</p>
<h1 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h1><p>定义：每秒从连续信号中提取并组成离散信号的采样个数，单位为赫兹（Hz）。</p>
<h2 id="音频中的采样率"><a href="#音频中的采样率" class="headerlink" title="音频中的采样率"></a>音频中的采样率</h2><p>指把音频信号数字化后 1 个通道 1 秒钟采取多少个样本，如 44.1kHz 的采样率，就是指 1 个通道 1 秒钟有 44.1k 个数据。</p>
<h2 id="视频中的采样率"><a href="#视频中的采样率" class="headerlink" title="视频中的采样率"></a>视频中的采样率</h2><p>视频一般<strong>不标识</strong>采样率属性</p>
<p>采样率本身就是一个可泛化的概念，对于视频来说，若非要用采样率来描述的话，那就要分为两个层面：<strong>帧频和场频</strong>。</p>
<p>从帧频层面来说，采样率就是指<strong>帧率</strong>，指 1 秒钟显示多少帧图像。</p>
<p>从场频层面来说，采样率就是指<strong>像素频率</strong>，指 1 秒钟显示多少个像素。</p>
<p>像素频率是显示器的一个指标，可以理解成显示器的最大带宽，可以起到限制<strong>分辨率和刷新率(每秒刷新的次数，Hz)</strong>的作用</p>
<p>根据含义可得出一个公式：</p>
<p><code>像素频率 = 刷新率 X 帧像素数量</code></p>
<p><code>像素频率 = 60Hz*1920*1080/1024/1024 = 118.65 MHz</code></p>
<h1 id="帧率"><a href="#帧率" class="headerlink" title="帧率"></a>帧率</h1><p>定义：用于测量显示帧数的量度。单位为 FPS（Frames per Second，每秒显示帧数）或赫兹（Hz）。</p>
<p>帧率越高，画面越流畅、逼真，对显卡的处理能力要求越高，数据量越大。</p>
<p>根据人眼视觉暂留原理，每秒超过 <strong>24</strong> 帧的图像变化看上去是平滑连续的，这样的连续画面叫视频。</p>
<h2 id="帧率主观感受"><a href="#帧率主观感受" class="headerlink" title="帧率主观感受"></a>帧率主观感受</h2><img src="/2019/07/31/直播/视频/视频相关基础概念/帧率主观感受.jpeg">
<p>视频长度是8秒。分辨率是QCIF (176 x 144) 。原始帧率是25 fps。</p>
<p>实验过程中，帧率变换为以下几种：25， 12.5， 8.33， 6.25， 5 以及 2.5 fps。</p>
<p>主观感受（MOS）取的是各个测试序列的平均值，包含了95%的置信区间。</p>
<p>可见帧率超过15帧以后，人眼就会获得很好的感受。而如果低于12.5帧的话，人眼的主观感受会随着帧率的下降而迅速下降。</p>
<h2 id="24-帧"><a href="#24-帧" class="headerlink" title="24 帧"></a>24 帧</h2><p>对电影等视频而言，24 帧 是流畅的；对游戏来说 是不流畅的</p>
<h3 id="两者图像生成原理不同"><a href="#两者图像生成原理不同" class="headerlink" title="两者图像生成原理不同"></a>两者图像生成原理不同</h3><p>电影的每一帧都包含一段时间的信息，会有动态模糊；而游戏的画面则是由显卡计算生成的，一帧只包含那一瞬间的信息</p>
<h3 id="电影的FPS是稳定的，而游戏则是不稳定的"><a href="#电影的FPS是稳定的，而游戏则是不稳定的" class="headerlink" title="电影的FPS是稳定的，而游戏则是不稳定的"></a>电影的FPS是稳定的，而游戏则是不稳定的</h3><p>电影若为 24fps，那就表示每隔 1/24 秒刷新一次画面，帧间隔是固定的。</p>
<p>游戏若为 60fps，表示大约每隔 1/60 秒刷新一次画面，帧间隔是不稳定的，即使 1 秒能显示 60 帧，那也可能是前半秒显示了 59 帧，后半秒显示了 1 帧。</p>
<p>所以游戏卡顿有两个解决方案：提高帧率，或增加动态模糊效果(游戏设置都有)。</p>
<h1 id="参考-amp-扩展"><a href="#参考-amp-扩展" class="headerlink" title="参考&amp;扩展"></a>参考&amp;扩展</h1><ul>
<li><a href="https://www.jianshu.com/p/1379ed99783e" target="_blank" rel="noopener">视频相关的理论知识与基础概念</a></li>
<li><a href="https://blog.csdn.net/lcalqf/article/details/53048347" target="_blank" rel="noopener">h264 Gop组 I 、P、B 帧</a></li>
<li><a href="https://blog.csdn.net/qq_29350001/article/details/73770702" target="_blank" rel="noopener">图像和流媒体 – I 帧,B帧,P帧,IDR帧的区别</a></li>
<li><a href="https://blog.csdn.net/leixiaohua1020/article/details/84490329" target="_blank" rel="noopener">视频帧率对人眼主观感受的影响 2</a> 雷霄骅</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/30/web/web渲染/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/30/web/web渲染/" itemprop="url">web渲染</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-30T15:28:14+08:00">
                2019-07-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基础术语"><a href="#基础术语" class="headerlink" title="基础术语"></a>基础术语</h1><h2 id="Rendering"><a href="#Rendering" class="headerlink" title="Rendering"></a>Rendering</h2><ul>
<li><strong>SSR 服务端渲染</strong>: Server-Side Rendering - 服务端渲染HTML.</li>
<li><strong>CSR 客户端渲染</strong>: Client-Side Rendering - 客服端浏览器使用DOM渲染.<br><strong>Rehydration 同构</strong>: 服务端和客户端使用同一份DOM渲染<br><strong>Prerendering 预渲染</strong>: 编译时启动一个客户端渲染出初始化的静态HTML</li>
</ul>
<h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><ul>
<li><strong>TTFB</strong>: Time to First Byte - seen as the time between clicking a link and the first bit of content coming in.</li>
<li><strong>FP</strong>: First Paint - the first time any pixel gets becomes visible to the user.</li>
<li><strong>FCP</strong>: First Contentful Paint - the time when requested content (article body, etc) becomes visible.</li>
<li><strong>TTI</strong>: Time To Interactive - the time at which a page becomes interactive (events wired up, etc).</li>
</ul>
<h2 id="SPA-和-MPA"><a href="#SPA-和-MPA" class="headerlink" title="SPA 和 MPA"></a>SPA 和 MPA</h2><p><strong>SPA 单页面应用</strong> Single-page Application </p>
<img src="/2019/07/30/web/web渲染/spa.png">
<p><strong>MPA 多页面应用多页面应用</strong> Multi-page Application </p>
<img src="/2019/07/30/web/web渲染/mpa.png">
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table>
<thead>
<tr>
<th></th>
<th>单页面应用</th>
<th>多页面应用</th>
</tr>
</thead>
<tbody>
<tr>
<td>组成</td>
<td>一个外壳页面和多个页面片段组成</td>
<td>多个完整页面构成</td>
</tr>
<tr>
<td>资源共用(css,js)</td>
<td>共用，只需在外壳部分加载</td>
<td>不共用，每个页面都需要加载</td>
</tr>
<tr>
<td>刷新方式</td>
<td>页面局部刷新或更改</td>
<td>整页刷新</td>
</tr>
<tr>
<td>url 模式</td>
<td>a.com/#/pageone  a.com/#/pagetwo</td>
<td>a.com/pageone.html  a.com/pagetwo.html</td>
</tr>
<tr>
<td>用户体验</td>
<td>用户体验良好。首屏时间慢，页面切换快</td>
<td>用户体验比较差。首屏时间快，页面切换慢</td>
</tr>
<tr>
<td>转场动画</td>
<td>容易实现</td>
<td>无法实现</td>
</tr>
<tr>
<td>数据传递</td>
<td>容易</td>
<td>依赖 url传参、或者cookie 、localStorage等</td>
</tr>
<tr>
<td>搜索引擎优化(SEO)</td>
<td>SEO差。需要单独方案、实现较为困难、可利用服务器端渲染(SSR)优化</td>
<td>SEO效果好。实现方法简易</td>
</tr>
<tr>
<td>使用范围</td>
<td>高要求的体验度、追求界面流畅的应用</td>
<td>适用于追求高度支持搜索引擎的应用</td>
</tr>
<tr>
<td>开发成本</td>
<td>较高，常需借助专业的框架</td>
<td>较低 ，但页面重复代码多</td>
</tr>
<tr>
<td>维护成本</td>
<td>相对容易</td>
<td>相对复杂</td>
</tr>
</tbody>
</table>
<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p>后端渲染 – 前端渲染 – 后端渲染</p>
<p>看一门技术的发展主要应该看背后的人是谁，应用场景是哪些，最后才是技术细节。</p>
<ol>
<li><p>后端发现页面中的 JS 很麻烦（虽然简单，但是坑多），于是让公司招聘专门写 JS 的人，也就是前端</p>
</li>
<li><p>前端名义上是程序员，实际上就是在写样式（CSS）和做特效(JS)，所以所有程序员中前端工资最低，职位也最低。所以前后端的鄙视链就出现了。</p>
</li>
<li>nodejs 和前端 mvc 的兴起让前端变得复杂起来，前端发现翻身的机会，于是全力支持这两种技术，造成本不该做成 SPA 的网站也成了 spa。慢慢地前后端分离运动从大公司开始兴起，目的就是前端脱离后端的指指点点，独立发展。（表面上是为了「代码分离」，实际上是为了「人员分离」，也就是「前后端分家」，前端不再附属于后端团队）</li>
<li>spa 之后发现 <strong>seo</strong> 问题很大，而且<strong>首屏渲染速度</strong>很慢，但是自己选的路再难走也要走下去，于是用 nodejs 在服务端渲染这一条路被看成是一条出路</li>
<li>其实这是第二个翻身的机会，如果 nodejs 服务器渲染成为主流，其实就相当于前端把后端的大部分工作给抢了，工资压过普通后端指日可待</li>
<li>然而结果是 nodejs 服务端渲染始终是小众，因为后端也没那么脆弱，java php rails 十多年沉淀的技术岂是你说推翻就推翻的，已经运行多年的项目又岂是容你随便用 nodejs 重写的，另一方面 golang 等技术的兴起也给 nodejs 不少压力。最终只有少部分前端特别强势的团队成功用上了 Node.js 做渲染（比如阿里的一些团队），大部分公司依然是用 PHP 渲染 HTML。</li>
<li>于是 nodejs 退一步说好好好我不抢你们的工作，我只做中间层（大部分工作就是渲染页面和调用后台接口），绝不越雷池。后端说算你识相。现在 nodejs 主要搞什么微服务，也是为了抢后端还没注意的市场。</li>
</ol>
<h2 id="前端的矛盾"><a href="#前端的矛盾" class="headerlink" title="前端的矛盾"></a>前端的矛盾</h2><p>前后端代码可以分离，但是人员绝对不应该分离。前后端撕逼的事情在大公司天天都在发生，全都是因为前后是两个团队，利益不同。实际上前端推 nodejs 渲染就是在试图重新让前后端合成一体。</p>
<p>但是前端不能明说这件事，因为如果要把前后端部门合并，拆掉的肯定是前端部门。</p>
<p>合，则相当于自断前程。<br>不合，则永远没法解决seo和首屏加载慢的问题。<br>所以前端真的挺矛盾的。</p>
<h2 id="JS的矛盾"><a href="#JS的矛盾" class="headerlink" title="JS的矛盾"></a>JS的矛盾</h2><p>凡是浏览器上的框架（Vue React）都说自己能适应「复杂」场景，凡是 Node.js 上的框架（express fastify koa）都说自己是「轻量级」框架。</p>
<p>为啥？因为浏览器是 JS 的主战场，而且无敌手。而服务器上，JS 的经验积累还是太少了，搞企业级服务，Node.js 是敌不过 Java、PHP 的，没办法，发展得太晚了。所以目前只能搞「轻量级」咯。<code>egg.js</code> 号称是企业级 Node.js 框架，用过的人来评我就不评了。</p>
<h2 id="大前端"><a href="#大前端" class="headerlink" title="大前端"></a>大前端</h2><p>有些大佬提出「大前端」的概念，意思是前端也要会后端，但是我们心还是前端的。</p>
<p>这不就是把以前的『前后端一个人做』换了个说法嘛。以前是后端一个人做，现在前端一个做。</p>
<p>反正你现在让后端去学前端，后端肯定是不愿意躺这浑水的。只能前端自己想办法咯。</p>
<p>想来想去就只有 Node.js 中间层做 HTML 渲染了。</p>
<p>由于阿里 nodejs 用得还算多，却招不到人，所以从功利的角度出发，也许你学 nodejs 比学 java 更容易进阿里，毕竟阿里的 java 大神多如云，nodejs 大神却不多。</p>
<h2 id="开历史倒车？"><a href="#开历史倒车？" class="headerlink" title="开历史倒车？"></a>开历史倒车？</h2><p>其实并<strong>不是</strong>。以前是 Back-end（或者说 Full-stack）工程师负责 SSR，但是现在是 Front-end 工程师负责 SSR 了啊。在目前这个知识爆炸的年代，前后端的职能目前已经被分割得很开，大家都不愿意去淌对方那摊混水，而 Rendering 这事从语义上出发就属于 Front-end 的范畴，让 Back-end 去做这事，其实很多人是不愿意的。</p>
<p>回到问题本身，SSR 的「又流行」其实是 Front-end 社区<strong>工具栈不断进化</strong>的体现，也是历史的必然啊。几年前，SPA/CSR 概念的大热，让很多 Front-end 把他们当做万金油了。其实大家都知道 CSR 有着 SEO 和 页面渲染速度的问题，但苦于社区中没有解决这个问题的工具栈，所以大家都对这个问题<strong>视而不见</strong>了。</p>
<p>而随着 Front-end 社区造轮子大潮的兴起，出现了一个很关键的历史转折点 —— Node.js 的出现。Node.js 赋予了 Front-end 在服务端执行 Js 的能力，有了这个环境和土壤，Front-end 工程师们终于可以考虑如何用 Js 来实现 SSR 了，于是 React 和 Vue 等主流框架后面开始支持 SSR 也就成了必然。</p>
<p>所以之前并不是不流行，而是因为前后端职能的分离，Back-end 不愿意做这事了，Front-end 没有条件去做。现在有条件了，自然又开始流行了。</p>
<h1 id="利弊"><a href="#利弊" class="headerlink" title="利弊"></a>利弊</h1><img src="/2019/07/30/web/web渲染/vs.png">
<h1 id="同构"><a href="#同构" class="headerlink" title="同构"></a>同构</h1><p>为了解决客户端渲染首屏慢与 SEO 问题，同构开始出现。</p>
<p>同构：前后端共用 JS，首次渲染时使用 Node.js 来直出 HTML。一般来说同构渲染是介于前后端中的共有部分。</p>
<p>简单说下在使用 Vue SSR（nuxt）的一些坑：</p>
<p>服务端必须是 node.js 或者专门跑个 node.js 来支持；</p>
<p>document 对象找不到，由于前端使用的 window，在 node 环境不存在；</p>
<p>数据预获取时，组件尚未实例化（无法使用 this ），于是在 created 生命钩子调用 method 里的方法行不通，数据请求及格式化等操作都应该放置在专门的数据预取存储容器（data store）或”状态容器（state container）”中处理；</p>
<p>string-based 模板性能肯定要比 virtual-dom-based 模板的性能好。string-base 模板只要填数据即可，virtual-dom-based 模板需要经历 Vue 模板语法 —&gt; Vnode —&gt; 拼接字符串 html 的过程。 有关性能的消耗对比，可以参考这篇文章<a href="https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;mid=2247485601&amp;idx=1&amp;sn=97a45254a771d13789faed81316b465a&amp;source=41#wechat_redirect" target="_blank" rel="noopener">实测Vue SSR的渲染性能：避开20倍耗时</a>；</p>
<p>缓存方面，只能做到页面级的缓存。如果用户特定（user-specific），即对于不同用户需要渲染不同内容，缓存是不可用的。</p>
<p>是否有其他解决客户端渲染不足之处的方法？</p>
<p>答案肯定是有的：</p>
<p>处理 SEO 问题时，使用 prerender… 、升级搜索引擎，以及其他。</p>
<p>白屏可以加 loading、Skeleton Screen 效果、以及其他。</p>
<h1 id="参考-amp-扩展"><a href="#参考-amp-扩展" class="headerlink" title="参考&amp;扩展"></a>参考&amp;扩展</h1><ul>
<li><a href="https://developers.google.com/web/updates/2019/02/rendering-on-the-web" target="_blank" rel="noopener">Google开发者：SSR、CSR、预渲染、伪同构等渲染架构</a></li>
<li><a href="https://blog.csdn.net/B9Q8e64lO6mm/article/details/79418969" target="_blank" rel="noopener">知乎问答：为什么现在又流行服务器端渲染html？</a></li>
<li><a href="https://juejin.im/entry/5a111eb7f265da431c6fe51c" target="_blank" rel="noopener">服务端渲染 vs 客户端渲染</a></li>
<li><a href="https://juejin.im/post/5a0ea4ec6fb9a0450407725c" target="_blank" rel="noopener">前端：你要懂的单页面应用和多页面应用</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/26/java基础/异常/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/26/java基础/异常/" itemprop="url">异常</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-26T15:55:53+08:00">
                2019-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="异常声明"><a href="#异常声明" class="headerlink" title="异常声明"></a>异常声明</h1><p>属于方法说明的一部分，紧跟在参数列表之后</p>
<p><code>void method() throws IOException {}</code></p>
<p>子类在覆盖方法时，不能添加父类方法没有的异常声明（只能保持或者减少）。</p>
<h1 id="Throwable-方法汇总"><a href="#Throwable-方法汇总" class="headerlink" title="Throwable 方法汇总"></a>Throwable 方法汇总</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">getMessage()</span><br><span class="line">getLocalizedMessage()</span><br><span class="line">toString()</span><br><span class="line"></span><br><span class="line">getCause()</span><br><span class="line">initCause(Throwable cause)</span><br><span class="line"></span><br><span class="line">printStackTrace()</span><br><span class="line">getStackTrace()</span><br><span class="line">fillInStackTrace()</span><br><span class="line">setStackTrace(StackTraceElement[] stackTrace)</span><br><span class="line"></span><br><span class="line">addSuppressed(Throwable exception)</span><br><span class="line">getSuppressed()</span><br></pre></td></tr></table></figure>
<h2 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h2><p><code>throw new RuntimeException(&quot;My Exception&quot;);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getMessage(): My Exception</span><br><span class="line">getLocalizedMessage(): My Exception</span><br><span class="line">toString(): java.lang. RuntimeException: My Exception</span><br><span class="line"></span><br><span class="line">printStackTrace(): </span><br><span class="line">	java.lang. RuntimeException: My Exception</span><br><span class="line">	at Test.main(Test.java:<span class="number">9</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>getLocalizedMessage()</code>和 <code>getMessage()</code> 返回构造方法传入的参数信息</li>
<li>toString() 返回异常完整类名和 <code>getMessage()</code>的信息</li>
<li>printStackTrace() 打印 <code>toString()</code>信息和异常堆栈</li>
</ul>
<h1 id="printStackTrace"><a href="#printStackTrace" class="headerlink" title="printStackTrace()"></a>printStackTrace()</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printStackTrace</span><span class="params">(PrintStreamOrWriter s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Guard against malicious overrides of Throwable.equals by</span></span><br><span class="line">    <span class="comment">// using a Set with identity equality semantics.</span></span><br><span class="line">    Set&lt;Throwable&gt; dejaVu =</span><br><span class="line">        Collections.newSetFromMap(<span class="keyword">new</span> IdentityHashMap&lt;Throwable, Boolean&gt;());</span><br><span class="line">    dejaVu.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (s.lock()) &#123;</span><br><span class="line">        <span class="comment">// Print our stack trace</span></span><br><span class="line">        s.println(<span class="keyword">this</span>);</span><br><span class="line">        StackTraceElement[] trace = getOurStackTrace();</span><br><span class="line">        <span class="keyword">for</span> (StackTraceElement traceElement : trace)</span><br><span class="line">            s.println(<span class="string">"\tat "</span> + traceElement);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Print suppressed exceptions, if any</span></span><br><span class="line">        <span class="keyword">for</span> (Throwable se : getSuppressed())</span><br><span class="line">            se.printEnclosedStackTrace(s, trace, SUPPRESSED_CAPTION, <span class="string">"\t"</span>, dejaVu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Print cause, if any</span></span><br><span class="line">        Throwable ourCause = getCause();</span><br><span class="line">        <span class="keyword">if</span> (ourCause != <span class="keyword">null</span>)</span><br><span class="line">            ourCause.printEnclosedStackTrace(s, trace, CAUSE_CAPTION, <span class="string">""</span>, dejaVu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>打印 自身 堆栈</li>
<li><strong>递归</strong> 打印 <strong>抑制(suppressed)异常链</strong> 堆栈<ul>
<li>第一行前缀 <code>Suppressed by:</code>在异常完整类名和构造参数之前 </li>
</ul>
</li>
<li><strong>递归</strong> 打印 <strong>cause</strong> 堆栈<ul>
<li>第一行前缀 <code>Caused by:</code>在异常完整类名和构造参数之前     </li>
</ul>
</li>
</ul>
<p>printEnclosedStackTrace() 是 <strong>递归方法</strong></p>
<h1 id="getOurStackTrace"><a href="#getOurStackTrace" class="headerlink" title="getOurStackTrace()"></a>getOurStackTrace()</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> StackTraceElement[] getOurStackTrace() &#123;</span><br><span class="line">    <span class="keyword">return</span> stackTrace;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>倒序</strong>记录着方法调用帧：后调用的在最前面/最顶上</p>
<ul>
<li>栈顶元素（元素0），是方法调用序列中最后一个方法调用</li>
<li>栈底元素（最后一个元素）是调用序列中的第一个方法调用</li>
</ul>
<h1 id="getStackTrace"><a href="#getStackTrace" class="headerlink" title="getStackTrace()"></a>getStackTrace()</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> StackTraceElement[] getStackTrace() &#123;</span><br><span class="line">    <span class="keyword">return</span> getOurStackTrace().clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="StackTraceElement"><a href="#StackTraceElement" class="headerlink" title="StackTraceElement"></a>StackTraceElement</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StackTraceElement</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Normally initialized by VM (public constructor added in 1.5)</span></span><br><span class="line">    <span class="keyword">private</span> String declaringClass; <span class="comment">//完整类名</span></span><br><span class="line">    <span class="keyword">private</span> String methodName; <span class="comment">//方法名。不带签名(参数和返回值)</span></span><br><span class="line">    <span class="keyword">private</span> String fileName; <span class="comment">//类文件名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>    lineNumber; <span class="comment">//行号；-2表示该方法是Native方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="重新抛出异常和异常链"><a href="#重新抛出异常和异常链" class="headerlink" title="重新抛出异常和异常链"></a>重新抛出异常和异常链</h1><h2 id="抛出原异常对象"><a href="#抛出原异常对象" class="headerlink" title="抛出原异常对象"></a>抛出原异常对象</h2><p>有时我们在捕获到异常后，可能在捕获的地方不适合处理该异常，我们需要将它重新抛出</p>
<p>这样就会存在一个问题，抛出的的异常携带的信息，是原来异常抛出点的调用栈信息，而非新抛出点的信息（新抛出点的调用信息就被掩盖了）。</p>
<p>可以使用 <code>fillInStackTrace()</code> 更新新抛出点信息到这个异常调用栈中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: My Exception</span><br><span class="line">	at Test.main(Test.java:9)</span><br><span class="line">	</span><br><span class="line">使用 fillInStackTrace() 后：</span><br><span class="line">java.lang.RuntimeException: My Exception</span><br><span class="line">	at Test.main(Test.java:11)</span><br></pre></td></tr></table></figure>
<p>单纯的更新了抛出异常的所在函数</p>
<p><strong>不推荐使用</strong></p>
<h2 id="抛出新异常对象"><a href="#抛出新异常对象" class="headerlink" title="抛出新异常对象"></a>抛出新异常对象</h2><p>新建异常对象时传入原来的异常对象，或者调用 <code>initCause(Throwable cause)</code>传入原异常对象。</p>
<p>这样原来的异常对象作为 <code>cause</code> 保持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: java.lang.RuntimeException: My Exception</span><br><span class="line">	at Test.main(Test.java:14) //新异常抛出处</span><br><span class="line">Caused by: java.lang.RuntimeException: My Exception</span><br><span class="line">	at Test.main(Test.java:12) //老异常抛出处</span><br></pre></td></tr></table></figure>
<h2 id="异常抑制"><a href="#异常抑制" class="headerlink" title="异常抑制"></a>异常抑制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"try"</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// throw new RuntimeException("finally");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: try</span><br><span class="line">	at Test.main(Test.java:10)</span><br><span class="line">	</span><br><span class="line">finally 也抛出异常：</span><br><span class="line">java.lang.RuntimeException: finally</span><br><span class="line">	at Test.main(Test.java:12)</span><br></pre></td></tr></table></figure>
<p>finally 抑制了上一个异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Exception exception = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"try"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    exception = e;</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    RuntimeException e = <span class="keyword">new</span> RuntimeException(<span class="string">"finally"</span>);</span><br><span class="line">    <span class="keyword">if</span>(exception!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        e.addSuppressed(exception);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: finally</span><br><span class="line">	at Test.main(Test.java:15)</span><br><span class="line">	Suppressed: java.lang.RuntimeException: try</span><br><span class="line">		at Test.main(Test.java:11)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/24/CocosCreator/CocosCreator新手上路/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/24/CocosCreator/CocosCreator新手上路/" itemprop="url">CocosCreator新手上路</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-24T18:30:53+08:00">
                2019-07-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/游戏/" itemprop="url" rel="index">
                    <span itemprop="name">游戏</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关于-Cocos-Creator"><a href="#关于-Cocos-Creator" class="headerlink" title="关于 Cocos Creator"></a>关于 Cocos Creator</h1><p>是一个完整的游戏开发解决方案</p>
<p>包括了</p>
<ul>
<li>cocos2d-x 引擎的 JavaScript 实现（不需要学习一个新的引擎）</li>
<li>快速开发游戏所需要的各种图形界面工具</li>
</ul>
<h1 id="安装-Cocos-Creator"><a href="#安装-Cocos-Creator" class="headerlink" title="安装 Cocos Creator"></a>安装 Cocos Creator</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>访问 <a href="https://www.cocos.com/creator/" target="_blank" rel="noopener">Cocos Creator 产品首页,详细发版记录</a> 上的下载链接获得 Cocos Creator 的安装包</p>
<p>兼容已有旧项目，选择 <a href="http://cocos2d-x.org/filedown/CocosCreator_v2.1.0_mac" target="_blank" rel="noopener">2.1.0版本</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Mac安装"><a href="#Mac安装" class="headerlink" title="Mac安装"></a>Mac安装</h3><p>操作系统要求：最低版本是 OS X 10.9</p>
<p>双击 DMG 文件，然后将 <code>CocosCreator.app</code> 拖拽到 <code>应用程序</code> 文件夹快捷方式</p>
<h1 id="安装配置原生开发环境"><a href="#安装配置原生开发环境" class="headerlink" title="安装配置原生开发环境"></a>安装配置原生开发环境</h1><p>如果只想开发 Web 平台的游戏，完成上面的步骤就足够了。</p>
<p>如果希望发布游戏到原生平台，就需要安装配置原生开发环境。</p>
<p>Cocos Creator 使用基于 cocos2d-x 引擎的 JSB 技术实现跨平台发布原生应用。</p>
<p>在使用 Cocos Creator 打包发布到原生平台之前，我们需要先配置好 cocos2d-x 相关的开发环境</p>
<h2 id="Android-平台相关依赖"><a href="#Android-平台相关依赖" class="headerlink" title="Android 平台相关依赖"></a>Android 平台相关依赖</h2><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><h3 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h3><h3 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h3><h3 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h3><h2 id="C-编译环境"><a href="#C-编译环境" class="headerlink" title="C++ 编译环境"></a>C++ 编译环境</h2><p>Cocos2d-x 自带的编译工具 Cocos Console 需要以下运行环境：</p>
<ul>
<li><p>Python 2.7.5+，<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">下载页</a>，注意不要下载 Python 3.x 版本。</p>
</li>
<li><p>Windows 下需要安装 Visual Studio 2015 或 2017 社区版，<a href="https://www.visualstudio.com/downloads/download-visual-studio-vs" target="_blank" rel="noopener">下载页</a></p>
</li>
<li>Mac 下需要安装 Xcode 和命令行工具，<a href="https://developer.apple.com/xcode/download/" target="_blank" rel="noopener">下载页</a></li>
</ul>
<h2 id="配置原生发布环境路径"><a href="#配置原生发布环境路径" class="headerlink" title="配置原生发布环境路径"></a>配置原生发布环境路径</h2><p>CocosCreator -&gt; <code>设置</code>，打开设置窗口</p>
<p>我们在这里需要配置以下两个路径：</p>
<p><code>NDK</code> 路径，选择 Android SDK Location 路径下的 ndk-bundle 文件夹（NDK 是其根目录），不需要编译 Android 平台的话这里可以跳过。</p>
<p><code>Android SDK</code> 路径，选择刚才在 SDK Manager 中记下的 Android SDK Location 路径（Android SDK 的目录下应该包含 build-tools、platforms 等文件夹），不需要编译 Android 平台的话这里可以跳过。<br>配置完成后点击 保存 按钮，保存并关闭窗口。</p>
<p>注意：这里的配置会在编译 原生工程 的时候生效。如果没有生效（一些 Mac 机器有可能出现这个情况），可能需要您尝试到 系统环境变量 设置这些值：COCOS_CONSOLE_ROOT, NDK_ROOT, ANDROID_SDK_ROOT。</p>
<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>在 <code>Dashboard</code> 中，打开 <code>新建项目</code> 选项卡，选中 <code>Hello World</code> 项目模板。</p>
<h2 id="打开场景，开始工作"><a href="#打开场景，开始工作" class="headerlink" title="打开场景，开始工作"></a>打开场景，开始工作</h2><p>Cocos Creator 的工作流程是以数据驱动和场景为核心的，初次打开一个项目时，默认不会打开任何场景，要看到 Hello World 模板中的内容，我们需要先打开场景资源文件。</p>
<img src="/2019/07/24/CocosCreator/CocosCreator新手上路/open_scene.png">
<p>在 <code>资源管理器</code> 中双击箭头所指的 <code>helloworld</code> 场景文件</p>
<h2 id="预览场景"><a href="#预览场景" class="headerlink" title="预览场景"></a>预览场景</h2><p>点击编辑器窗口正上方的 <code>预览游戏</code> 按钮。</p>
<img src="/2019/07/24/CocosCreator/CocosCreator新手上路/preview_button.png">
<p>Cocos Creator 会使用您的默认浏览器运行当前游戏场景。点击预览窗口左上角的下拉菜单，可以选择不同设备屏幕的预览效果。</p>
<img src="/2019/07/24/CocosCreator/CocosCreator新手上路/preview.png">
<h2 id="修改欢迎文字"><a href="#修改欢迎文字" class="headerlink" title="修改欢迎文字"></a>修改欢迎文字</h2><p>首先在 <code>层级管理器</code> 中选中 <code>Canvas</code> 节点，我们的 HelloWorld 组件脚本就挂在这个节点上。</p>
<p>接下来在 <code>属性检查器</code> 面板下方找到 <code>HelloWorld</code>组件属性，然后将 <code>Text</code> 属性里的文本改成 你好，世界！</p>
<img src="/2019/07/24/CocosCreator/CocosCreator新手上路/change_text.png">
<p>再次运行预览，可以看到欢迎文字已经更新了</p>
<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ProjectName（项目文件夹）</span><br><span class="line">	├──assets </span><br><span class="line">		├──Scene		├──Scene.meta		├──Script		├──Script.meta		├──Texture		├──Texture.meta</span><br><span class="line">	├──build</span><br><span class="line">	├──library</span><br><span class="line">	├──local</span><br><span class="line">	├──settings</span><br><span class="line">	├──temp</span><br><span class="line">	└──project.json</span><br></pre></td></tr></table></figure>
<h2 id="assets-资源文件夹"><a href="#assets-资源文件夹" class="headerlink" title="assets 资源文件夹"></a>assets 资源文件夹</h2><p>游戏中所有本地资源、脚本和第三方库文件 </p>
<p>显示在 <strong>资源管理器</strong> 中</p>
<p>每个文件在导入后都会生成一个同名 <code>.meta</code> 文件，用于存储该文件作为资源导入后的信息和与其他资源的<strong>关联</strong>。</p>
<h2 id="library-资源库"><a href="#library-资源库" class="headerlink" title="library 资源库"></a>library 资源库</h2><p><code>assets</code> 中的资源导入后<strong>自动生成</strong>的。将文件结构和资源格式处理成最终游戏发布时需要的形式。</p>
<p>不需要进入版本控制的</p>
<p>丢失或损坏的时候，删除整个 <code>library</code> 文件夹再打开项目，就会重新生成资源库</p>
<h2 id="local-本地设置"><a href="#local-本地设置" class="headerlink" title="local 本地设置"></a>local 本地设置</h2><p>该项目的本地设置：包括编辑器面板布局，窗口大小，位置等信息。</p>
<p>按照您的习惯设置编辑器布局，这些就会自动保存在这个文件夹</p>
<p>不需要进入版本控制</p>
<h2 id="settings-项目设置"><a href="#settings-项目设置" class="headerlink" title="settings 项目设置"></a>settings 项目设置</h2><p>项目相关的设置：<code>构建发布</code> 菜单里的包名、场景和平台选择等。</p>
<p>需要进行版本控制</p>
<h2 id="project-json"><a href="#project-json" class="headerlink" title="project.json"></a>project.json</h2><p><code>project.json</code> 文件和 <code>assets</code> 文件夹一起，作为验证 Cocos Creator 项目合法性的标志。只有包括了这两个内容的文件夹才能作为 Cocos Creator 项目打开。</p>
<p>目前只用来规定当前使用的引擎类型和插件存储位置，不需要用户关心其内容。</p>
<p>需要进行版本控制</p>
<h2 id="build-构建目标"><a href="#build-构建目标" class="headerlink" title="build 构建目标"></a>build 构建目标</h2><p>在使用主菜单中的 <code>项目</code> -&gt; <code>构建发布...</code> 使用<strong>默认发布路径</strong>发布项目后，编辑器会在项目路径下创建 build 目录，并存放所有目标平台的构建工程。</p>
<p>不进入版本控制</p>
<ul>
<li>每次构建项目后资源 id 可能会变化</li>
<li>体积很大</li>
</ul>
<h1 id="打包发布原生平台"><a href="#打包发布原生平台" class="headerlink" title="打包发布原生平台"></a>打包发布原生平台</h1><p>点击菜单栏的 <code>项目</code> -&gt; <code>构建发布</code>，打开构建发布面板。</p>
<h2 id="构建原生工程"><a href="#构建原生工程" class="headerlink" title="构建原生工程"></a>构建原生工程</h2><p>选择发布平台，设置初始场景，点击右下角的 <code>构建</code> 按钮，开始构建流程。</p>
<img src="/2019/07/24/CocosCreator/CocosCreator新手上路/build.png">
<p>进度条到达 100% 后请继续等待 <strong>控制台</strong> 面板(在主面板底部)中的工程构建结束</p>
<p>编译成功</p>
<p>控制台面板日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Building /Users/liyungui/StudioProjects/cocos_helloworld</span><br><span class="line">Destination /Users/liyungui/StudioProjects/cocos_helloworld/build/jsb-link</span><br><span class="line">Delete /Users/liyungui/StudioProjects/cocos_helloworld/build/jsb-link/res/**/*,/Users/liyungui/StudioProjects/cocos_helloworld/build/jsb-link/src/*/</span><br><span class="line">Checked Python Version [2.7.10]</span><br><span class="line">Creating native cocos project to /Users/liyungui/StudioProjects/cocos_helloworld/build/jsb-link</span><br><span class="line">Start building assets</span><br><span class="line">Finish building assets</span><br><span class="line">Start building plugin scripts</span><br><span class="line">Checked Python Version [2.7.10]</span><br><span class="line">Built to &quot;/Users/liyungui/StudioProjects/cocos_helloworld/build/jsb-link&quot; successfully</span><br></pre></td></tr></table></figure>
<p>构建结束后，我们得到的是一个标准的 cocos2d-x 工程</p>
<p>接下来我们可以选择通过 Cocos Creator 编辑器的进程进行编译，以及运行桌面预览，或手动在相应平台的 IDE 中打开构建好的原生工程，进行进一步的预览、调试和发布。</p>
<h2 id="编译原生工程"><a href="#编译原生工程" class="headerlink" title="编译原生工程"></a>编译原生工程</h2><h3 id="通过编辑器编译"><a href="#通过编辑器编译" class="headerlink" title="通过编辑器编译"></a>通过编辑器编译</h3><p>点击下方的 <code>编译</code> 按钮，进入编译流程，如果模板选择了 default 的源码版引擎，这个编译的过程将会花费比较久的时间。</p>
<p>编译成功</p>
<p>控制台面板日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Checked Python Version [2.7.10]</span><br><span class="line">Start to compile native project. Please wait...</span><br><span class="line">The log file path [ /Users/liyungui/.CocosCreator/logs/native.log ]</span><br><span class="line">Compile native project successfully.</span><br></pre></td></tr></table></figure>
<p>注意：首次编译 Android 平台，建议通过 Android Studio 打开工程，根据提示下载缺失的工具，再进行编译运行。</p>
<h2 id="运行预览原生工程"><a href="#运行预览原生工程" class="headerlink" title="运行预览原生工程"></a>运行预览原生工程</h2><h3 id="通过编辑器运行预览"><a href="#通过编辑器运行预览" class="headerlink" title="通过编辑器运行预览"></a>通过编辑器运行预览</h3><p>点击右下角的 <code>运行</code> 按钮，通过默认方式预览原生平台的游戏。</p>
<p>点击运行后，视平台不同可能还会继续进行一部分编译工作，请耐心等待或通过日志文件查看进展。</p>
<p>其中 Mac/Windows 平台直接在桌面运行预览，iOS 平台会调用模拟器运行预览，Android 平台必须通过 USB 连接真机，并且在真机上开启 USB 调试后才可以运行预览。</p>
<p>运行成功后，logcat日志 过滤 tag: jswrapper</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2019-07-24 19:02:18.986 6156-6195/? D/jswrapper: Initializing V8, version: 6.0.286.52</span><br><span class="line">2019-07-24 19:02:20.081 6156-6195/? D/jswrapper: JS: Enable batch GL commands optimization!</span><br><span class="line">2019-07-24 19:02:20.960 6156-6195/? D/jswrapper: glGetIntegerv: pname: 0x8b4c</span><br><span class="line">2019-07-24 19:02:21.004 6156-6195/? D/jswrapper: JS: Cocos Creator v2.1.0</span><br><span class="line">2019-07-24 19:02:21.078 6156-6195/? D/jswrapper: JS: LoadScene 2dL3kvpAxJu6GJ7RdqJG5J: 70.58299999999986ms</span><br><span class="line">2019-07-24 19:02:21.082 6156-6195/? D/jswrapper: JS: Success to load scene: db://assets/Scene/helloworld.fire</span><br></pre></td></tr></table></figure>
<h2 id="使用原生工程"><a href="#使用原生工程" class="headerlink" title="使用原生工程"></a>使用原生工程</h2><p>点击发布路径旁边的 <code>打开</code>按钮，就会在操作系统的文件管理器中打开构建发布路径。</p>
<img src="/2019/07/24/CocosCreator/CocosCreator新手上路/open_project.png">
<p>这个路径中的 <code>jsb-default</code> 或 <code>jsb-link</code> （根据选择模板不同）里就包含了所有原生构建工程。</p>
<img src="/2019/07/24/CocosCreator/CocosCreator新手上路/native_projects.jpg">
<p>接下来您只要使用原生平台对应的 IDE （如 Xcode、Android Studio、Visual Studio）打开这些工程，就可以进行进一步的编译、预览、发布操作了。</p>
<p>注意：在 MIUI 10 系统上运行 debug 模式构建的工程可能会弹出 “Detected problems with API compatibility” 的提示框，这是 MIUI 10 系统自身引入的问题，使用 release 模式构建即可。<br>s</p>
<h1 id="参考-amp-扩展"><a href="#参考-amp-扩展" class="headerlink" title="参考&amp;扩展"></a>参考&amp;扩展</h1><ul>
<li><a href="https://www.cocos.com/creator/" target="_blank" rel="noopener">Cocos Creator 产品首页,详细发版记录</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/19/Android/性能优化/卡顿分析-正确评测流畅度/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/19/Android/性能优化/卡顿分析-正确评测流畅度/" itemprop="url">卡顿分析-正确评测流畅度</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-19T18:05:53+08:00">
                2019-07-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="使用FPS评测应用流畅度不科学"><a href="#使用FPS评测应用流畅度不科学" class="headerlink" title="使用FPS评测应用流畅度不科学"></a>使用FPS评测应用流畅度不科学</h1><p>说到应用的流畅度，都会想到FPS</p>
<p>FPS(Frames Per Second) 每秒帧数</p>
<p>Android系统获取FPS的原理是：SurfaceFLinger类把系统所有进程当前需要显示的信息合成一帧，提交到屏幕上进行显示。FPS就是1秒内SurfaceFLinger提交到屏幕的帧数。</p>
<p>用FPS评测应用是否卡顿存在两个问题。</p>
<ul>
<li>有的时候FPS很低，APP看起来却很流畅；<ul>
<li>当前界面在1秒内只需要10帧的显示需求，FPS只要高于10就可以了，如果屏幕根本没有绘制需求，那FPS的值就是0</li>
</ul>
</li>
<li>APP停止操作之后，FPS还是在一直变化</li>
</ul>
<h1 id="VSYNC信号"><a href="#VSYNC信号" class="headerlink" title="VSYNC信号"></a>VSYNC信号</h1><p>Android渲染机制是每隔16ms发出VSYNC信号，触发对UI的渲染，16ms没完成绘制就会卡顿。</p>
<p>VSync机制就像是一台固定转速的发动机(60转/s)。每一转会带动着去做一些UI相关的事情，但不是每一转都会有工作去做。有时候某一转因为工作量比较重超过了16.6ms，那么这台发动机这秒内就不是60转了，转速降低。我们把这个转速叫做流畅度。流畅度越小说明当前程序越卡顿。</p>
<h1 id="Choreographer帧率检测原理"><a href="#Choreographer帧率检测原理" class="headerlink" title="Choreographer帧率检测原理"></a>Choreographer帧率检测原理</h1><p>Choreographer中（英[ˌkɒrɪ’ɒɡrəfə(r)] 美[ˌkɒrɪ’ɒɡrəfə(r)]）编舞者</p>
<p>我们有时候会看到这样的log，系统帮助我们打印出了跳帧数。这个日志来自于<code>Choreographer.doFrame</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">02-07 19:47:04.337 17601-17601/zhangwan.wj.com.choreographertest I/Choreographer: Skipped 60 frames!  The application may be doing too much work on its main thread.</span><br><span class="line">02-07 19:47:11.685 17601-17601/zhangwan.wj.com.choreographertest I/Choreographer: Skipped 85 frames!  The application may be doing too much work on its main thread.</span><br><span class="line">02-07 19:47:12.545 17601-17601/zhangwan.wj.com.choreographertest I/Choreographer: Skipped 37 frames!  The application may be doing too much work on its main thread.</span><br><span class="line">02-07 19:47:14.893 17601-17601/zhangwan.wj.com.choreographertest I/Choreographer: Skipped 37 frames!  The application may be doing too much work on its main thread.</span><br><span class="line">02-07 19:47:23.049 17601-17601/zhangwan.wj.com.choreographertest I/Choreographer: Skipped 36 frames!  The application may be doing too much work on its main thread.</span><br><span class="line">02-07 19:47:23.929 17601-17601/zhangwan.wj.com.choreographertest I/Choreographer: Skipped 37 frames!  The application may be doing too much work on its main thread.</span><br><span class="line">02-07 19:47:24.961 17601-17601/zhangwan.wj.com.choreographertest I/Choreographer: Skipped 61 frames!  The application may be doing too much work on its main thread.</span><br><span class="line">02-07 19:47:25.817 17601-17601/zhangwan.wj.com.choreographertest I/Choreographer: Skipped 36 frames!  The application may be doing too much work on its main thread.</span><br><span class="line">02-07 19:47:26.433 17601-17601/zhangwan.wj.com.choreographertest I/Choreographer: Skipped 36 frames!  The application may be doing too much work on its main thread.</span><br></pre></td></tr></table></figure>
<p>阈值默认是30，跳帧超过30帧则打印警告日志，所以上面的log并不是经常看到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SKIPPED_FRAME_WARNING_LIMIT =SystemProperties.getInt( <span class="string">"debug.choreographer.skipwarning"</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>
<p>如果我们用反射的方法把SKIPPED_FRAME_WARNING_LIMIT的值设置成1，这样只要有丢帧，就会有上面的log输出。我们只要捕获这个log提取出skippedFrames 就可以知道界面是否卡顿</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Field field = Choreographer.class.getDeclaredField(<span class="string">"SKIPPED_FRAME_WARNING_LIMIT"</span>);</span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    field.set(Choreographer.class,<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="检测帧率"><a href="#检测帧率" class="headerlink" title="检测帧率"></a>检测帧率</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FrameCallback</span> </span>&#123;  </span><br><span class="line">  <span class="comment">//当新的一帧被绘制的时候被调用。  </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义FrameCallback。记录下每一帧开始渲染的时间，在下一帧被处理时，判断上一帧在渲染过程中是否出现掉帧。</p>
<p>在需要检测的Activity中调用 SMFrameCallback.getInstance().start()即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMFrameCallback</span> <span class="keyword">implements</span> <span class="title">Choreographer</span>.<span class="title">FrameCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  SMFrameCallback sInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String TAG=<span class="string">"SMFrameCallback"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> deviceRefreshRateMs=<span class="number">16.6f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">long</span> lastFrameTimeNanos=<span class="number">0</span>;<span class="comment">//纳秒为单位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">long</span> currentFrameTimeNanos=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Choreographer.getInstance().postFrameCallback(SMFrameCallback.getInstance());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SMFrameCallback <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sInstance = <span class="keyword">new</span> SMFrameCallback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lastFrameTimeNanos==<span class="number">0</span>)&#123;</span><br><span class="line">            lastFrameTimeNanos=frameTimeNanos;</span><br><span class="line">            Choreographer.getInstance().postFrameCallback(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        currentFrameTimeNanos=frameTimeNanos;</span><br><span class="line">        <span class="keyword">float</span> value=(currentFrameTimeNanos-lastFrameTimeNanos)/<span class="number">1000000.0f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> skipFrameCount = skipFrameCount(lastFrameTimeNanos, currentFrameTimeNanos, deviceRefreshRateMs);</span><br><span class="line">        Log.e(TAG,<span class="string">"两次绘制时间间隔value="</span>+value+<span class="string">"  frameTimeNanos="</span>+frameTimeNanos+<span class="string">"  currentFrameTimeNanos="</span>+currentFrameTimeNanos+<span class="string">"  skipFrameCount="</span>+skipFrameCount+<span class="string">""</span>);</span><br><span class="line">        lastFrameTimeNanos=currentFrameTimeNanos;</span><br><span class="line">        Choreographer.getInstance().postFrameCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *计算跳过多少帧</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> devicefreshRate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">int</span> <span class="title">skipFrameCount</span><span class="params">(<span class="keyword">long</span> start,<span class="keyword">long</span> end,<span class="keyword">float</span> devicefreshRate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> diffNs=end-start;</span><br><span class="line">        <span class="keyword">long</span> diffMs = Math.round(diffNs / <span class="number">1000000.0f</span>);</span><br><span class="line">        <span class="keyword">long</span> dev=Math.round(devicefreshRate);</span><br><span class="line">        <span class="keyword">if</span>(diffMs&gt;dev)&#123;</span><br><span class="line">            <span class="keyword">long</span> skipCount=diffMs/dev;</span><br><span class="line">            count=(<span class="keyword">int</span>)skipCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有跳帧的时候输出的日志是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">02-07 20:21:53.909 9530-9530/zhangwan.wj.com.choreographertest E/SMFrameCallback: 两次绘制时间间隔value=16.666666  frameTimeNanos=7177466379568  currentFrameTimeNanos=7177466379568  skipFrameCount=0</span><br><span class="line">02-07 20:21:53.925 9530-9530/zhangwan.wj.com.choreographertest E/SMFrameCallback: 两次绘制时间间隔value=16.666666  frameTimeNanos=7177483046234  currentFrameTimeNanos=7177483046234  skipFrameCount=0</span><br><span class="line">02-07 20:21:54.133 9530-9530/zhangwan.wj.com.choreographertest E/SMFrameCallback: 两次绘制时间间隔value=200.0  frameTimeNanos=7177683046226  currentFrameTimeNanos=7177683046226  skipFrameCount=11</span><br><span class="line">02-07 20:21:54.745 9530-9530/zhangwan.wj.com.choreographertest E/SMFrameCallback: 两次绘制时间间隔value=616.6666  frameTimeNanos=7178299712868  currentFrameTimeNanos=7178299712868  skipFrameCount=36</span><br><span class="line">02-07 20:21:54.757 9530-9530/zhangwan.wj.com.choreographertest E/SMFrameCallback: 两次绘制时间间隔value=16.666666  frameTimeNanos=7178316379534  currentFrameTimeNanos=7178316379534  skipFrameCount=0</span><br><span class="line">02-07 20:21:54.773 9530-9530/zhangwan.wj.com.choreographertest E/SMFrameCallback: 两次绘制时间间隔value=16.666666  frameTimeNanos=7178333046200  currentFrameTimeNanos=7178333046200  skipFrameCount=0</span><br><span class="line">02-07 20:21:54.789 9530-9530/zhangwan.wj.com.choreographertest E/SMFrameCallback: 两次绘制时间间隔value=16.666666  frameTimeNanos=7178349712866  currentFrameTimeNanos=7178349712866  skipFrameCount=0</span><br></pre></td></tr></table></figure>
<p>看到两次绘制的时间间隔相差616.6666毫秒，跳过了36帧，这个卡顿用户是能够明显感知的。</p>
<h1 id="参考-amp-扩展"><a href="#参考-amp-扩展" class="headerlink" title="参考&amp;扩展"></a>参考&amp;扩展</h1><ul>
<li><a href="https://www.jianshu.com/p/d126640eccb1" target="_blank" rel="noopener">Android性能优化第（十 一）篇—卡顿分析，正确评测流畅度</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/17/java基础/Timer设计缺陷分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/17/java基础/Timer设计缺陷分析/" itemprop="url">Timer设计缺陷分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-17T14:41:53+08:00">
                2019-07-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>APP模块中使用Timer需要实现一个10秒一次的心跳</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mHeartBeatTimer = <span class="keyword">new</span> Timer();</span><br><span class="line">mHeartBeatTimerTask = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//直接在Timer线程进行API请求，未开启线程</span></span><br><span class="line"> 		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			ExceptionUtil.handle(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">mHeartBeatTimer.schedule(mHeartBeatTimerTask, <span class="number">0</span>, <span class="number">10</span> * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>上线后发现存在心跳丢失问题。</p>
<p>排查bugly发现没有任何异常和崩溃，初步怀疑是Timer的问题。</p>
<h1 id="Timer缺陷"><a href="#Timer缺陷" class="headerlink" title="Timer缺陷"></a>Timer缺陷</h1><p>下面来自《Java并发编程实战》：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.Timer在执行所有定时任务时只会创建一个线程。</span><br><span class="line">	如果某个任务的执行时间长度大于其周期时间长度，那么就会导致这一次的任务还在执行，而下一个周期的任务已经需要开始执行了，</span><br><span class="line">	当然在一个线程内这两个任务只能顺序执行，有两种情况：对于之前需要执行但还没有执行的任务，</span><br><span class="line">		scheduleAtFixedRate，任务快速调用。当前任务执行完马上执行那些任务（按顺序来），</span><br><span class="line">		schedule，任务丢失。干脆把那些任务丢掉，不去执行它们。</span><br><span class="line">2.如果TimerTask抛出了一个未检出的异常，那么Timer线程就会被终止掉，</span><br><span class="line">之前已经被调度但尚未执行的TimerTask就不会再执行了，新的任务也不能被调度了。</span><br></pre></td></tr></table></figure>
<h1 id="Timer源码分析"><a href="#Timer源码分析" class="headerlink" title="Timer源码分析"></a>Timer源码分析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line">	<span class="comment">//任务队列。</span></span><br><span class="line">	<span class="comment">//内部是一个数组，按任务执行时间排序</span></span><br><span class="line">	<span class="comment">//存放Timer的TimerTask；Timer生产，TimerThread消费</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> TaskQueue queue = <span class="keyword">new</span> TaskQueue();</span><br><span class="line">	<span class="comment">//Thread子类。run()中死循环 检查和执行 任务队列的任务</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> TimerThread thread = <span class="keyword">new</span> TimerThread(queue);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造方法。设置线程名称和Daemon，开启线程</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Timer</span><span class="params">(String name, <span class="keyword">boolean</span> isDaemon)</span> </span>&#123;</span><br><span class="line">        thread.setName(name);</span><br><span class="line">        thread.setDaemon(isDaemon);</span><br><span class="line">        thread.start();<span class="comment">//开启</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(TimerTask task, Date firstTime, <span class="keyword">long</span> period)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//period设置为负值</span></span><br><span class="line">        sched(task, firstTime.getTime(), -period);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleAtFixedRate</span><span class="params">(TimerTask task, Date firstTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">long</span> period)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Non-positive period."</span>);</span><br><span class="line">        sched(task, firstTime.getTime(), period);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sched</span><span class="params">(TimerTask task, <span class="keyword">long</span> time, <span class="keyword">long</span> period)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (time &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal execution time."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 限制period最大值</span></span><br><span class="line">        <span class="keyword">if</span> (Math.abs(period) &gt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>))</span><br><span class="line">            period &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!thread.newTasksMayBeScheduled)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Timer already cancelled."</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//设置task属性</span></span><br><span class="line">            <span class="keyword">synchronized</span>(task.lock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (task.state != TimerTask.VIRGIN)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                        <span class="string">"Task already scheduled or cancelled"</span>);</span><br><span class="line">                task.nextExecutionTime = time;</span><br><span class="line">                task.period = period;</span><br><span class="line">                task.state = TimerTask.SCHEDULED;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//将task加入队列</span></span><br><span class="line">            queue.add(task);</span><br><span class="line">            <span class="keyword">if</span> (queue.getMin() == task)</span><br><span class="line">                queue.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="comment">//用来标识是否可以添加新任务</span></span><br><span class="line">    <span class="keyword">boolean</span> newTasksMayBeScheduled = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> TaskQueue queue;</span><br><span class="line"></span><br><span class="line">    TimerThread(TaskQueue queue) &#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mainLoop();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Someone killed this Thread, behave as if Timer cancelled</span></span><br><span class="line">            <span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">                newTasksMayBeScheduled = <span class="keyword">false</span>;</span><br><span class="line">                queue.clear();  <span class="comment">// Eliminate obsolete references</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mainLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimerTask task;</span><br><span class="line">                <span class="keyword">boolean</span> taskFired;<span class="comment">//任务是否过期(执行时间&lt;=现在时间)</span></span><br><span class="line">                <span class="keyword">synchronized</span>(queue) &#123;</span><br><span class="line">                    <span class="comment">// 死循环，等待任务队列非空</span></span><br><span class="line">                    <span class="keyword">while</span> (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)</span><br><span class="line">                        queue.wait();</span><br><span class="line">                    <span class="keyword">if</span> (queue.isEmpty())</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// 任务队列为空，且不可添加新任务，结束TimerThread线程</span></span><br><span class="line">                    <span class="comment">// 任务队列非空，检查和执行第一个任务</span></span><br><span class="line">                    <span class="keyword">long</span> currentTime, executionTime;</span><br><span class="line">                    task = queue.getMin();</span><br><span class="line">                    <span class="keyword">synchronized</span>(task.lock) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (task.state == TimerTask.CANCELLED) &#123;</span><br><span class="line">                            queue.removeMin();</span><br><span class="line">                            <span class="keyword">continue</span>;  <span class="comment">// 该任务已取消，直接从队列中移除，等待下一任务</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        currentTime = System.currentTimeMillis();</span><br><span class="line">                        executionTime = task.nextExecutionTime;</span><br><span class="line">                        <span class="comment">//任务已过期</span></span><br><span class="line">                        <span class="keyword">if</span> (taskFired = (executionTime&lt;=currentTime)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (task.period == <span class="number">0</span>) &#123; <span class="comment">// 不需要重复执行，直接移除</span></span><br><span class="line">                                queue.removeMin();</span><br><span class="line">                                task.state = TimerTask.EXECUTED;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 需要重复执行，修改task下一次执行时间，并刷新任务队列排序</span></span><br><span class="line">                                queue.rescheduleMin(</span><br><span class="line">                                  task.period&lt;<span class="number">0</span> ? currentTime - task.period</span><br><span class="line">                                                : executionTime + task.period);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!taskFired) <span class="comment">// Task hasn't yet fired; wait</span></span><br><span class="line">                        queue.wait(executionTime - currentTime);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (taskFired)  <span class="comment">// 任务已过期，立即执行</span></span><br><span class="line">                    task.run();</span><br><span class="line">            &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;<span class="comment">//捕获异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Timer在执行定时任务时只创建一个线程，如果任务耗时超过了两个任务的间隔时间，会发生一些缺陷<ul>
<li>schedule <strong>Timer任务丢失</strong>    <ul>
<li>period&lt;0，下一次执行时间 = currentTime - task.period；</li>
<li>任务被重置。从现在开始，period周期间隔后执行一次任务。</li>
<li>那么之前预想在period这个间隔内存在的任务执行就没了，也就是 <strong>任务丢失</strong> 问题</li>
</ul>
</li>
<li>scheduleAtFixedRate <strong>Timer任务快速调用</strong><ul>
<li>period&gt;0，下一次执行时间 = executionTime + task.period；</li>
<li>下一次任务还是按原来的算。从原来应该的执行时间开始，period周期间隔后执行一次任务。</li>
<li>如果这时executionTime + task.period还先于currentTime，那么下一个任务就会马上执行，也就是 <strong>任务快速调用</strong> 问题。</li>
</ul>
</li>
</ul>
</li>
<li><p>TimerTask异常导致 <strong>Timer线程异常结束</strong></p>
<ul>
<li>TimerThread run方法的死循环只捕获了 <strong>InterruptedException</strong>  异常<ul>
<li>当前线程可以被中断，被操作系统挂到一边休息，然后又回来继续执行</li>
<li>其它异常，那么整个循环就挂掉，导致线程结束</li>
</ul>
</li>
</ul>
</li>
<li><p>Timer执行周期任务时 <strong>依赖系统时间</strong> ,修改系统时间容易导致任务被挂起（如果当前时间小于执行时间）</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用Timer实现定时发心跳包可能会有问题</p>
<p>如果Timer线程在执行过程中被中断了，那么调用schedule的就很有可能导致心跳包没有发出去，而调用scheduleAtFixedRate的又可能会导致Timer线程没有占用CPU时心跳包没发出去，某一时刻又快速地发送好几个心跳包。</p>
<p>因此在Android中如果需要一个严格准时的定时操作，一般使用 <strong>AlarmManager</strong> 实现。</p>
<h1 id="参考-amp-扩展"><a href="#参考-amp-扩展" class="headerlink" title="参考&amp;扩展"></a>参考&amp;扩展</h1><ul>
<li><a href="https://blog.csdn.net/u012619640/article/details/50749715" target="_blank" rel="noopener">Java中的Timer源码分析及缺陷</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/10/Android/View.post不靠谱/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/10/Android/View.post不靠谱/" itemprop="url">View.post不靠谱</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-10T18:36:53+08:00">
                2019-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>有时候，我们会用 View.post() 方法，来将一个 Runnable 发送到主线程去执行。这一切，看似很美好，它最终会通过一个 Handler.post() 方法去执行，又避免我们重新定义一个 Handler 对象。</p>
<p>但是，在 Android 7.0（Api level 24） 上，View.post() 将不再那么靠谱了，你post() 出去的 Runnable ，可能永远也不会有机会得到执行。</p>
<h1 id="post-在-7-0-的差异"><a href="#post-在-7-0-的差异" class="headerlink" title="post 在 7.0 的差异"></a>post 在 7.0 的差异</h1><p>在 Api23 及以下，<code>executeAction()</code> 是会被<strong>循环调用</strong>（一个 VSync 的间隔），基本上其内的 mActions 中，只要有未执行的 Runnable 立刻就会被消费掉</p>
<p>在 Api24 及以上，<code>executeActions()</code> 只在 <code>dispatchAttachedToWindow()</code> 中才有机会被<strong>调用一次</strong>，而 <code>View.dispatchAttachedToWindow()</code> 只有在这个 View 通过 addView() 方法，或者原本写在页面布局的 xml 中（实际上也是调用的 addView()），加入到一个 ViewGroup 的时候，才会被调用到</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>View.post() 方法，在不同版本的差异，根本原因还是在于 Api23 和 Api24 中，<code>executeActions()</code> 方法的调用时机不同，导致 View 在没有 mAttachInfo 对象的时候，表现不一样了。</p>
<p>所以我们在使用的过程中需要慎用，区分出实际使用的场景，一般规范自己的代码即可：</p>
<ul>
<li>动态创建的 View ，如果视条件去决定是否加入到根布局中，则不要使用它来调用 post() 方法。</li>
<li>尽量避免使用 View.post() 方法，可以直接使用 Handler.post() 方法来替代。</li>
</ul>
<h1 id="参考-amp-扩展"><a href="#参考-amp-扩展" class="headerlink" title="参考&amp;扩展"></a>参考&amp;扩展</h1><ul>
<li><a href="https://www.cnblogs.com/plokmju/p/7481727.html" target="_blank" rel="noopener">View.post() 不靠谱的地方你知道吗？</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/10/Android/View 的可见性检查/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/10/Android/View 的可见性检查/" itemprop="url">View 的可见性检查</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-10T18:24:53+08:00">
                2019-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="/2019/07/10/Android/View%20的可见性检查/visibility.png">
<p>四种方法获取的结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">View5.getVisibility() = View.VISIBLE;</span><br><span class="line">View5.isShown() = <span class="keyword">true</span>; </span><br><span class="line">View5.getGlobalVisibleRect() = <span class="keyword">false</span>;</span><br><span class="line">View5.getLocalVisibleRect() =  <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<h1 id="View-getVisibility"><a href="#View-getVisibility" class="headerlink" title="View.getVisibility()"></a>View.getVisibility()</h1><p>最基本的检查View可见性的方法</p>
<p>如果这个方法返回的是View.INVISIBLE或者View.GONE，那么这个View肯定是对用户不可见的。</p>
<h1 id="View-isShown"><a href="#View-isShown" class="headerlink" title="View.isShown()"></a>View.isShown()</h1><ul>
<li>递归</li>
<li>检查View以及它的parentView的Visibility == View.VISIBLE，</li>
<li>检查parentView == null<ul>
<li>也就是说所有的parentView都不能为null。否则就说明这个View根本没有被addView过</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the visibility of this view and all of its ancestors</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> True if this view and all of its ancestors are &#123;<span class="doctag">@link</span> #VISIBLE&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    View current = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//noinspection ConstantConditions</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((current.mViewFlags &amp; VISIBILITY_MASK) != VISIBLE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ViewParent parent = current.mParent;</span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// We are not attached to the view root</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(parent <span class="keyword">instanceof</span> View)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current = (View) parent;</span><br><span class="line">    &#125; <span class="keyword">while</span> (current != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="View-getGlobalVisibleRect"><a href="#View-getGlobalVisibleRect" class="headerlink" title="View.getGlobalVisibleRect()"></a>View.getGlobalVisibleRect()</h1><p>返回一个View是否可见的boolean值，同时还会将该View的可见区域left，top，right，bottom值保存在一个rect对象中</p>
<p>获得的rect坐标系的原点是屏幕的左上角</p>
<p>调用的是<code>getGlobalVisibleRect(Rect r, Point globalOffset)</code></p>
<h1 id="View-getLocalVisibleRect"><a href="#View-getLocalVisibleRect" class="headerlink" title="View.getLocalVisibleRect()"></a>View.getLocalVisibleRect()</h1><p>获得的rect坐标系的原点是View自己的左上角</p>
<p>其也会调用<code>getGlobalVisibleRect()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">getLocalVisibleRect</span><span class="params">(Rect r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Point offset = mAttachInfo != <span class="keyword">null</span> ? mAttachInfo.mPoint : <span class="keyword">new</span> Point();</span><br><span class="line">    <span class="keyword">if</span> (getGlobalVisibleRect(r, offset)) &#123;</span><br><span class="line">        r.offset(-offset.x, -offset.y); <span class="comment">// make r local</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>先获取View的offset point（相对屏幕或者ParentView的偏移坐标），</li>
<li>再调用getGlobalVisibleRect(Rect r, Point globalOffset)方法来获取可见区域</li>
<li>最后再把得到的GlobalVisibleRect和Offset坐标做一个加减法，转换坐标系原点</li>
</ul>
<p>View在屏幕中全部不可见时(图中view5)，两者的visibility都为false，且两者获取的rect值相同。由源码可以知道，getLocalVisibleRect()最终调用的是getGlobalVisibleRect()方法，并会减去View自身的便偏移坐标offset point，但只有当View可见时才会减去这个偏移坐标，要是不可见就直接返回了，所以此时两者获取出的rect值是相同的</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul>
<li><code>getGlobalVisibleRect()</code> <code>getLocalVisibleRect()</code>判断View的可见性时，一定要等View绘制完成后，再去调用这两个方法，否则无法得到对的结果，返回值的rect值都是0，visibility为false。这和获取View的宽高原理是一样的，如果View没有被绘制完成，那么View.getWidth和View.getHeight一定是等于0的</li>
<li><code>getGlobalVisibleRect()</code>只能检查出这个View在手机屏幕（或者说是相对它的父View）的位置，而不能检查出与其他兄弟View的相对位置:<br>比如有一个ViewGroup，下面有View1、View2这两个子View，View1和View2是平级关系。此时如果View2盖住了View1，那么用getGlobalVisibleRect方法检查View1的可见性，得到的返回值依然是true，得到的可见矩形区域rect也是没有任何变化的。</li>
</ul>
<h1 id="参考-amp-扩展"><a href="#参考-amp-扩展" class="headerlink" title="参考&amp;扩展"></a>参考&amp;扩展</h1><ul>
<li><a href="https://www.jianshu.com/p/30b0ae304518" target="_blank" rel="noopener">View 的可见性检查还可以这样</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/04/Android/setVisibility不起作用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/04/Android/setVisibility不起作用/" itemprop="url">setVisibility不起作用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-04T17:40:53+08:00">
                2019-07-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="控件本身正在执行动画"><a href="#控件本身正在执行动画" class="headerlink" title="控件本身正在执行动画"></a>控件本身正在执行动画</h1><p>解决方案：view.clearAnimation()</p>
<h1 id="控件还在使用当中"><a href="#控件还在使用当中" class="headerlink" title="控件还在使用当中"></a>控件还在使用当中</h1><p>比如设置点击某个ViewGroup的子View后，让改ViewGroup 消失。就极有可能导致setVisibility 无效</p>
<p>解决方案：利用Handler.post()发送 setVisibility任务</p>
<h1 id="设备性能问题"><a href="#设备性能问题" class="headerlink" title="设备性能问题"></a>设备性能问题</h1><p>方案一：</p>
<p>利用Handler.post()发送 setVisibility任务</p>
<p>这个方法同样适用于<strong>动画不生效等其他UI异常</strong></p>
<p>方案二：重新加载，即重新构造。</p>
<p>setVisibility 后 调用view.invalidate()或者view.postinvalidate()；</p>
<p>如果也不行，直接调用自身的requestLayout或者其父容器的requestLayout()进行强制的界面即时刷新重构;</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/31/">31</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="风" />
            
              <p class="site-author-name" itemprop="name">风</p>
              <p class="site-description motion-element" itemprop="description">随心而动，随刃而行</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">308</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">71</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">风</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
