<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="随心而动，随刃而行">
<meta property="og:type" content="website">
<meta property="og:title" content="风">
<meta property="og:url" content="http://yoursite.com/page/9/index.html">
<meta property="og:site_name" content="风">
<meta property="og:description" content="随心而动，随刃而行">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="风">
<meta name="twitter:description" content="随心而动，随刃而行">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/9/"/>





  <title>风</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">风</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">技术博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/03/直播/音频/PCM音频降噪/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/03/直播/音频/PCM音频降噪/" itemprop="url">PCM音频降噪</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-03T14:52:14+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/直播/" itemprop="url" rel="index">
                    <span itemprop="name">直播</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.jianshu.com/p/77a363960711" target="_blank" rel="noopener">PCM音频处理</a></p>
<p>对于降噪前后的对比，从三个方面进行评价：<strong>时域，频域，个人听觉感受</strong>。</p>
<p>音频处理软件：<strong>Audacity</strong>（简单分析降噪效果）</p>
<h1 id="Speex音频降噪模块"><a href="#Speex音频降噪模块" class="headerlink" title="Speex音频降噪模块"></a>Speex音频降噪模块</h1><p>Speex是很强大的开源编解码库，也包含一些降噪，自动增益，回音消除等模块功能</p>
<p>Opus是Speex的更优替代方案，但是Opus没有降噪去噪模块</p>
<p>支持的采样率有3种：<strong>8K，16K，44K</strong></p>
<p>采样送进去降噪的数据需要控制在<strong>20ms</strong>，也就是（20*采样率/1000）个采样点。</p>
<p>Speex的降噪原理：设置音频数据的阀值，过滤掉低于阀值分贝的声音</p>
<ul>
<li>优点：简单，使用Speex编解码库时可以直接使用</li>
<li>缺点：会把声音细节抹掉</li>
<li>效果：<ul>
<li>时域，效果不明显</li>
<li>频域，效果不明显</li>
<li>实际听的效果，降噪后，背景的沙沙声有所减弱，但是总体效果还是不佳</li>
</ul>
</li>
</ul>
<h1 id="WebRTC音频降噪模块"><a href="#WebRTC音频降噪模块" class="headerlink" title="WebRTC音频降噪模块"></a>WebRTC音频降噪模块</h1><p>谷歌出品，必属精品</p>
<p>webrtc的音频处理模块分为降噪ns和nsx，回音消除aec，回声控制acem，音频增益agc，静音检测部分</p>
<p>支持三种采样率，<strong>8K，16K和32K</strong>，如果超过32K，则需要重采样成符合要求的采样率</p>
<p>采样送进去降噪的数据需要控制在<strong>10ms</strong>，也就是（10*采样率/1000）个采样点。</p>
<pre><code>根据前辈的说法
    32K数据需要使用滤波函数将音频数据分为高频和低频两个部分进行降噪，降噪后再合并为降噪后数据
    8K和16K数据，不需要分为高频低频这个步骤，作为低频数据输入，输出也是通过低频数据返回
</code></pre><ul>
<li>效果：<ul>
<li>时域，音量较低的数据基本被抹平，但是不影响波形清晰</li>
<li>频域，频率峰值明显加强，1500Hz到3500Hz区域，能量普遍下降</li>
<li>实际听的效果的，降噪后，背景的沙沙声基本没有，但是音量也有所下降，直观感觉上比Speex好一些</li>
</ul>
</li>
</ul>
<h1 id="根据PCM文件的音量进行阀值限制"><a href="#根据PCM文件的音量进行阀值限制" class="headerlink" title="根据PCM文件的音量进行阀值限制"></a>根据PCM文件的音量进行阀值限制</h1><p>以二进制方式打开，PCM数据其实就是音量数据</p>
<p>如果把音量小的声音默认为噪声，则可以通过把音量小的数值替换为0，来实现降噪。但是这个方法的缺点也是明显的，会把很多的比较小的细节声音直接去掉了。</p>
<p><strong>音量计算公式dB = 20×log(data)</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/03/直播/音频/android录音和播放/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/03/直播/音频/android录音和播放/" itemprop="url">android录音和播放</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-03T14:52:14+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/直播/" itemprop="url" rel="index">
                    <span itemprop="name">直播</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="录音"><a href="#录音" class="headerlink" title="录音"></a>录音</h1><p> 必须在AndroidManifest中设置相应的权限：android:name=”android.permission.RECORD_AUDIO” </p>
<p> Android提供了两个API用于实现录音功能</p>
<h2 id="AudioRecord"><a href="#AudioRecord" class="headerlink" title="AudioRecord"></a>AudioRecord</h2><pre><code>主要是实现边录边播（AudioRecord+AudioTrack）以及对音频的实时处理（如会说话的汤姆猫、语音）
优点：语音的实时处理，可以用代码实现各种音频的封装
缺点：输出是PCM语音数据，如果保存成音频文件，是不能够被播放器播放的，所以必须先写代码实现数据编码以及压缩
示例：使用AudioRecord类录音，并实现WAV格式封装。录音20s，输出的音频文件大概为3.5M左右（已写测试代码）
    主要api：audioRecord.startRecording()，audioRecord.read，audioRecord.stop()，audioRecord.release()
    开始录制
    int sampleRateInHz= 44100;  //44.1KHz,普遍使用的频率   
    int channelConfig = AudioFormat.CHANNEL_IN_STEREO;
    int audioFormat = AudioFormat.ENCODING_PCM_16BIT;
     // 获得缓冲区字节大小  
    int bufferSizeInBytes = AudioRecord.getMinBufferSize(sampleRateInHz, channelConfig, audioFormat);
    int audioSource = MediaRecorder.AudioSource.MIC;
    // 创建AudioRecord对象  
    audioRecord = new AudioRecord(audioSource, sampleRateInHz, channelConfig, audioFormat, bufferSizeInBytes);
    audioRecord.startRecording();
    // 开启线程将音频流写入文件  
    new Thread(new AudioRecordThread()).start();  

    class AudioRecordThread implements Runnable {  
        @Override 
        public void run() {  
            writeDateTOFile();//往文件中写入裸数据  
            copyWaveFile(AudioName, NewAudioName);//给裸数据加上头文件  
        }  
    } 
    private void writeDateTOFile() {  
        // new一个byte数组用来存一些字节数据，大小为前面获得的缓冲区大小  
        byte[] audiodata = new byte[bufferSizeInBytes];  
        FileOutputStream fos = null;  
        int readsize = 0;  
        try {  
            File file = new File(AudioName);  //AudioName为sd卡根目录下test.raw
            if (file.exists()) {  
                file.delete();  
            }  
            fos = new FileOutputStream(file);// 建立一个可存取字节的文件  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
        while (isRecord == true) {  
            readsize = audioRecord.read(audiodata, 0, bufferSizeInBytes);  
            if (AudioRecord.ERROR_INVALID_OPERATION != readsize &amp;&amp; fos != null) {  
                try {  
                    fos.write(audiodata);  
                } catch (IOException e) {  
                    e.printStackTrace();  
                }  
            }  
        }  
        try {
            if(fos != null)
                fos.close();// 关闭写入流  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    } 
    private void copyWaveFile(String inFilename, String outFilename) {  
        FileInputStream in = null;  
        FileOutputStream out = null;  
        long totalAudioLen = 0;  
        long totalDataLen = totalAudioLen + 36;  //wave头44字节，36实在不懂
        long longSampleRate = sampleRateInHz;  //上面的44100
        int channels = 2;  
        long byteRate = 16 * sampleRateInHz * channels / 8;  
        byte[] data = new byte[bufferSizeInBytes];  
        try {  
            in = new FileInputStream(inFilename);  
            out = new FileOutputStream(outFilename);  
            totalAudioLen = in.getChannel().size();  
            totalDataLen = totalAudioLen + 36;  
            WriteWaveFileHeader(out, totalAudioLen, totalDataLen,  
                    longSampleRate, channels, byteRate);  
            while (in.read(data) != -1) {  
                out.write(data);  
            }  
            in.close();  
            out.close();  
        } catch (FileNotFoundException e) {  
            e.printStackTrace();  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
    private void WriteWaveFileHeader(FileOutputStream out, long totalAudioLen,  
        long totalDataLen, long longSampleRate, int channels, long byteRate)  
        throws IOException {  
        byte[] header = new byte[44];  //wave文件头44字节
        header[0] = &apos;R&apos;; // RIFF/WAVE header  
        header[1] = &apos;I&apos;;  
        header[2] = &apos;F&apos;;  
        header[3] = &apos;F&apos;;  
        header[4] = (byte) (totalDataLen &amp; 0xff);  
        header[5] = (byte) ((totalDataLen &gt;&gt; 8) &amp; 0xff);  
        header[6] = (byte) ((totalDataLen &gt;&gt; 16) &amp; 0xff);  
        header[7] = (byte) ((totalDataLen &gt;&gt; 24) &amp; 0xff);  
        header[8] = &apos;W&apos;;  
        header[9] = &apos;A&apos;;  
        header[10] = &apos;V&apos;;  
        header[11] = &apos;E&apos;;  
        header[12] = &apos;f&apos;; // &apos;fmt &apos; chunk  
        header[13] = &apos;m&apos;;  
        header[14] = &apos;t&apos;;  
        header[15] = &apos; &apos;;  
        header[16] = 16; // 4 bytes: size of &apos;fmt &apos; chunk  
        header[17] = 0;  
        header[18] = 0;  
        header[19] = 0;  
        header[20] = 1; // format = 1  
        header[21] = 0;  
        header[22] = (byte) channels;  
        header[23] = 0;  
        header[24] = (byte) (longSampleRate &amp; 0xff);  
        header[25] = (byte) ((longSampleRate &gt;&gt; 8) &amp; 0xff);  
        header[26] = (byte) ((longSampleRate &gt;&gt; 16) &amp; 0xff);  
        header[27] = (byte) ((longSampleRate &gt;&gt; 24) &amp; 0xff);  
        header[28] = (byte) (byteRate &amp; 0xff);  
        header[29] = (byte) ((byteRate &gt;&gt; 8) &amp; 0xff);  
        header[30] = (byte) ((byteRate &gt;&gt; 16) &amp; 0xff);  
        header[31] = (byte) ((byteRate &gt;&gt; 24) &amp; 0xff);  
        header[32] = (byte) (2 * 16 / 8); // block align  
        header[33] = 0;  
        header[34] = 16; // bits per sample  
        header[35] = 0;  
        header[36] = &apos;d&apos;;  
        header[37] = &apos;a&apos;;  
        header[38] = &apos;t&apos;;  
        header[39] = &apos;a&apos;;  
        header[40] = (byte) (totalAudioLen &amp; 0xff);  
        header[41] = (byte) ((totalAudioLen &gt;&gt; 8) &amp; 0xff);  
        header[42] = (byte) ((totalAudioLen &gt;&gt; 16) &amp; 0xff);  
        header[43] = (byte) ((totalAudioLen &gt;&gt; 24) &amp; 0xff);  
        out.write(header, 0, 44);  
    } 
    停止录制
    audioRecord.stop();  
    audioRecord.release();//释放资源  
    audioRecord = null;  
</code></pre><h2 id="MediaRecorder"><a href="#MediaRecorder" class="headerlink" title="MediaRecorder"></a>MediaRecorder</h2><pre><code>已经集成了录音、录像、编码、压缩等，支持少量的录音音频格式，大概有.aac（API = 16以上） .amr .3gp
优点：大部分已经集成，直接调用相关接口即可，代码量小
缺点：无法实时处理音频；输出的音频格式不是很多，例如没有输出mp3格式文件
示例：使用MediaRecorder类录音，输出amr格式文件。录音20s，输出的音频文件大概为33K（已写测试代码）
    开始录制
    mRecorder = new MediaRecorder();
    mRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);
    mRecorder.setOutputFormat(MediaRecorder.OutputFormat.DEFAULT);//Android默认就是amr
    mRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.DEFAULT);
    mRecorder.setOutputFile(outputFilePath);
    try {
        mRecorder.prepare();
    } catch (Exception e) {
        e.printStackTrace();
    } 
    mRecorder.start();
    停止录制
    mRecorder.stop();
    mRecorder.release();
    mRecorder = null;

    开始播放
    mPlayer = new MediaPlayer();
    try {
        mPlayer.setDataSource(fileName);
        mPlayer.prepare();
        mPlayer.start();
    } catch (IOException e) {
        e.printStackTrace();
    }
    停止播放
    mPlayer.stop();
    mPlayer.release();
    mPlayer = null;
</code></pre><h1 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h1><h2 id="MediaPlayer音频视频播放"><a href="#MediaPlayer音频视频播放" class="headerlink" title="MediaPlayer音频视频播放"></a>MediaPlayer音频视频播放</h2><p>MediaPlayer支持：AAC、AMR、FLAC、MP3、MIDI、OGG、PCM、WAV等格式 </p>
<p>资源占用量较高、延迟时间较长、不支持多个音频同时播放等</p>
<h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><pre><code>public void startPlay(String fileName) {
    mPlayer = new MediaPlayer();
    try {
        mPlayer.setDataSource(fileName);
        mPlayer.prepare();
        mPlayer.start();
    } catch (IOException e) {
        e.printStackTrace();
    }
}

public void stopPlay() {
    mPlayer.stop();
    mPlayer.release();
    mPlayer = null;
}
</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>MediaPlayer 的使用介绍（翻译官方文档，详细） http://blog.csdn.net/songshizhuyuan/article/details/32900965
</code></pre><h4 id="MediaPlayer"><a href="#MediaPlayer" class="headerlink" title="MediaPlayer"></a>MediaPlayer</h4><pre><code>这个类包含用于播放声音和视频的主要API
</code></pre><p>Raw下的元数据</p>
<pre><code>//直接创建，不需要设置setDataSource
mMediaPlayer=MediaPlayer.create(this, R.raw.audio);
mMediaPlayer.start();
</code></pre><h4 id="AudioManager"><a href="#AudioManager" class="headerlink" title="AudioManager"></a>AudioManager</h4><pre><code>这个类用于管理音源，并在设备上的音频输出。
</code></pre><h4 id="处理音频焦点"><a href="#处理音频焦点" class="headerlink" title="处理音频焦点"></a>处理音频焦点</h4><p>音频焦点是合作性。也就是说，应用程序应该尽量配合，以符合音频焦点的指引，但规则不是由系统执行。如果应用程序失去音讯焦点后，大声播放音乐，系统也不会阻止。</p>
<pre><code>http://blog.csdn.net/dadoneo/article/details/8252933
</code></pre><p>AudioFocus的申请与释放</p>
<p>安卓2.2(api8)开始 新增 <code>AudioManager.requestAudioFocus（）</code></p>
<p>AudioFocus被抢占与重新获得</p>
<pre><code>http://www.android100.org/html/201510/08/188724.html
</code></pre><h4 id="外放、听筒、耳机-模式切换"><a href="#外放、听筒、耳机-模式切换" class="headerlink" title="外放、听筒、耳机 模式切换"></a>外放、听筒、耳机 模式切换</h4><pre><code>AudioManager audioManager = (AudioManager) this.getSystemService(Context.AUDIO_SERVICE);
audioManager.setMicrophoneMute(false);
audioManager.setSpeakerphoneOn(true);//使用扬声器外放，即使已经插入耳机
audioManager.setMode(AudioManager.STREAM_MUSIC);
</code></pre><h2 id="SoundPool"><a href="#SoundPool" class="headerlink" title="SoundPool"></a>SoundPool</h2><p>支持多个音频文件同时播放(组合音频也是有上限的)，延时短，比较适合短促、密集的场景，是游戏开发中音效播放的福音。</p>
<p><code>SoundPool(int maxStreams, int streamType, int srcQuality)</code></p>
<p>区分2个概念</p>
<ol>
<li>soundID：加载音乐资源时的返回值，int load(String path, int priority),这个int返回值就是soundID </li>
<li>streamID：播放时返回的值，即play()方法的返回值</li>
</ol>
<p>这两个值都很重要，需要缓存下来</p>
<p>某些采样频率会导致播放错误(不能播放，只能播放部分)</p>
<h2 id="AsyncPlayer"><a href="#AsyncPlayer" class="headerlink" title="AsyncPlayer"></a>AsyncPlayer</h2><p>AsyncPlayer就是对MediaPlayer的一次简单的封装，对MediaPlaer所有的操作都在新开线程中执行。不影响调用线程任何操作。</p>
<p>AsyncPlayer只适合简单的异步播放，不能控制进度，只能开始或停止播放。如果再次调用play()方法，AsyncPlayer会停止当前播放，开始新的播放。</p>
<h2 id="AudioTrack播放音频"><a href="#AudioTrack播放音频" class="headerlink" title="AudioTrack播放音频"></a>AudioTrack播放音频</h2><p>AudioTrack属于更偏底层的音频播放，MediaPlayerService的内部就是使用了AudioTrack。</p>
<p>AudioTrack用于单个音频播放和管理，相比于MediaPlayer具有：精炼、高效的优点。</p>
<p>更适合实时产生播放数据的情况，如加密的音频，<br>MediaPlayer是束手无策的，AudioTrack却可以。</p>
<p>AudioTrack用于播放PCM(PCM无压缩的音频格式)音乐流的回放，<br>如果需要播放其它格式音频，需要响应的解码器，<br>这也是AudioTrack用的比较少的原因，需要自己解码音频。</p>
<h3 id="AudioTreack的2种播放模式"><a href="#AudioTreack的2种播放模式" class="headerlink" title="AudioTreack的2种播放模式"></a>AudioTreack的2种播放模式</h3><h4 id="静态模式—static"><a href="#静态模式—static" class="headerlink" title="静态模式—static"></a>静态模式—static</h4><p>数据一次性交付给接收方。好处是简单高效，只需要进行一次操作就完成了数据的传递;缺点当然也很明显，对于数据量较大的音频回放，显然它是无法胜任的，因而通常只用于播放铃声、系统提醒等对内存小的操作</p>
<h4 id="流模式streaming"><a href="#流模式streaming" class="headerlink" title="流模式streaming"></a>流模式streaming</h4><p>流模式和网络上播放视频是类似的，即数据是按照一定规律不断地传递给接收方的。理论上它可用于任何音频播放的场景，不过我们一般在以下情况下采用：</p>
<ul>
<li><p>音频文件过大</p>
</li>
<li><p>音频属性要求高，比如采样率高、深度大的数据</p>
</li>
<li><p>音频数据是实时产生的，这种情况就只能用流模式了</p>
</li>
</ul>
<p>通过write(byte[], int, int), write(short[], int, int)<br>write(float[], int, int, int)等方法推送解码数据到AudioTrack</p>
<h2 id="Ringtone和RingtoneManager"><a href="#Ringtone和RingtoneManager" class="headerlink" title="Ringtone和RingtoneManager"></a>Ringtone和RingtoneManager</h2><p>Ringtone为铃声、通知和其他类似声音提供快速播放的方法</p>
<p>RingtoneManager提供系统铃声列表检索方法，Ringtone实例需要从RingtoneManager获取</p>
<h3 id="RingtoneManager"><a href="#RingtoneManager" class="headerlink" title="RingtoneManager"></a>RingtoneManager</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="comment">// 两个构造方法</span></span><br><span class="line">RingtoneManager(Activity activity)</span><br><span class="line">RingtoneManager(Context context)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. <span class="comment">// 获取指定声音类型(铃声、通知、闹铃等)的默认声音的Uri</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Uri <span class="title">getDefaultUri</span><span class="params">(<span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">3. <span class="comment">// 获取系统所有Ringtone的cursor</span></span></span><br><span class="line"><span class="function">Cursor <span class="title">getCursor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">4. <span class="comment">// 获取cursor指定位置的Ringtone uri</span></span></span><br><span class="line"><span class="function">Uri <span class="title">getRingtoneUri</span><span class="params">(<span class="keyword">int</span> position)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">5. <span class="comment">// 判断指定Uri是否为默认铃声</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDefault</span><span class="params">(Uri ringtoneUri)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">6. <span class="comment">//获取指定uri的所属类型</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultType</span><span class="params">(Uri defaultRingtoneUri)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">7. <span class="comment">//将指定Uri设置为指定声音类型的默认声音</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setActualDefaultRingtoneUri</span><span class="params">(Context context, <span class="keyword">int</span> type, Uri ringtoneUri)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="JetPlayer播放音频"><a href="#JetPlayer播放音频" class="headerlink" title="JetPlayer播放音频"></a>JetPlayer播放音频</h2><p>用于播放 ”.jet”文件</p>
<p>JET常用于控制游戏的声音特效，采用MIDI（Musical Instrument Digital Interface）格式。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>对于延迟度要求不高，并且希望能够更全面的控制音乐的播放，MediaPlayer比较适合

声音短小，延迟度小，并且需要几种声音同时播放的场景，适合使用SoundPool

对于简单的播放，不需要复杂控制的播放，可以给使用AsyncPlayer，所有操作均在子线程不阻塞UI

播放大文件音乐，如WAV无损音频和PCM无压缩音频，可使用更底层的播放方式AudioTrack。它支持流式播放，可以读取(可来自本地和网络)音频流，却播放延迟较小。 
ps：据我测试AudioTrack直接支持WAV和PCM，其他音频需要解码成PCM格式才能播放。(其他无损格式没有尝试，有兴趣可以使本文提供的例子测试一下)

.jet的音频比较少见(有的游戏中在使用)，可使用专门的播放器JetPlayer播放

对于系统类声音的播放和操作，Ringtone更适合(RingtoneManager)
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/03/直播/音频/pcm 转 amr/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/03/直播/音频/pcm 转 amr/" itemprop="url">pcm 转 amr</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-03T14:52:14+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/直播/" itemprop="url" rel="index">
                    <span itemprop="name">直播</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.csdn.net/honeybaby201314/article/details/50379040" target="_blank" rel="noopener">pcm 转 amr</a></p>
<p><a href="https://www.zybuluo.com/DevWiki/note/115307" target="_blank" rel="noopener">Android中Pcm文件转Amr文件</a></p>
<p>Android系统自带的AmrInputStream类可以转换pcm到amr</p>
<h1 id="思路一、反射调用"><a href="#思路一、反射调用" class="headerlink" title="思路一、反射调用"></a>思路一、反射调用</h1><ul>
<li>通过Android系统自带的AmrInputStream类转换，因为它被隐藏了，只有通过反射来操作。</li>
<li>手动加上 <code>amr文件头</code>，<code>byte[] header = new byte[]{0x23, 0x21, 0x41, 0x4D, 0x52, 0x0A};</code></li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code> /**
 * 通过反射调用android系统自身AmrInputStream类进行转换
 * @param inPath 源文件
 * @param outPath 目标文件
 */
public void systemPcm2Amr(String inPath,String outPath){
    try {
        FileInputStream fileInputStream = new FileInputStream(inPath);
        FileOutputStream fileoutputStream = new FileOutputStream(outPath);
        // 获得Class
        Class&lt;?&gt; cls = Class.forName(&quot;android.media.AmrInputStream&quot;);
        // 通过Class获得所对应对象的方法
        Method[] methods = cls.getMethods();
        // 输出每个方法名
        byte[] header = new byte[]{0x23, 0x21, 0x41, 0x4D, 0x52, 0x0A};
        fileoutputStream.write(header);
        Constructor&lt;?&gt; con = cls.getConstructor(InputStream.class);
        Object obj = con.newInstance(fileInputStream);
        for (Method method : methods) {
            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();
            if (&quot;read&quot;.equals(method.getName())
                    &amp;&amp; parameterTypes.length == 3) {
                byte[] buf = new byte[1024];
                int len = 0;
                while ((len = (int) method.invoke(obj, buf, 0, 1024)) &gt; 0) {
                    fileoutputStream.write(buf, 0, len);
                }
                break;
            }
        }
        for (Method method : methods) {
            if (&quot;close&quot;.equals(method.getName())) {
                method.invoke(obj);
                break;
            }
        }
        fileoutputStream.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>查看源码可知，AmrInputStream 转码默认 PCM 的采样率是 8000 Hz，所以要<strong>保证录制时采样率是8000Hz</strong>，否则amr音频会有快放和慢放的效果</p>
<pre><code>public class AmrInputStream extends InputStream {      
    ... 
    // frame is 20 msec at 8.000 khz  
    private final static int SAMPLES_PER_FRAME = 8000 * 20 / 1000;  
</code></pre><p>在华为机型上，反射调用特别的慢，容易AR</p>
<h1 id="思路二、复制类文件到工程"><a href="#思路二、复制类文件到工程" class="headerlink" title="思路二、复制类文件到工程"></a>思路二、复制类文件到工程</h1><p>不用反射，更加高效</p>
<p>工程下新建包 <code>android.media</code>。因为调用Android自带的Pcm转amr的库:media_jni.so需要这个包名</p>
<p>复制AmrInputStream类到该包下</p>
<pre><code>public final class AmrInputStream extends InputStream {
    static {
        System.loadLibrary(&quot;media_jni&quot;);
    }
    private final static String TAG = &quot;AmrInputStream&quot;;
    // frame is 20 msec at 8.000 khz
    private final static int SAMPLES_PER_FRAME = 8000 * 20 / 1000;
    // pcm input stream
    private InputStream mInputStream;
    // native handle
    private int mGae;
    // result amr stream
    private byte[] mBuf = new byte[SAMPLES_PER_FRAME * 2];
    private int mBufIn = 0;
    private int mBufOut = 0;
    // helper for bytewise read()
    private byte[] mOneByte = new byte[1];
    /**
     * Create a new AmrInputStream, which converts 16 bit PCM to AMR
     * @param inputStream InputStream containing 16 bit PCM.
     */
    public AmrInputStream(InputStream inputStream) {
        mInputStream = inputStream;
        mGae = GsmAmrEncoderNew();
        GsmAmrEncoderInitialize(mGae);
    }
    @Override
    public int read() throws IOException {
        int rtn = read(mOneByte, 0, 1);
        return rtn == 1 ? (0xff &amp; mOneByte[0]) : -1;
    }
    @Override
    public int read(byte[] b) throws IOException {
        return read(b, 0, b.length);
    }
    @Override
    public int read(byte[] b, int offset, int length) throws IOException {
        if (mGae == 0) throw new IllegalStateException(&quot;not open&quot;);
        // local buffer of amr encoded audio empty
        if (mBufOut &gt;= mBufIn) {
            // reset the buffer
            mBufOut = 0;
            mBufIn = 0;
            // fetch a 20 msec frame of pcm
            for (int i = 0; i &lt; SAMPLES_PER_FRAME * 2; ) {
                int n = mInputStream.read(mBuf, i, SAMPLES_PER_FRAME * 2 - i);
                if (n == -1) return -1;
                i += n;
            }
            // encode it
            mBufIn = GsmAmrEncoderEncode(mGae, mBuf, 0, mBuf, 0);
        }
        // return encoded audio to user
        if (length &gt; mBufIn - mBufOut) length = mBufIn - mBufOut;
        System.arraycopy(mBuf, mBufOut, b, offset, length);
        mBufOut += length;
        return length;
    }
    @Override
    public void close() throws IOException {
        try {
            if (mInputStream != null) mInputStream.close();
        } finally {
            mInputStream = null;
            try {
                if (mGae != 0) GsmAmrEncoderCleanup(mGae);
            } finally {
                try {
                    if (mGae != 0) GsmAmrEncoderDelete(mGae);
                } finally {
                    mGae = 0;
                }
            }
        }
   }
    @Override
    protected void finalize() throws Throwable {
        if (mGae != 0) {
            close();
            throw new IllegalStateException(&quot;someone forgot to close AmrInputStream&quot;);
        }
    }
    //
    // AudioRecord JNI interface
    //
    private static native int GsmAmrEncoderNew();
    private static native void GsmAmrEncoderInitialize(int gae);
    private static native int GsmAmrEncoderEncode(int gae,
           byte[] pcm, int pcmOffset, byte[] amr, int amrOffset) throws IOException;
    private static native void GsmAmrEncoderCleanup(int gae);
    private static native void GsmAmrEncoderDelete(int gae);
}
</code></pre><p>复制AmrEncoder类</p>
<pre><code>public class AmrEncoder {
    public static void pcm2Amr(String pcmPath , String amrPath) {
        FileInputStream fis;
        try {
            fis = new FileInputStream(pcmPath);
            pcm2Amr(fis, amrPath);
            fis.close();
        } catch (FileNotFoundException e1) {
            e1.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    public static void pcm2Amr(InputStream pcmStream, String amrPath) {
        try {
            AmrInputStream ais = new AmrInputStream(pcmStream);
            OutputStream out = new FileOutputStream(amrPath);
            byte[] buf = new byte[4096];
            int len = -1;
            /*
             * 下面的AMR的文件头,缺少这几个字节是不行的
             */
            out.write(0x23);
            out.write(0x21);
            out.write(0x41);
            out.write(0x4D);
            out.write(0x52);
            out.write(0x0A);   
            while((len = ais.read(buf)) &gt;0){
                out.write(buf,0,len);
            }
            out.close();
            ais.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }       
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/03/直播/音频/学乎录音实现方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/03/直播/音频/学乎录音实现方式/" itemprop="url">学乎录音实现方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-03T14:52:14+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/直播/" itemprop="url" rel="index">
                    <span itemprop="name">直播</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>学乎录音实现</p>
<h1 id="学乎录音实现方式探索历程"><a href="#学乎录音实现方式探索历程" class="headerlink" title="学乎录音实现方式探索历程"></a>学乎录音实现方式探索历程</h1><p>尝试过 MedicaRecord,AudioRecord录音，lame库编码为MP3(<a href="https://github.com/liyungui/MP3LameRecord" target="_blank" rel="noopener">MP3LameRecord</a>)，webrtc降噪(<a href="https://github.com/liyungui/PCMNoiseSupression" target="_blank" rel="noopener">PCMNoiseSupression</a>)</p>
<p>经过实践测试，发现音效最好(音量大，噪音小)的实现方式是：AudioRecord录制，使用Android系统自带的pcm转arm</p>
<h2 id="关键细节"><a href="#关键细节" class="headerlink" title="关键细节"></a>关键细节</h2><pre><code>AudioManager audioManager = (AudioManager) App.getApplication().getSystemService(Context.AUDIO_SERVICE);
audioManager.setMode(AudioManager.MODE_IN_COMMUNICATION);
audioManager.setSpeakerphoneOn(true);

// 获得缓冲区字节大小
bufferSizeInBytes = AudioRecord.getMinBufferSize(AUDIO_SAMPLE_RATE,
        AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT);

// 创建AudioRecord对象
recorder = new AudioRecord(AUDIO_INPUT, AUDIO_SAMPLE_RATE,
        AudioFormat.CHANNEL_IN_MONO, AudioFormat.ENCODING_PCM_16BIT, bufferSizeInBytes);
voiceFilePath = PathUtil.getInstance().getVoicePath() + File.separator + getPCMFileName(&quot;&quot;);
file = new File(voiceFilePath);
recorder.startRecording();
isRecording = true;// 让录制状态为true
// 开启音频文件写入线程
new Thread(new AudioRecordThread()).start();

private void writeDateTOFile(String AudioName) {
    // new一个byte数组用来存一些字节数据，大小为缓冲区大小
    byte[] audiodata = new byte[bufferSizeInBytes];
    FileOutputStream fos = null;
    int readsize = 0;
    try {
        File file = new File(AudioName);
        if (file.exists()) {
            file.delete();
        }
        fos = new FileOutputStream(file);// 建立一个可存取字节的文件

        while (isRecording) {
            readsize = recorder.read(audiodata, 0, bufferSizeInBytes);
            if (AudioRecord.ERROR_INVALID_OPERATION != readsize &amp;&amp; fos != null) {
                try {
                    fos.write(audiodata);

                    getVolumeDB(readsize, audiodata);
                } catch (Exception e) {
                    if (e != null) {
                        e.printStackTrace();
                    }
                }
            }
        }

        if (fos != null)
            fos.close();// 关闭写入流
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre><p>pcm 转 amr实现细节参考另一篇笔记。反射调用在华为机型上容易ANR，要把系统类文件复制到工程中使用，性能好</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/03/直播/音频/微信语音编码-silk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/03/直播/音频/微信语音编码-silk/" itemprop="url">微信语音编码-silk</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-03T14:52:14+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/直播/" itemprop="url" rel="index">
                    <span itemprop="name">直播</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android微信语音聊天记录及文本聊天记录-数据库破解-silk-整理"><a href="#Android微信语音聊天记录及文本聊天记录-数据库破解-silk-整理" class="headerlink" title="Android微信语音聊天记录及文本聊天记录 数据库破解 silk 整理"></a><a href="http://blog.csdn.net/voler_HJL/article/details/53788126" target="_blank" rel="noopener">Android微信语音聊天记录及文本聊天记录 数据库破解 silk 整理</a></h1><p><strong>微信语音文件存储位置</strong></p>
<pre><code>根目录 -》tencent -》MicroMsg -》名字很长又很乱的那个文件夹 -》voice2 
</code></pre><p><strong>播放</strong></p>
<p>.amr后缀，但它并不是真正的.amr文件，amr播放器是播放不了的 </p>
<p>其实是silk v3格式，QQ的语音文件也是这种格式 </p>
<h1 id="微信语音文件的格式转换"><a href="#微信语音文件的格式转换" class="headerlink" title="微信语音文件的格式转换"></a><a href="http://www.jianshu.com/p/71137d5acf78" target="_blank" rel="noopener">微信语音文件的格式转换</a></h1><p>起初，iOS 只是去掉了文件头的 amr，添上就能还原为 amr 了；Android 则是原生的 amr。</p>
<p>微信6.0 之后开始采用 silk 编码来传输语音，必须用 slik v3 解码器</p>
<p>这方面许多人做过工作，罗列一下：</p>
<h2 id="个人"><a href="#个人" class="headerlink" title="个人"></a>个人</h2><p><strong>kn007</strong>: </p>
<p><a href="https://kn007.net/topics/decoding-qq-wechat-silk-v3-encoded-audio-to-mp3-or-other-formats/" target="_blank" rel="noopener">解码转换QQ微信的SILK v3编码音频为MP3或其他格式</a></p>
<p><a href="https://kn007.net/topics/batch-convert-silk-v3-audio-files-to-mp3-in-windows/" target="_blank" rel="noopener">Windows下批量转换Silk v3音频文件为MP3格式</a></p>
<p><a href="https://kn007.net/topics/update-silk2mp3-to-official-version/" target="_blank" rel="noopener">更新了Silk2MP3</a></p>
<p><strong>snakeninny</strong>：</p>
<p><a href="http://bbs.iosre.com/t/topic/3199" target="_blank" rel="noopener">从微信中提取语音文件，并转换成文字的全自动化解决方案</a></p>
<p><strong>hangcom</strong>：《iOS应用逆向工程》的作者，之前还开发了朋友圈导出。</p>
<p><a href="https://zhuanlan.zhihu.com/p/21783890" target="_blank" rel="noopener">微信语音文件的解析</a></p>
<p><strong>杨树下的狐狸</strong>：Android 方案</p>
<p><a href="https://www.zhihu.com/question/19909162/answer/80640430" target="_blank" rel="noopener">微信的语音聊天记录可以从手机提取出来保存到PC上么？ - 知乎</a></p>
<p><strong>cxun</strong>：整体解决方案</p>
<p>（暂时失效）<a href="http://www.cnblogs.com/cxun/p/4338643.html" target="_blank" rel="noopener">微信聊天记录查看器（程序+源码）</a></p>
<h2 id="商用"><a href="#商用" class="headerlink" title="商用"></a>商用</h2><p>iTools：可以转换 aud 到 wav</p>
<p>楼月微信聊天记录导出恢复助手：同上</p>
<p>其他还有：Silk 手机音频播放器、Silk 转换工具、WeBack 等等。</p>
<h1 id="Skype-Silk-与Opus的关系"><a href="#Skype-Silk-与Opus的关系" class="headerlink" title="Skype Silk 与Opus的关系"></a><a href="http://tiger-beach.blogspot.com/2014/04/skype-silk-opus.html" target="_blank" rel="noopener">Skype Silk 与Opus的关系</a></h1><p>Skype自2009年1月以来一直采用自己的SILK音频编码解码器，但是从2012年起过渡到新的Opus标准。</p>
<p>Opus标准已经获互联网工程任务组（IETF）批准，标准格式为RFC 6716。</p>
<p>Opus支持6kbps到510kbps的可变比特率。</p>
<p>它是一个有损声音编码的格式，适用于网络上的实时声音传输。</p>
<p>由于是一个开放格式，Opus在使用上没有任何专利限制。</p>
<p>Opus合并了Xiph.org的CELT低延时音频编解码器和Skype的SILK语音编解码器，专为互联网音频设计，可用于替代现有的私有音频编解码器</p>
<p>由 Xiph.Org、Mozilla、微软、Broadcom、Octasic和Google联合开发。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/03/直播/音频/音频基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/03/直播/音频/音频基础/" itemprop="url">音频基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-03T14:52:14+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/直播/" itemprop="url" rel="index">
                    <span itemprop="name">直播</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="PCM"><a href="#PCM" class="headerlink" title="PCM"></a>PCM</h1><p>Pulse Code Modulation 脉冲编码调制</p>
<p>PCM是把声音从模拟信号(人耳听到的)转化为数字信号的技术。原理是用一个固定的频率对模拟信号进行采样，采样后的信号在波形上看就像一串连续的幅值不一的脉冲</p>
<p>把这些脉冲的幅值按一定精度进行量化和编码，这就组成了数字音频的产生三个过程：<strong>采样、量化、编码</strong></p>
<p>采样就是在时间轴上对信号进行数字化</p>
<p>量化是指在幅度轴上对信号进行数字化</p>
<p>编码就是按照一定的格式记录采样和量化后的数字数据，比如顺序存储或压缩存储</p>
<p>采样频率：每秒采集数据的次数</p>
<p>采样精度：每次采集数据的位数</p>
<p>声道数：存在几路音频</p>
<p>比特率：针对编码格式，表示压缩编码后每秒的音频数据量大小</p>
<h1 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h1><h2 id="WAV"><a href="#WAV" class="headerlink" title="WAV"></a>WAV</h2><p>Windows Media Audio</p>
<p>微软公司开发的Windows平台数字音频编码</p>
<p>录音质量高，但是压缩率小，文件大。每秒170k左右</p>
<h2 id="AMR"><a href="#AMR" class="headerlink" title="AMR"></a>AMR</h2><p>Adaptive Multi-Rate 自适应多速率</p>
<p>使用1-8个不同的位速编码，使语音编码最优化</p>
<p>高压缩率，质量比较差，多用于人声，由欧洲通信标准化委员会提出，是在移动通信系统中使用最广泛的语音标准。每秒1K左右</p>
<p>分为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.AMR-NB</span><br><span class="line">2.AMR-WB, Adaptive Multi-Rate - Wideband Speech Codec</span><br><span class="line">3.AMR-WB+, Extended Adaptive Multi-Rate - Wideband Speech Codec</span><br></pre></td></tr></table></figure>
<h2 id="MP3"><a href="#MP3" class="headerlink" title="MP3"></a>MP3</h2><p>MPEG-1 or MPEG-2 Audio Layer III</p>
<p>有损压缩，大幅度地降低音频数据量(压缩率 10-12)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">就bit rates来说MP3可以分为2种：</span><br><span class="line">MP3-CBR：Constant Bit Rate 固定比特率</span><br><span class="line">MP3_VBR： Variable Bit Rate 可变比特率</span><br></pre></td></tr></table></figure>
<h2 id="AAC"><a href="#AAC" class="headerlink" title="AAC"></a>AAC</h2><p>Advanced Audio Coding 高级音频编码</p>
<p>高压缩比(18)</p>
<p>音质方面，采用多声道，在同规格下比其他编码更胜一筹</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/03/直播/音频/音频增益/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/03/直播/音频/音频增益/" itemprop="url">音频增益</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-03T14:52:14+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/直播/" itemprop="url" rel="index">
                    <span itemprop="name">直播</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.cnblogs.com/mod109/p/5767867.html" target="_blank" rel="noopener">音频增益</a> c++</p>
<p><a href="https://my.oschina.net/jinzei/blog/1305843" target="_blank" rel="noopener">PortAudio+webrtc+lame实现采集降噪增益mp3</a> c++</p>
<pre><code>不同采样率的兼容计算和细节讲的比较详细

先降噪后增益,噪音降低后增益把原声和降低的噪音又都放大了,效果是降噪不太明显,主声增大比较显著. 

可以尝试 降噪–增益–再降噪
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/03/直播/音频/音频播放中切换听筒和扬声器模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/03/直播/音频/音频播放中切换听筒和扬声器模式/" itemprop="url">音频播放中切换听筒和扬声器模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-03T14:52:14+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/直播/" itemprop="url" rel="index">
                    <span itemprop="name">直播</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://blog.csdn.net/wl332197858/article/details/51298868" target="_blank" rel="noopener">音频播放中切换听筒和扬声器模式</a></p>
<h1 id="切换听筒和扬声器模式"><a href="#切换听筒和扬声器模式" class="headerlink" title="切换听筒和扬声器模式"></a>切换听筒和扬声器模式</h1><p>网上的版本都是对于5.0以下可以使用的，实测5.0及以上不能使用，系统没有提供权限给我们修改</p>
<pre><code>audioManager.setSpeakerphoneOn(false);//关闭扬声器  
audioManager.setRouting(AudioManager.MODE_NORMAL, AudioManager.ROUTE_EARPIECE, AudioManager.ROUTE_ALL);  
mediaPlayer.setAudioStreamType(AudioManager.STREAM_VOICE_CALL); 
audioManager.setMode(AudioManager.MODE_IN_CALL);  //把声音设定成Earpiece（听筒）出来，设定为正在通话中  

需要权限： android.permission.MODIFY_AUDIO_SETTINGS
</code></pre><p>兼容5.0及以上的版本分三个步骤</p>
<pre><code>1.播放音频流类型要设置为AudioManager.STREAM_VOICE_CALL
2.在播放前调用AudioSystem.setForceUse(AudioSystem.FOR_COMMUNICATION,AudioSystem.FORCE_NONE);
3.配置权限： android.permission.MODIFY_AUDIO_SETTINGS
</code></pre><p>代码如下：</p>
<pre><code>private void setSpeakerphoneOn(boolean on) {
    try {

        mediaPlayer.setAudioStreamType(AudioManager.STREAM_VOICE_CALL);

        Class audioSystemClass = Class.forName(&quot;android.media.AudioSystem&quot;);
        Method setForceUse = audioSystemClass.getMethod(&quot;setForceUse&quot;, int.class, int.class);

        if (on) {
            audioManager.setMicrophoneMute(false);
            audioManager.setSpeakerphoneOn(true);
            audioManager.setMode(AudioManager.MODE_NORMAL);
        } else {
            audioManager.setSpeakerphoneOn(false);
            audioManager.setMode(AudioManager.MODE_NORMAL);
            setForceUse.invoke(null, 0, 0);
            audioManager.setMode(AudioManager.MODE_IN_COMMUNICATION);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre><h1 id="播放中切换"><a href="#播放中切换" class="headerlink" title="播放中切换"></a>播放中切换</h1><p>在播放声音过程中切换，是无法立即生效的，只有当调用 <code>mediaPlayer.prepare()</code> 后才起效</p>
<p>解决方案： 每次切换模式后，强制重新开始播放（微信就是从头开始播放）</p>
<pre><code>mediaPlayer.reset();
mediaPlayer.setDataSource(filePath);
mediaPlayer.prepare();
mediaPlayer.start();
</code></pre><h1 id="自动切换"><a href="#自动切换" class="headerlink" title="自动切换"></a><a href="http://blog.csdn.net/jjmm2009/article/details/37930449" target="_blank" rel="noopener">自动切换</a></h1><p>耳朵靠近时听筒播放，离开后扬声器播放</p>
<p>插入耳机耳机播放，拔出耳机扬声器播放</p>
<p>解决方案： </p>
<ol>
<li><p>利用<strong>距离感应器</strong>感应距离，当距离超过感应器最大距离（说明没有阻挡），就是扬声器播放</p>
<pre><code>SensorManager sensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
final Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY);
sensorManager.registerListener(new SensorEventListener() {
    @Override
    public void onSensorChanged(SensorEvent event) {
        if (isPlaying) {
            float range = event.values[0];
            if (range == sensor.getMaximumRange()) {
                Toast.makeText(context, &quot;正常模式&quot;, Toast.LENGTH_LONG).show();
                setSpeakerphoneOn(true);
            } else {
                Toast.makeText(context, &quot;听筒模式&quot;, Toast.LENGTH_LONG).show();
                setSpeakerphoneOn(false);
            }
            startPlayVoice(message.getLocalurl());
        }
    }

    @Override
    public void onAccuracyChanged(Sensor sensor, int accuracy) {

    }
}, sensor, SensorManager.SENSOR_DELAY_NORMAL);    
</code></pre></li>
<li><p><strong>耳机插拔广播接受者</strong></p>
<p> 监听广播 AudioManager.ACTION_AUDIO_BECOMING_NOISY和 android.intent.action.HEADSET_PLUG</p>
<pre><code>public class HeadsetPlugReceiver extends BroadcastReceiver {   
    @Override   
    public void onReceive(Context context, Intent intent) {   
        Log.i(&quot;NoisyAudioStreamReceiver=====================&gt;&quot;, &quot;change mode&quot;);  
        if (intent.hasExtra(&quot;state&quot;)){   
            if (intent.getIntExtra(&quot;state&quot;, 0) == 0){   
                Log.i(&quot;NoisyAudioStreamReceiver=====================&gt;headset not connected&quot;, &quot;change mode1&quot;);  
                audioManager.setMode(AudioManager.MODE_NORMAL);  
            }   
            else if (intent.getIntExtra(&quot;state&quot;, 0) == 1){   
                Log.i(&quot;NoisyAudioStreamReceiver=====================&gt;headset connected&quot;, &quot;change mode3&quot;);  
                audioManager.setMode(AudioManager.MODE_IN_CALL);  
            }   
        }   
    }   
} 

广播注册：
    myNoisyAudioStreamReceiver = new HeadsetPlugReceiver();  
    IntentFilter intentFilter = new IntentFilter(AudioManager.ACTION_AUDIO_BECOMING_NOISY);  
    intentFilter.addAction(&quot;android.intent.action.HEADSET_PLUG&quot;);  
    registerReceiver(myNoisyAudioStreamReceiver, intentFilter);    
</code></pre></li>
<li><p><strong>总结</strong></p>
<ul>
<li>耳机插拔可以不用监听，因为系统会自动处理（插入耳机用耳机，拔出耳机用扬声器）</li>
<li>添加了距离感应器切换扬声器和听筒后，系统自带的耳机插拔处理会失效<ul>
<li>原因：因为 距离感应器切换扬声器和听筒只有扬声器和听筒两种状态</li>
<li>解决：距离感应器增加判断，当有耳机插入时，什么也不做 <code>audioManager.isWiredHeadsetOn()</code></li>
</ul>
</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/02/Android/TransactionTooLargeException错误/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/02/Android/TransactionTooLargeException错误/" itemprop="url">TransactionTooLargeException错误</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-02T17:54:53+08:00">
                2019-09-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h1><pre><code>TransactionTooLargeException: data parcel size 587588  bytes
</code></pre><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p><strong>Binder传递数据量过大</strong>    </p>
<p>进程内Binder缓冲区最大上限1M（进程内所有线程共享这块空间，实际上操作的线程内，数据超过200K都可能挂掉）</p>
<p>在6.0的源码 <code>/frameworks/base/core/jni/android_util_Binder.cpp</code>v中的 <code>signalExceptionForError</code> 函数里，对于 <code>FAILED_TRANSACTION</code> 这种错误的分支里，丢出了异常，不过还是有让人困惑的地方：传递的数据超过200K就要报错</p>
<h2 id="Activity状态Bundle"><a href="#Activity状态Bundle" class="headerlink" title="Activity状态Bundle"></a>Activity状态Bundle</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Activity跳转Intent"><a href="#Activity跳转Intent" class="headerlink" title="Activity跳转Intent"></a>Activity跳转Intent</h2><p>通过Intent传递数据，具体的大小限制不同版本的系统不同，比较普遍的一个看法是不能超过1MB，因为官方文档里有这样的说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The Binder transaction failed because it was too large.</span><br><span class="line"></span><br><span class="line">During a remote procedure call, the arguments and the return value of the call are transferred as Parcel objects stored in the Binder transaction buffer. If the arguments or the return value are too large to fit in the transaction buffer, then the call will fail and TransactionTooLargeException will be thrown.</span><br><span class="line"></span><br><span class="line">The Binder transaction buffer has a limited fixed size, currently 1Mb, which is shared by all transactions in progress for the process. Consequently this exception can be thrown when there are many transactions in progress even when most of the individual transactions are of moderate size.</span><br></pre></td></tr></table></figure>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="压缩数据量"><a href="#压缩数据量" class="headerlink" title="压缩数据量"></a>压缩数据量</h2><h2 id="使用其他方式传递数据"><a href="#使用其他方式传递数据" class="headerlink" title="使用其他方式传递数据"></a>使用其他方式传递数据</h2><ul>
<li>文件</li>
<li>EventBus</li>
</ul>
<h1 id="参考-amp-扩展"><a href="#参考-amp-扩展" class="headerlink" title="参考&amp;扩展"></a>参考&amp;扩展</h1><ul>
<li><a href="https://www.jianshu.com/p/044e2c318306" target="_blank" rel="noopener">Android TransactionTooLargeException 解析，思考与监控方案</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/31/web/wordpress/主题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/31/web/wordpress/主题/" itemprop="url">主题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-31T17:35:14+08:00">
                2019-08-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Flatsome"><a href="#Flatsome" class="headerlink" title="Flatsome"></a>Flatsome</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">requests数量：过多 90+</span><br><span class="line"></span><br><span class="line">电商主题</span><br></pre></td></tr></table></figure>
<h1 id="Avada"><a href="#Avada" class="headerlink" title="Avada"></a>Avada</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">功能：全面而强大</span><br><span class="line">编辑器：体验很好</span><br><span class="line">个性化设置：丰富</span><br><span class="line">requests数量：过多 120+</span><br><span class="line">服务器资源要求：高</span><br><span class="line"></span><br><span class="line">ThemeForest市场上最畅销的主题，但它并不是WordPress最畅销的主题。</span><br><span class="line">将Avada用于电子商务网站是在寻找麻烦。电子商务网站拥有更多的资源需求，需要精简高效且编码良好的主题。</span><br><span class="line">使用后端页面构建器，浪费很多时间在前端和后端切换验证每一个小变化；</span><br></pre></td></tr></table></figure>
<p><a href="http://libs.websoft9.com/apps/wordpress/wordpress5.0.2-avada5.7.2-en.tar.gz" target="_blank" rel="noopener">Websoft9 Avada5.7.2 官方原版下载</a></p>
<h1 id="Enfold"><a href="#Enfold" class="headerlink" title="Enfold"></a>Enfold</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">编辑器：体验很好;优于avada</span><br><span class="line">requests数量：50+</span><br><span class="line">个性化设置：略欠缺，需要custom css</span><br></pre></td></tr></table></figure>
<h1 id="Betheme"><a href="#Betheme" class="headerlink" title="Betheme"></a>Betheme</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">requests数量：40+</span><br><span class="line"></span><br><span class="line">WP主题 TOP5</span><br></pre></td></tr></table></figure>
<h1 id="Impreza"><a href="#Impreza" class="headerlink" title="Impreza"></a>Impreza</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">requests数量：30+</span><br><span class="line"></span><br><span class="line">最大的主题库themeforest 中的wordpress好评排名第一。</span><br><span class="line">推荐外贸建站的WordPress用户使用Impreza</span><br></pre></td></tr></table></figure>
<h1 id="GeneratePress"><a href="#GeneratePress" class="headerlink" title="GeneratePress"></a>GeneratePress</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">requests数量：40+；速度最快，谷歌速度分数：A（95％）</span><br><span class="line"></span><br><span class="line">轻量级主题</span><br></pre></td></tr></table></figure>
<h1 id="参考-amp-扩展"><a href="#参考-amp-扩展" class="headerlink" title="参考&amp;扩展"></a>参考&amp;扩展</h1><ul>
<li><a href="https://www.liaosam.com/wordpress-theme-avada-enfold-betheme.html/comment-page-1" target="_blank" rel="noopener">Avada &amp; Enfold &amp; Betheme：最棒的三个外贸建站英文主题</a></li>
<li><a href="https://www.imaiko.com/why-i-not-choose-avada.html" target="_blank" rel="noopener">为什么我不推荐Avada</a></li>
<li><a href="https://www.imaiko.com/avada-divi-impreza.html" target="_blank" rel="noopener">三个主题比较，Avada，Divi和Impreza</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="风" />
            
              <p class="site-author-name" itemprop="name">风</p>
              <p class="site-description motion-element" itemprop="description">随心而动，随刃而行</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">318</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">73</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">风</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
