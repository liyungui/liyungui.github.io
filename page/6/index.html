<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="随心而动，随刃而行">
<meta property="og:type" content="website">
<meta property="og:title" content="风">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="风">
<meta property="og:description" content="随心而动，随刃而行">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="风">
<meta name="twitter:description" content="随心而动，随刃而行">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/6/"/>





  <title>风</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">风</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">技术博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/14/编程思想/mvc mvp mvvm clean/Google官方MVP Sample代码解读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/14/编程思想/mvc mvp mvvm clean/Google官方MVP Sample代码解读/" itemprop="url">Google官方MVP Sample代码解读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-14T09:07:56+08:00">
                2019-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程思想/" itemprop="url" rel="index">
                    <span itemprop="name">编程思想</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.cnblogs.com/mengdd/p/5988104.html" target="_blank" rel="noopener">Google官方MVP Sample代码解读</a></p>
<p><a href="http://blog.csdn.net/ljd2038/article/details/51477475" target="_blank" rel="noopener">Android官方MVP架构解读</a></p>
<p><a href="https://github.com/boredream/DesignResCollection/tree/master/DesignResCollection_MVP" target="_blank" rel="noopener">一个简单项目（反馈页面）搞定 MVP + Mockito进行单元测试 + Espresso进行UI测试，配详细介绍文档</a></p>
<h1 id="项目结构分析"><a href="#项目结构分析" class="headerlink" title="项目结构分析"></a>项目结构分析</h1><p>项目是一个备忘录。添加任务到待办任务列表。列表中标记任务已完成，任务详细页面修改任务内容，统计已完成的任务和未完成的任务数量。 </p>
<p><img src="http://img.blog.csdn.net/20160522165007677" alt=""></p>
<ul>
<li><p>一个源码目录 <code>mian</code> ，四个测试目录 <code>androidTest</code> <code>androidTestMock</code> <code>mock</code> <code>test</code> 。</p>
</li>
<li><p>代码分包结构</p>
<ul>
<li>四个功能包：<ul>
<li>任务的添加编辑(addedittask)。包内一般有类：xxActivity,xxFragment,xxPresenter,xxContract。<code>Presenter层</code>与<code>View层</code></li>
<li>任务完成情况的统计(statistics)</li>
<li>任务的详情(taskdetail)</li>
<li>任务列表的显示(tasks)。</li>
</ul>
</li>
<li>data包。数据源，数据库读写，网络请求，MVP架构中的 <code>Model层</code>。</li>
<li>util包。工具类。</li>
<li>在最外层存放了两接口BasePresenter和BaseView。Presenter层接口和View层接口的基类，项目中所有的Presenter接口和View层接口都继承自这两个接口。 </li>
</ul>
</li>
</ul>
<h1 id="MVP架构实现"><a href="#MVP架构实现" class="headerlink" title="MVP架构实现"></a>MVP架构实现</h1><h2 id="Model层的实现"><a href="#Model层的实现" class="headerlink" title="Model层的实现"></a>Model层的实现</h2><h3 id="public-interface-TasksDataSource"><a href="#public-interface-TasksDataSource" class="headerlink" title="public interface TasksDataSource"></a>public interface TasksDataSource</h3><pre><code>/**
 * For simplicity, only getTasks() and getTask() have callbacks.Consider adding callbacks to other methods
 */
public interface TasksDataSource {
    void getTasks(@NonNull LoadTasksCallback callback);
    void getTask(@NonNull String taskId, @NonNull GetTaskCallback callback);
    void saveTask(@NonNull Task task);
    void completeTask(@NonNull Task task);//标记为已完成
    void completeTask(@NonNull String taskId);
    void activateTask(@NonNull Task task);//标记为进行中
    void activateTask(@NonNull String taskId);
    void clearCompletedTasks();
    void refreshTasks();
    void deleteAllTasks();
    void deleteTask(@NonNull String taskId);
</code></pre><h3 id="local数据源"><a href="#local数据源" class="headerlink" title="local数据源"></a>local数据源</h3><pre><code>/**
 * Concrete implementation of a data source as a db.
 */
public class TasksLocalDataSource implements TasksDataSource {
</code></pre><h3 id="remote数据源"><a href="#remote数据源" class="headerlink" title="remote数据源"></a>remote数据源</h3><pre><code>/**
 * Implementation of the data source that adds a latency simulating network.
 */
public class TasksRemoteDataSource implements TasksDataSource {
</code></pre><h3 id="数据三级缓存"><a href="#数据三级缓存" class="headerlink" title="数据三级缓存"></a>数据三级缓存</h3><pre><code>/**
 * Concrete implementation to load tasks from the data sources into a cache.
 * 
 * For simplicity, this implements a dumb synchronisation between locally persisted data and data
 * obtained from the server, by using the remote data source only if the local database doesn&apos;t
 * exist or is empty.
 */
public class TasksRepository implements TasksDataSource {
    Map&lt;String, Task&gt; mCachedTasks;
    boolean mCacheIsDirty = false;

    /**
     * Gets tasks from cache, local data source (SQLite) or remote data source, whichever is available first.
     * 
     * LoadTasksCallback#onDataNotAvailable() is fired if all data sources fail to get the data.
     */
    @Override
    public void getTasks(@NonNull final LoadTasksCallback callback) {
        checkNotNull(callback);

        // Respond immediately with cache if available and not dirty
        if (mCachedTasks != null &amp;&amp; !mCacheIsDirty) {
            callback.onTasksLoaded(new ArrayList&lt;&gt;(mCachedTasks.values()));
            return;
        }

        if (mCacheIsDirty) {
            // If the cache is dirty we need to fetch new data from the network.
            getTasksFromRemoteDataSource(callback);
        } else {
            // Query the local storage if available. If not, query the network.
            mTasksLocalDataSource.getTasks(new LoadTasksCallback() {
                @Override
                public void onTasksLoaded(List&lt;Task&gt; tasks) {
                    refreshCache(tasks);
                    callback.onTasksLoaded(new ArrayList&lt;&gt;(mCachedTasks.values()));
                }

                @Override
                public void onDataNotAvailable() {
                    getTasksFromRemoteDataSource(callback);
                }
            });
        }
    }

    private void getTasksFromRemoteDataSource(@NonNull final LoadTasksCallback callback) {
        mTasksRemoteDataSource.getTasks(new LoadTasksCallback() {
            @Override
            public void onTasksLoaded(List&lt;Task&gt; tasks) {
                refreshCache(tasks);
                refreshLocalDataSource(tasks);
                callback.onTasksLoaded(new ArrayList&lt;&gt;(mCachedTasks.values()));
            }

            @Override
            public void onDataNotAvailable() {
                callback.onDataNotAvailable();
            }
        });
    }

    private void refreshCache(List&lt;Task&gt; tasks) {
        if (mCachedTasks == null) {
            mCachedTasks = new LinkedHashMap&lt;&gt;();
        }
        mCachedTasks.clear();
        for (Task task : tasks) {
            mCachedTasks.put(task.getId(), task);
        }
        mCacheIsDirty = false;
    }

    private void refreshLocalDataSource(List&lt;Task&gt; tasks) {
        mTasksLocalDataSource.deleteAllTasks();
        for (Task task : tasks) {
            mTasksLocalDataSource.saveTask(task);
        }
    }
</code></pre><p>实际使用的就是带三级缓存的数据源，它由手动实现的注入类Injection（该类在mock目录）提供:</p>
<pre><code>public class Injection {
    public static TasksRepository provideTasksRepository(@NonNull Context context) {
        checkNotNull(context);
        return TasksRepository.getInstance(FakeTasksRemoteDataSource.getInstance(),
                TasksLocalDataSource.getInstance(context));
    }
}
</code></pre><h2 id="contract"><a href="#contract" class="headerlink" title="contract"></a>contract</h2><pre><code>public interface BasePresenter {
    void start();
}

public interface BaseView&lt;T&gt; {
    void setPresenter(T presenter);
}

public interface AddEditTaskContract {

    interface View extends BaseView&lt;Presenter&gt; {

        void showEmptyTaskError();

        void showTasksList();

        void setTitle(String title);

        void setDescription(String description);

        boolean isActive();
    }

    interface Presenter extends BasePresenter {

        void createTask(String title, String description);

        void updateTask( String title, String description);

        void populateTask();
    }
}
</code></pre><h2 id="Presenter层的实现"><a href="#Presenter层的实现" class="headerlink" title="Presenter层的实现"></a>Presenter层的实现</h2><pre><code>/**
 * Listens to user actions from the UI ({@link AddEditTaskFragment}), retrieves the data and updates the UI as required.
 */
public class AddEditTaskPresenter implements AddEditTaskContract.Presenter, TasksDataSource.GetTaskCallback {
</code></pre><h2 id="View层的实现"><a href="#View层的实现" class="headerlink" title="View层的实现"></a>View层的实现</h2><ul>
<li>View的实现是在Fragment中</li>
<li><p>而在Activity中则是完成对Fragment的添加，Presenter的创建</p>
<pre><code>// Create the presenter
mAddEditTaskPresenter = new AddEditTaskPresenter(
        taskId,
        Injection.provideTasksRepository(getApplicationContext()),
        addEditTaskFragment,
        shouldLoadDataFromRepo);
</code></pre></li>
<li><p>官方对于采用Fragment的原因给出了两种解释。</p>
<ul>
<li>通过Activity和Fragment分离非常适合对于MVP架构的实现。Activity作为全局控制者将Presenter与View联系在一起。</li>
<li>采用Fragment更有利于平板电脑的布局或者是多视图屏幕。</li>
</ul>
</li>
</ul>
<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><ul>
<li><p>MVP模式的主要优势就是便于为业务逻辑加上单元测试.</p>
</li>
<li><p>本例子中的单元测试是给TasksRepository和四个feature的Presenter加的.</p>
</li>
<li><p>单元测试的目录是  <code>mock</code> <code>test</code></p>
</li>
<li><p>单元测试使用的是 Junit + <a href="http://site.mockito.org/" target="_blank" rel="noopener">mockito</a></p>
</li>
</ul>
<p>依赖配置</p>
<pre><code>repositories { jcenter() }
dependencies { testCompile &quot;org.mockito:mockito-core:1.+&quot; }
</code></pre><p>Presenter的单元测试, Mock了View和Model, 测试调用逻辑, 如:</p>
<pre><code>/**
 * Unit tests for the implementation of {@link AddEditTaskPresenter}.
 */
public class AddEditTaskPresenterTest {

    @Mock
    private TasksRepository mTasksRepository;

    @Mock
    private AddEditTaskContract.View mAddEditTaskView;

    /**
     * {@link ArgumentCaptor} is a powerful Mockito API to capture argument values and use them to
     * perform further actions or assertions on them.
     */
    @Captor
    private ArgumentCaptor&lt;TasksDataSource.GetTaskCallback&gt; mGetTaskCallbackCaptor;

    private AddEditTaskPresenter mAddEditTaskPresenter;

    @Before
    public void setupMocksAndView() {
        // Mockito has a very convenient way to inject mocks by using the @Mock annotation. To
        // inject the mocks in the test the initMocks method needs to be called.
        MockitoAnnotations.initMocks(this);

        // The presenter wont&apos;t update the view unless it&apos;s active.
        when(mAddEditTaskView.isActive()).thenReturn(true);
    }

    @Test
    public void saveNewTaskToRepository_showsSuccessMessageUi() {
        // Get a reference to the class under test
        mAddEditTaskPresenter = new AddEditTaskPresenter(
                null, mTasksRepository, mAddEditTaskView, true);

        // When the presenter is asked to save a task
        mAddEditTaskPresenter.saveTask(&quot;New Task Title&quot;, &quot;Some Task Description&quot;);

        // Then a task is saved in the repository and the view updated
        verify(mTasksRepository).saveTask(any(Task.class)); // saved to the model
        verify(mAddEditTaskView).showTasksList(); // shown in the UI
    }
</code></pre><h1 id="UI-测试"><a href="#UI-测试" class="headerlink" title="UI 测试"></a>UI 测试</h1><p>Espresso，Google官方提供的Android UI自动化测试的框架</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/14/编程思想/mvc mvp mvvm clean/google mvp clean 架构解读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/14/编程思想/mvc mvp mvvm clean/google mvp clean 架构解读/" itemprop="url">google mvp clean 架构解读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-14T09:07:56+08:00">
                2019-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程思想/" itemprop="url" rel="index">
                    <span itemprop="name">编程思想</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.jianshu.com/p/cba6663435c7" target="_blank" rel="noopener">学习 CleanArchitecture 心得体会</a> </p>
<p><a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp-clean/" target="_blank" rel="noopener">google mvp clean architecture sample</a></p>
<p><a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="noopener">uncle-bob Clean Architecture</a></p>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>google samples<br><img src="https://upload-images.jianshu.io/upload_images/1019822-cda363d399934d04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>uncle-bob<br><img src="http://upload-images.jianshu.io/upload_images/1019822-b2acfd9ed6182541.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>两个图其实是一个意思。都是三层结构</strong></p>
<p>It’s based on the MVP sample, adding a <code>domain</code> layer between the <code>presentation</code> layer and <code>data</code> layar, splitting the app in three layers:</p>
<ul>
<li>PresentationLayer。 展示层，原来的MVP</li>
<li>DomainLayer。 新加的层</li>
<li><p>DataLayer。原来的数据层。</p>
<p>  最底层，完全不知道 DomainLayer 和PresentationLayer 的存在。这是保证 <code>可测试性</code> <code>低耦合度</code> 的关键所在 </p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/14/编程思想/mvc mvp mvvm clean/Clean 架构开发android应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/14/编程思想/mvc mvp mvvm clean/Clean 架构开发android应用/" itemprop="url">Clean架构开发Android应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-14T09:06:53+08:00">
                2019-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程思想/" itemprop="url" rel="index">
                    <span itemprop="name">编程思想</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>使用Clean架构开发Android应用详细指南 http://www.open-open.com/lib/view/open1455759692636.html
</code></pre><p><strong>Clean 架构是向内依赖：内层不能依赖外层，即内层不知道有关外层的任何事情（此句道尽Clean架构）。</strong><br><img src="http://static.open-open.com/lib/uploadImg/20160218/20160218094131_195.png" alt=""></p>
<p><strong>Clean架构可以使你的代码有如下特性：</strong></p>
<ol>
<li>独立于架构</li>
<li>易于测试</li>
<li>独立于UI</li>
<li>独立于数据库</li>
<li>独立于任何外部类库</li>
</ol>
<h2 id="Clean在Android中如何表现"><a href="#Clean在Android中如何表现" class="headerlink" title="Clean在Android中如何表现"></a>Clean在Android中如何表现</h2><p>一个应用可以有任意数目的层，但除非你的应用到处是企业级功能逻辑，一般需要这三层：</p>
<ul>
<li>外层：接口实现层</li>
<li>中层：接口适配层</li>
<li>内层：逻辑层</li>
</ul>
<p><strong>接口实现层是体现架构细节的地方</strong>。实现架构的代码是所有不用来解决问题的代码，这包括所有与安卓相关的东西，比如创建Activity和Fragment，发送Intent以及其他联网与数据库的架构相关的代码。图片中UI、Web、Devices、DB、External Interfaces是和架构相关的（android还是ios或是web）</p>
<p><strong>接口适配层就是桥接逻辑层和架构层的代码，是胶水代码</strong>。mvc中的c，mvp的p。</p>
<p><strong>逻辑层最重要，这里包含了真正解决问题的代码</strong>。这一层不包含任何实现架构的代码， 不用模拟器也应能运行这里的代码 。这样一来你的逻辑代码就有了易于测试、开发和维护的优点。这就是Clean架构的一个主要的好处。</p>
<p>每一个位于核心层外部的层都应能将外部模型转成可以被内层处理的内部模型。内层不能持有属于外层的模型类的引用。</p>
<p>为什么要进行模型转换呢？举个例子，当逻辑层的模型不能直接很优雅地展现给用户，或是需要同时展示多个逻辑层的模型时，最好创建一个ViewModel类来更好的进行UI展示。这样一来，你就需要一个属于外层的Converter类来将逻辑层模型转换成合适的ViewModel。</p>
<p>再举一个例子：你从外部数据库层获得了ContentProvider的Cursor对象，外层首先要将这个对象转换成内层模型，再将它传给内层处理。</p>
<h2 id="如何开始写Clean应用？"><a href="#如何开始写Clean应用？" class="headerlink" title="如何开始写Clean应用？"></a>如何开始写Clean应用？</h2><p><strong>开始写用例</strong></p>
<p>一般来说一个安卓应用的结构如下：</p>
<ul>
<li><p>外层项目包：UI，Storage，Network等等。</p>
</li>
<li><p>中层项目包：Presenter，Converter。</p>
</li>
<li><p>内层项目包：Interactor，Model，Repository，Executor。</p>
</li>
</ul>
<p><strong>外层体现了框架的细节。</strong></p>
<p>UI– 包括所有的Activity，Fragment，Adapter和其他UI相关的Android代码。</p>
<p>Storage– 用于让交互类获取和存储数据的接口实现类，包含了数据库相关的代码。包括了如ContentProvider或DBFlow等组件。</p>
<p>Network– 网络操作。</p>
<p><strong>中层是桥接实现代码与逻辑代码的Glue Code。</strong></p>
<p>Presenter– presenter处理UI事件，如单击事件，通常包含内层Interactor的回调方法。这里需要注意不能持有外层UI的引用，所以通过持有接口而UI实现接口实现间接持有UI（mvp的做法）</p>
<p>Converter– 负责将内外层的模型互相转换。内层不能持有外层引用，所以转换成ViewModule传给内层</p>
<p><strong>内层真正解决问题的代码，这一层的类和对象不知道外层的任何信息，且应能在任何JVM下运行。</strong></p>
<p>Interactor– Interactor中包含了解决问题的逻辑代码。这里的代码在后台执行，并通过回调方法向外层传递事件。在其他项目中这个模块被称为用例Use Case。一个项目中可能有很多小Interactor，这符合单一职责原则，而且这样更容易让人接受。一般mvp是在这里直接调用mvp方法。clean不能持有相对外层的引用，所以需要在本层再增加一个回调接口，让present去实现。</p>
<p>Model– 在业务逻辑代码中操作的业务模型。</p>
<p>Repository– 包含接口让外层类实现，如操作数据(获取/保存)的类等。不能持有外层引用，Interactor持有这些接口来获取和存储数据,外层需要实现这些接口（DB/External Interfaces就是这些接口的实现）。这也叫资源库模式Repository Pattern。</p>
<p>Executor– 通过Worker Thread Executor让Interactor在后台执行。一般不需要修改这个包里的代码。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/14/编程思想/mvc mvp mvvm clean/重构！将Google官方Android MVP应用于已有项目/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/14/编程思想/mvc mvp mvvm clean/重构！将Google官方Android MVP应用于已有项目/" itemprop="url">重构将Google官方Android MVP应用于已有项目</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-14T09:05:53+08:00">
                2019-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程思想/" itemprop="url" rel="index">
                    <span itemprop="name">编程思想</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.jianshu.com/p/bb5df9b7e357" target="_blank" rel="noopener">重构！将Google官方Android MVP应用于已有项目</a></p>
<p>采用MVP架构进行重构，代码量上相对于原项目时有所增加的</p>
<h1 id="Google示例项目"><a href="#Google示例项目" class="headerlink" title="Google示例项目"></a>Google示例项目</h1><p><a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="noopener">Android Architecture Blueprints [beta]</a></p>
<h1 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h1><h2 id="建立两个Base接口，BaseView和BasePresenter"><a href="#建立两个Base接口，BaseView和BasePresenter" class="headerlink" title="建立两个Base接口，BaseView和BasePresenter"></a>建立两个Base接口，BaseView和BasePresenter</h2><pre><code>public interface BasePresenter {
}

public interface BaseView&lt;T&gt; {
    void setPresenter(T presenter);//将Presenter实例传入view，调用时机为Presenter实现类的构造方法中
}
</code></pre><h2 id="创建契约类-统一管理View和Presenter的所有接口"><a href="#创建契约类-统一管理View和Presenter的所有接口" class="headerlink" title="创建契约类,统一管理View和Presenter的所有接口"></a>创建契约类,统一管理View和Presenter的所有接口</h2><pre><code>public interface MainActivityContract {

    interface View extends BaseView&lt;Presenter&gt; {

        void showError();

        void showLoading();

        void stopLoading();

        void showResults(ArrayList&lt;String&gt; list);

        void showNetworkError();

    }

    interface Presenter extends BasePresenter {

        void loadPosts(String url, boolean clearing);

        void refresh(String url);

        void loadMore(String url);

    }

}
</code></pre><h2 id="创建Presenter实现类"><a href="#创建Presenter实现类" class="headerlink" title="创建Presenter实现类"></a>创建Presenter实现类</h2><pre><code>public class MainActivityPresenter implements MainActivityContract.Presenter, NewsListener {

    private MainActivityContract.View view;//持有View接口
    private NewsModel model;//持有Model实现类

    private ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();

    public MainActivityPresenter(MainActivityContract.View view) {
        this.view = view;
        this.view.setPresenter(this);//View设置Present
        model = new NewsModel();
    }

    @Override
    public void loadPosts(String url, boolean clearing) {
        view.showLoading();
        if (clearing) {
            list.clear();
        }
        model.load(url, this);
    }

    @Override
    public void refresh(String url) {
        list.clear();
        loadPosts(url, true);
    }

    @Override
    public void loadMore(String url) {
        model.load(url, this);
    }

    @Override
    public void start() {

    }

    @Override
    public void onSuccess(String result) {
        list.add(result);
        view.showResults(list);
        view.stopLoading();

    }

    @Override
    public void onError(String error) {
        view.stopLoading();
        view.showError();
    }

}
</code></pre><h2 id="创建View实现类。-作为View和Presenter的桥梁，创建View和Presenter实现类的实例"><a href="#创建View实现类。-作为View和Presenter的桥梁，创建View和Presenter实现类的实例" class="headerlink" title="创建View实现类。 作为View和Presenter的桥梁，创建View和Presenter实现类的实例"></a>创建View实现类。 作为View和Presenter的桥梁，创建View和Presenter实现类的实例</h2><pre><code>public class MainActivity extends AppCompatActivity implements MainActivityContract.View {

    private SwipeRefreshLayout refresh;
    private TextView tvRefresh;
    private TextView tvLoadMore;
    private TextView tvContent;

    private MainActivityContract.Presenter presenter;

    private String cnnews = &quot;cnnews&quot;;
    private String usanews = &quot;usanews&quot;;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        new MainActivityPresenter(this);//创建Presenter实例

        refresh = (SwipeRefreshLayout) findViewById(R.id.refresh);
        tvRefresh = (TextView) findViewById(R.id.tvRefresh);
        tvLoadMore = (TextView) findViewById(R.id.tvLoadMore);
        tvContent = (TextView) findViewById(R.id.tvContent);
        refresh.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
            @Override
            public void onRefresh() {
                refresh.setRefreshing(false);
            }
        });
        tvRefresh.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                presenter.refresh(cnnews);
            }
        });
        tvLoadMore.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                presenter.loadMore(usanews);
            }
        });

        presenter.loadPosts(cnnews, false);
    }

    @Override
    public void showError() {
        tvContent.setText(&quot;出现错误&quot;);
    }

    @Override
    public void showLoading() {
        refresh.setRefreshing(true);
    }

    @Override
    public void stopLoading() {
        refresh.setRefreshing(false);
    }

    @Override
    public void showResults(ArrayList&lt;String&gt; list) {
        String content = &quot;&quot;;
        for (String string : list) {
            if (!TextUtils.isEmpty(content)) {
                content += &quot;\n&quot;;
            }
            content += string;
            tvContent.setText(content + &quot;\n&quot;);
        }
    }

    @Override
    public void showNetworkError() {
        tvContent.setText(&quot;网络错误&quot;);
    }

    @Override
    public void setPresenter(MainActivityContract.Presenter presenter) {
        if (null != presenter) {
            this.presenter = presenter;
        }
    }
}
</code></pre><h2 id="Model实现类"><a href="#Model实现类" class="headerlink" title="Model实现类"></a>Model实现类</h2><p>Gson解析接口返回</p>
<pre><code>public class News {
    private String content;

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }
}
</code></pre><p>网络请求异步，返回接口需要接口回调</p>
<pre><code>public interface NewsListener {

    void onSuccess(String result);

    void onError(String error);

}
</code></pre><p>Retrofit网络请求</p>
<pre><code>public class NewsModel {

    public void load(String url, final NewsListener listener) {
        NewsAPI.get(url, new Callback&lt;News&gt;() {
            @Override
            public void onResponse(Call&lt;News&gt; call, Response&lt;News&gt; response) {
                if (response.code() == 200) {
                    listener.onSuccess(response.body().getContent());
                }
            }

            @Override
            public void onFailure(Call&lt;News&gt; call, Throwable t) {
                listener.onError(call.request().url() + &quot; faild&quot;);
                t.printStackTrace();
            }
        });

    }
}
</code></pre><h2 id="mvp是如何互相持有的"><a href="#mvp是如何互相持有的" class="headerlink" title="mvp是如何互相持有的"></a>mvp是如何互相持有的</h2><p>View与Presenter</p>
<pre><code>View中
    new MainActivityPresenter(this);//创建Presenter实例

    implements MainActivityContract.View
    @Override
    public void setPresenter(MainActivityContract.Presenter presenter) {
        if (null != presenter) {
            this.presenter = presenter;//持有了Presenter
        }
    }

Presenter中
    public MainActivityPresenter(MainActivityContract.View view) {
        this.view = view;//持有了View
        this.view.setPresenter(this);//View设置Present
        model = new NewsModel();
    }
</code></pre><p>Presenter与Model</p>
<pre><code>Model中
    public void load(String url, final NewsListener listener) 

Presenter中
    public class MainActivityPresenter implements MainActivityContract.Presenter, NewsListener 
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/14/编程思想/mvc mvp mvvm clean/我不使用Android Data Binding的四个理由/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/14/编程思想/mvc mvp mvvm clean/我不使用Android Data Binding的四个理由/" itemprop="url">我不使用Android Data Binding的四个理由</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-14T09:04:53+08:00">
                2019-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程思想/" itemprop="url" rel="index">
                    <span itemprop="name">编程思想</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>我不使用Android Data Binding的四个理由  http://mafei.me/2016/08/14/%E8%AF%91%E6%96%87-%E6%88%91%E4%B8%8D%E4%BD%BF%E7%94%A8Android-Data-Binding%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%90%86%E7%94%B1/
</code></pre><h2 id="1、专家不建议这么做"><a href="#1、专家不建议这么做" class="headerlink" title="1、专家不建议这么做"></a>1、专家不建议这么做</h2><p>ButterKnife的作者Jake在下面这个github issue中直指要点。</p>
<pre><code>data binding在最简单的场景下是比较有用的。
但它并没有什么创新，所以在复杂度增加的情况下还是会像其他平台上的解决方案一样用起来非常痛苦（例如：XAML）。
当这个库扩展到高级的情况下，将会迫使你把绑定的逻辑写到代码中，那里才是它真正该在的地方。
</code></pre><p>事实上，我同意其中的两点：</p>
<pre><code>1、它的扩展性并不好。
2、业务逻辑应该在代码中。
</code></pre><h2 id="2、它让你写出意大利面式的代码"><a href="#2、它让你写出意大利面式的代码" class="headerlink" title="2、它让你写出意大利面式的代码"></a>2、它让你写出意大利面式的代码</h2><p>一旦我们开始实现复杂的布局，将会使我们的Data Binding解决方案越来越复杂。</p>
<p>首先我们将会面临下面的问题：</p>
<pre><code>1、Layout 要求你给他们分别传递数据。

2、你也可能想为你的布局创建不同的数据源。

3、同样的问题也会在ViewStubs中发生。

4、当你使用Picasso加载图片的时候，你需要为他实现一个自定义的data binding adapter，那样的话你就不能作为依赖mock和注入了。
</code></pre><h2 id="3、单元测试也不能用了"><a href="#3、单元测试也不能用了" class="headerlink" title="3、单元测试也不能用了"></a>3、单元测试也不能用了</h2><p>我非常喜欢Robolectric和Mockito，他们节约了我很多时间在创建和运行测试实例的时候，没有了他们我将无法工作。</p>
<p>Data Binding的一个特性对于我来说是一个bug：如果layout发生了异步更新，那就意味着在我设置了绑定之后单元测试中我无法确定view上的数据是否正确。</p>
<h2 id="4、它比ButterKnife提供的功能少很多"><a href="#4、它比ButterKnife提供的功能少很多" class="headerlink" title="4、它比ButterKnife提供的功能少很多"></a>4、它比ButterKnife提供的功能少很多</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/14/编程思想/mvc mvp mvvm clean/为什么要把Dagger2,MVP以及Rxjava引入项目中/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/14/编程思想/mvc mvp mvvm clean/为什么要把Dagger2,MVP以及Rxjava引入项目中/" itemprop="url">为什么要把Dagger2,MVP以及Rxjava引入项目中</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-14T09:03:53+08:00">
                2019-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程思想/" itemprop="url" rel="index">
                    <span itemprop="name">编程思想</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://www.jianshu.com/p/91c2bb8e6369" target="_blank" rel="noopener">为什么要把Dagger2,MVP以及Rxjava引入项目中</a></p>
<p>毫无疑问在Android开发圈中这三个技术是经常被提及的,如此多的文章和开源项目在介绍他们,使用他们</p>
<pre><code>其实我们大多数项目中是使用不到他们的,或者说对这些技术的需求不是很大,为什么这么说呢？
</code></pre><ul>
<li>大多数的开发者其实都是在开发功能模块比较少的小项目,对于这些项目来说,其实使用这些技术带来的好处相对于在开发时的所付出的时间来说其实性价比并不高。因为学习这些会有个学习曲线,并且这些技术并不会让你的开发速度加快,相反会让你多写很多代码,比如MVP和Dagger都会让你多写很多类和接口</li>
</ul>
<ul>
<li><p>所以说我们开发小项目根本是感觉不到这些技术给我们带来的好处,也会困惑我们为什么要引入这些技术?</p>
<pre><code>那为什么这些技术会这么火呢？
</code></pre></li>
</ul>
<p>其实这些困惑大多出现在一直做功能模块比较少的小项目的开发者上。</p>
<p>只要你做过比较大的项目,随着代码的增多你就会遇到代码的耦合,团队协作时冲突的解决,类依赖的复杂度等问题，其实这些技术就是来解决这些问题的,所以这些技术大项目用的非常多</p>
<pre><code>这些技术出现是为了解决什么？
</code></pre><p>想灵活运用一个技术,必然要了解这些技术为什么出现,出现是为了解决什么问题</p>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>我个人的理解就是 <code>解耦</code> 和 <code>扩展</code> 以及 <code>团队协作</code>。</p>
<p>大多数文章都只是介绍了怎么写MVP接口,不懂为什么用他们,就算会写也只是在做复制粘贴</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul>
<li><p>我们需要用户点击按钮从网络获取一段新闻消息显示到TextView上,如果都在Activity中做这些事情,OK,非常爽,不用多写MVP相关的接口和类,啪啪啪一下就写完了</p>
</li>
<li><p>但是我们现在需求变了,我们要加入缓存,并且不用TextView显示,使用Toast显示,现在去改Activity,虽然麻烦,但是没问题，都是你写的。但是如果不是你写的,要把逻辑重新看一遍,并且如果改错的话,会影响之前已经写好的功能,这完全违背开闭原则</p>
</li>
<li><p>但是我们用MVP去开发,就可以缩小这些问题,我们只需要在Model层加入缓存逻辑,因为Presenter层拿到的是Model的接口,他只关心Model层返回的数据,至于你的接口是怎么实现的,你的数据是从网络还是数据库还是本地文件获取的,根本不必关心</p>
</li>
<li><p>Presenter拿到的是View的接口,Presenter从Model获取完数据,返回给View,就完成了他的工作,他根本不用管View是怎么实现的,使用TextView显示还是Toast显示,这些都是View的事情,所以他们每层只用把各自的事情做好根本不用管以外的事情</p>
</li>
<li><p>这样我们就可以把View,Presenter,Model给三个不同的人写,需求一变不会影响整个代码,将问题最小化,比如UI需求一变我们只用修改View层,出了问题可以马上定位,并且易于测试</p>
</li>
</ul>
<h2 id="Dagger"><a href="#Dagger" class="headerlink" title="Dagger"></a>Dagger</h2><p>Dagger的门槛个人认为在这三个中是最高的</p>
<p>很多只是讲怎么写这些类,注解该怎么用,都没讲为什么不直接new,为什么要把如此简单的事情弄这么复杂?</p>
<p>其实这还是和项目的大小有关,因为它解决的问题就是大项目的需求</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><ul>
<li><p>大型项目的实际情况是这样的</p>
<pre><code>A a = new A();
B b = new B(a);
C c = new C(a,b);
D d = new D(c);
E e = new E(a,b,d);
</code></pre></li>
<li><p>以上例子,构建一个E,还要构建一堆其他的对象,并且其他对象的构建同样复杂,并且必须按顺序构建,而且需要的对象的生命周期都不一样,有些生命周期可能和Activity一样,有些可能是单例,所以在构建的时候还要考虑对象声明周期,考虑对象的来源,在大型项目,这很痛苦,不光用起老火,别人看代码也和看天书一样</p>
</li>
<li><p>所以这个时候依赖注入框架就派上用场了,我们只用专注于怎么实现功能,对象的依赖关系和生命周期,都让它来帮我们管理,一个Inject,它会按照依赖关系帮我们注入我们需要的对象,并且它会管理好每个对象的生命周期,在生命周期还没结束的情况下是不会重复new的,所以Dagger非常适合大项目,小项目开发者因为项目复杂度低,没遇到这些问题,所以不会理解为什么要用Dagger,让简单的new,变这么复杂</p>
</li>
</ul>
<h2 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h2><p>提到Rxjava最多人都是用来处理 线程调度,回调地狱,加上Retrofit又支持Rxjava,所以大部分开发者都只会在请求网络和需要切换线程的时候用到Rxjava,其实它有一个最重要的特性,它可以让数据的流向更加直观,代码更清晰</p>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><ul>
<li><p>一个庞大的项目,一个事件传递的过程可能要经历很多方法,方法套方法,每个方法的位置七零八落,一个个方法跳进去看,跳过去跳过来很容易把脑袋弄晕,不够直观,但是Rxjava可以把所有逻辑用链式加闭包的方式呈现,做了哪些操作,谁在前谁在后非常直观,逻辑清晰,维护就会非常轻松,就算不是你写的你也可以很快的了解</p>
</li>
<li><p>你可以把它看作一条河流,整个过程就是对里面的水流做进行加工,懂了这个特性我们才知道在复杂的逻辑中运用Rxjava是多么的重要</p>
</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><ul>
<li><p>学习新技术,我们不应该盲目的跟风,我们如果不知道这个技术为什么出现,出现是为了解决什么,我们也就不知道为什么运用它,我们就算在项目中使用也无法灵活运用,非常浅显的使用,复制粘贴一些模版代码,也根本无法扩展自己的思维</p>
</li>
<li><p>这些技术虽然比较适合大项目一点,但是还是建议各位开发者开始使用他们,使用他们能扩展自己的思维,让自己考虑耦合,扩展,团队协作之类大项目才会考虑的问题,你如果一直重复的按最简单的方式写项目,什么都不考虑,你就算是5年经验,也只是以第一年的经验重复5年</p>
</li>
<li><p>最后介绍一个将MVP,Dagger,Retrofit,Rxjava等技术相结合并用于快速开发的框架,如果想搭建一个新项目使用这些技术,改了包名就可以直接使用,包含详细的文档,相比于这些技术漫长的学习曲线,我们在实践中学习他们不是更快吗？</p>
</li>
</ul>
<p><a href="https://github.com/JessYanCoding/MVPArms" target="_blank" rel="noopener">MVPArms Mvp快速集成框架</a></p>
<p><a href="http://www.jianshu.com/p/48e66e879061" target="_blank" rel="noopener">MVPArms Mvp快速集成框架使用</a> </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/14/编程思想/ioc框架--注解和反射/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/14/编程思想/ioc框架--注解和反射/" itemprop="url">分层架构与 M-V-X</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-14T08:58:53+08:00">
                2019-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程思想/" itemprop="url" rel="index">
                    <span itemprop="name">编程思想</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ioc框架–注解和反射<br>来自张鸿洋博客 <a href="http://blog.csdn.net/lmj623565791/article/details/39269193" target="_blank" rel="noopener">http://blog.csdn.net/lmj623565791/article/details/39269193</a><br>IoC，控制反转（Inversion of Control，英文缩写为IoC）<br>1.为什么要ioc<br>    一个类里面需要用到很多个成员变量，传统的写法，你要用这些成员变量，那么你就new 出来用呗~~<br>    IoC的原则是：不要new，这样耦合度太高；你配置个xml文件，里面标明哪个类，里面用了哪些成员变量，等待加载这个类的时候，我帮你注入（new）进去；<br>    所以，在现代软件分层开发中，每一层要一个包放接口，一个包放实现类<br>        而ioc只要声明了成员变量+写个配置文件，有人帮你new；<br>        此时，在类中就可以把需要使用到的成员变量都声明成接口，<br>        然后你会发现，当实现类发生变化的时候，或者切换实现类，你只要在配置文件里面做个简单的修改。<br>        如果你用的就是实实在在的实现类，现在换实现类，你需要找到所有声明这个实现类的地方，逐个手动修改类名<br>    有人说，写个配置文件多麻烦。于是又出现了另一种方案。<br>    注解–在需要注入的成员变量上面加个注解<br>2.如何注入<br>    配置文件/注解 是如何实现注入的？<br>    其实就是把字符串类路径变成类。这就需要用到反射了。<br>3.注入框架实现–xUtils<br>    使用实例<br>        @ContentView(value = R.layout.activity_main)<br>        public class MainActivity extends BaseActivity {<br>            @ViewInject(R.id.id_btn)<br>            private Button mBtn1;<br>            @ViewInject(R.id.id_btn02)<br>            private Button mBtn2;<br>            public void onCreate(Bundle savedInstanceState) {<br>                super.onCreate(savedInstanceState);<br>                ViewUtils.inject(this);<br>            }<br>        }<br>    实现<br>        @Target(ElementType.TYPE)<br>        @Retention(RetentionPolicy.RUNTIME)<br>        public @interface ContentView<br>        {<br>            int value();<br>        }<br>        @Target(ElementType.FIELD)<br>        @Retention(RetentionPolicy.RUNTIME)<br>        public @interface ViewInject<br>        {<br>            int value();<br>        }<br>        public static void inject(Activity activity) {<br>            injectContentView(activity);<br>            injectViews(activity);<br>        }<br>        (1)注入主布局文件的代码<br>            private static void injectContentView(Activity activity) {<br>                Class&lt;? extends Activity&gt; clazz = activity.getClass();<br>                // 查询类上是否存在ContentView注解<br>                ContentView contentView = clazz.getAnnotation(ContentView.class);<br>                if (contentView != null)// 存在<br>                {<br>                    int contentViewLayoutId = contentView.value();<br>                    try<br>                    {<br>                        Method method = clazz.getMethod(“setContentView”, int.class);<br>                        method.setAccessible(true);<br>                        method.invoke(activity, contentViewLayoutId);<br>                    } catch (Exception e)<br>                    {<br>                        e.printStackTrace();<br>                    }<br>                }<br>            }<br>            通过传入的activity对象，获得它的Class类型，判断如果该类写了ContentView这个注解，读取它的value，然后得到setContentView这个方法，使用invoke进行调用；<br>        (2)注入Views<br>            private static void injectViews(Activity activity) {<br>                Class&lt;? extends Activity&gt; clazz = activity.getClass();<br>                Field[] fields = clazz.getDeclaredFields();<br>                // 遍历所有成员变量<br>                for (Field field : fields)<br>                {<br>                    ViewInject viewInjectAnnotation = field.getAnnotation(ViewInject.class);<br>                    if (viewInjectAnnotation != null){<br>                        int viewId = viewInjectAnnotation.value();<br>                        if (viewId != -1){<br>                            Log.e(“TAG”, viewId+””);<br>                            // 初始化View<br>                            try {<br>                                Method method = clazz.getMethod(“findViewById”, int.class);<br>                                Object resView = method.invoke(activity, viewId);<br>                                field.setAccessible(true);<br>                                field.set(activity, resView);<br>                            } catch (Exception e) {<br>                                e.printStackTrace();<br>                            }<br>                        }<br>                    }<br>                }<br>            }<br>            遍历类中声明的所有属性，找到存在ViewInject注解的属性并获取其value，然后去调用findViewById方法，最后把值设置给field</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/14/编程思想/分层架构与 M-V-X/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/14/编程思想/分层架构与 M-V-X/" itemprop="url">分层架构与 M-V-X</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-14T08:58:53+08:00">
                2019-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程思想/" itemprop="url" rel="index">
                    <span itemprop="name">编程思想</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>分层架构与 M-V-X</p>
<p>分层架构是一种常见的软件应用架构<br>在 Java 程序中可以算是一种应用标准了，通常又叫 N 层架构<br>而最常见的是 3 层架构，它包含如下 3 层：<br>    展示层（Presentation tier），也称为 UI 层，也就是程序的界面部分。</p>
<pre><code>业务层（business logic(domain) tier）， 业务层，是最为核心的一层。

持久层（Data tier），数据持久层。
</code></pre><p>3 层架构是存在物理上分层概念的，<br>从上往下即展示层、业务层、持久层，也从上往下由上一层依赖下一层。<br>不同层之间也是 高内聚低耦合 的体现，层内高内聚，层间低耦合，<br>层 是层内具体工作的高度抽象。<br>低耦合则是依赖倒转原则体现出来，高层依赖于下层的抽象而不是具体。</p>
<p>在分层架构中 M-V-X 是在展示层（Presentation tier）的应用</p>
<p>M-V-X 的鼻祖 MVC<br>Model–View–Controller (MVC) is a software architectural pattern for implementing user interfaces.<br>Model，domain model（领域模型）是数据层代表的数据模型，<br>    也可以理解为用户界面需要显示数据的抽象（数据）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/14/编程思想/Clean code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/14/编程思想/Clean code/" itemprop="url">CleanCode</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-14T08:56:53+08:00">
                2019-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程思想/" itemprop="url" rel="index">
                    <span itemprop="name">编程思想</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第一章、-整洁代码"><a href="#第一章、-整洁代码" class="headerlink" title="第一章、 整洁代码"></a>第一章、 整洁代码</h2><p>我们一直需要整洁代码。 可预见的未来，自动化产生代码无法替代人工编写。</p>
<h2 id="第二章、-有意义的命名"><a href="#第二章、-有意义的命名" class="headerlink" title="第二章、 有意义的命名"></a>第二章、 有意义的命名</h2><h2 id="2-2-名副其实"><a href="#2-2-名副其实" class="headerlink" title="2.2 名副其实"></a>2.2 名副其实</h2><p>名称应该答复了所有大问题。 为何存在，何用，如何用</p>
<p>如果名称需要注释类补充，就不是名副其实</p>
<p>实例： 消逝的时间，以日记</p>
<pre><code>elapsedTimeInDay;
daysSinceCreation
fileAgeInDay
</code></pre><h2 id="2-3-避免误导"><a href="#2-3-避免误导" class="headerlink" title="2.3 避免误导"></a>2.3 避免误导</h2><ul>
<li><p>避免留下误导的错误仙索。</p>
<p>  实例： 一组账号</p>
<pre><code>accountList 最好别用，即使真是List&lt;Account&gt;。List对程序员有特殊含义
accounts 推荐使用
</code></pre></li>
<li><p>避免使用不同之处较小的名称</p>
<p>  现代IDE都能自动提示自动补全，假如相似的名称放在一起，不同之处较小，分清楚得花多少时间</p>
</li>
</ul>
<h2 id="2-4-做有意义的区分"><a href="#2-4-做有意义的区分" class="headerlink" title="2.4 做有意义的区分"></a>2.4 做有意义的区分</h2><p>错误示例：</p>
<ul>
<li>a,b,c</li>
<li>list1,list2</li>
<li>Product,ProductInfo,ProductData</li>
<li>name,nameString</li>
</ul>
<h2 id="使用读得出来的名称"><a href="#使用读得出来的名称" class="headerlink" title="使用读得出来的名称"></a>使用读得出来的名称</h2><p>方便交流</p>
<h2 id="2-6-使用可搜索的名称"><a href="#2-6-使用可搜索的名称" class="headerlink" title="2.6 使用可搜索的名称"></a>2.6 使用可搜索的名称</h2><p>单字母名称和数字常量，都是无法搜索</p>
<p>MAX_COLUM_PER_PAGE 能搜索出来，常量 7 麻烦了</p>
<h2 id="2-7-避免使用编码"><a href="#2-7-避免使用编码" class="headerlink" title="2.7 避免使用编码"></a>2.7 避免使用编码</h2><p>现在语言中使用编码，纯属多余的负担</p>
<h3 id="2-7-1-匈牙利命名法"><a href="#2-7-1-匈牙利命名法" class="headerlink" title="2.7.1 匈牙利命名法"></a>2.7.1 匈牙利命名法</h3><p>windows c 语言 API 时代，程序员需要匈牙利命名法来帮助自己记住类型。</p>
<ul>
<li>类型不好区分：整数句柄，长指针，void指针，string的几种实现（不同属性/用途）</li>
<li>编译器不做类型检查</li>
</ul>
<h3 id="2-7-2-成员前缀"><a href="#2-7-2-成员前缀" class="headerlink" title="2.7.2 成员前缀"></a>2.7.2 成员前缀</h3><p>类和函数足够小，自然不需要 m_ 前缀来表明成员变量</p>
<p>现代IDE 都自动用高亮来 标识成员变量</p>
<h3 id="2-7-3-接口和实现"><a href="#2-7-3-接口和实现" class="headerlink" title="2.7.3 接口和实现"></a>2.7.3 接口和实现</h3><p>用户根本不需要知道这个是接口。</p>
<p>我说如果，一定要选一个编码的话，宁愿选择给实现编码。</p>
<h2 id="2-8-避免思维映射"><a href="#2-8-避免思维映射" class="headerlink" title="2.8 避免思维映射"></a>2.8 避免思维映射</h2><p>不要让读者非得把你的名称映射/翻译为他们熟知的名称。 明确是王道</p>
<h2 id="2-9-类名"><a href="#2-9-类名" class="headerlink" title="2.9 类名"></a>2.9 类名</h2><ul>
<li><p>类名应是名词/名词短语。</p>
<pre><code>Address，AddressParser
</code></pre></li>
<li><p>避免使用Manager，Processor，Data，Info。 出现说明类过大/命名不明确</p>
</li>
</ul>
<h2 id="2-10-方法名"><a href="#2-10-方法名" class="headerlink" title="2.10 方法名"></a>2.10 方法名</h2><ul>
<li><p>方法名应是动词</p>
<pre><code>deletePage，save
</code></pre></li>
<li><p>重载构造器是，使用静态工厂方法名</p>
<pre><code>Message.fromType(1) 好过 new Message(1);
</code></pre></li>
</ul>
<h2 id="2-11-别扮可爱"><a href="#2-11-别扮可爱" class="headerlink" title="2.11 别扮可爱"></a>2.11 别扮可爱</h2><p>别为了扮可爱，用一些不好理解的词命名</p>
<h2 id="2-12-每个概念对应一个词"><a href="#2-12-每个概念对应一个词" class="headerlink" title="2.12 每个概念对应一个词"></a>2.12 每个概念对应一个词</h2><p>给每个抽象概念选一个词，并一以贯之。</p>
<p>错误范例： </p>
<ul>
<li>使用 <code>fetch</code> , <code>retrive</code>, <code>find</code>, <code>get</code> 来给查询命名，怎么记得住哪个类中用哪个方法呢</li>
<li><code>controller</code> , <code>manager</code> , <code>driver</code></li>
</ul>
<h2 id="2-13-别用双关语（一个词用于多个概念-目的）"><a href="#2-13-别用双关语（一个词用于多个概念-目的）" class="headerlink" title="2.13 别用双关语（一个词用于多个概念/目的）"></a>2.13 别用双关语（一个词用于多个概念/目的）</h2><p><code>add</code> 用于多个场景/目的：</p>
<ul>
<li>连接两个字符串。 <code>append</code> 就挺好</li>
<li>将一个对象放到集合中。 <code>insert</code> 可以</li>
</ul>
<h2 id="2-14-使用解决方案领域名称"><a href="#2-14-使用解决方案领域名称" class="headerlink" title="2.14 使用解决方案领域名称"></a>2.14 使用解决方案领域名称</h2><p>只有程序员才会读你的代码，放心地使用解决方案领域名称吧。</p>
<p>使用问题领域名称，难道你指望你的客户会跟你讨论代码。</p>
<h2 id="2-15-使用源自所涉问题领域的名称"><a href="#2-15-使用源自所涉问题领域的名称" class="headerlink" title="2.15 使用源自所涉问题领域的名称"></a>2.15 使用源自所涉问题领域的名称</h2><p>如果实在不能用解决方案领域名称命名，那就用所涉问题领域名称吧。至少，负责维护的程序员就能去请教领域专家了。</p>
<h2 id="2-16-添加有意义的语境"><a href="#2-16-添加有意义的语境" class="headerlink" title="2.16 添加有意义的语境"></a>2.16 添加有意义的语境</h2><p>多数名称都不能自我说明，需要良好命令的类、函数、名称空间来提供语境。如果没有，给名称添加前缀是最后一招了。</p>
<p>addressFirstName，addressState</p>
<h1 id="第三章、函数"><a href="#第三章、函数" class="headerlink" title="第三章、函数"></a>第三章、函数</h1><h2 id="3-1-短小"><a href="#3-1-短小" class="headerlink" title="3.1 短小"></a>3.1 短小</h2><h3 id="代码块和缩进"><a href="#代码块和缩进" class="headerlink" title="代码块和缩进"></a>代码块和缩进</h3><p>代码块(if/else,while等)应该只有一行（调用函数），缩进层级不该多于两层。</p>
<h2 id="3-2-只做一件事"><a href="#3-2-只做一件事" class="headerlink" title="3.2 只做一件事"></a>3.2 只做一件事</h2><p>判断函数是否只做了一件事：能否再拆出一个函数</p>
<h2 id="3-3-每个函数一抽象层级"><a href="#3-3-每个函数一抽象层级" class="headerlink" title="3.3 每个函数一抽象层级"></a>3.3 每个函数一抽象层级</h2><p>如何确保函数只做一件事：函数中的语句都在同一抽象层级上。</p>
<h3 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h3><p>每个函数后面紧跟位于下一抽象层级的函数（被调用的函数）</p>
<h2 id="3-4-switch语句"><a href="#3-4-switch语句" class="headerlink" title="3.4 switch语句"></a>3.4 <a href="http://feikiss.iteye.com/blog/1454010" target="_blank" rel="noopener">switch语句</a></h2><p>即使只有两种条件的switch语句也比我想要的单个代码块或函数大得多。而switch天生要做N件事。</p>
<p>不幸我们总无法避开switch语句，我们可以<strong>利用多态来确保每个switch都埋藏在较低的抽象层级，且永不重复</strong>。</p>
<pre><code>public Money calculatePay(Employee e) thorws InvalidEmployeeType {  
    switch(e.type)  {  
       case COMMISSIONED:  
            return calculateCommissionedPay(e);  
       case HOURLY:  
            return calculateHourlyPay(e);  
       case SALARIED:  
             return calculateSalariedPay(e);  
       default:  
             throw new InvalidEmployeeType(e.type);  
}  
</code></pre><p>该函数问题：</p>
<ul>
<li>首先，太长，当出现新的雇员时，它还会更长</li>
<li>其次，明显做了不止一件事。</li>
<li>第三，违反了单一权责原则，因为有好几个修改它的理由。</li>
<li>第四，违反了开-关原则，因为每当添加新的雇员类型时，就必须修改它。</li>
<li><p>最麻烦的，可能是到处皆有类似结构的函数。都需要重复同样的switch结构</p>
<p>  例如，可能会有： </p>
<pre><code>isPayday(Employ e, Date date)  
deliverPay(Employee e, Money pay)
</code></pre></li>
</ul>
<p>解决方案：</p>
<p>将switch语句埋到抽象工厂底下，不让任何人看到。</p>
<p>使用switch语句为Employee的派生类创建适当的实体，而不同的函数，如calculatePay、isPayday和deliverPay等，则由Employee接口动态的调用相应子类方法。 </p>
<pre><code>public interface Employee{  
    public boolean isPayday();  
    public Money calculatePay();  
    public void deliverPay(Money pay);  

} 

public interface EmployeeFactory{  
    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;  
} 

public class EmployeeFactoryImpl implements EmployeeFactory{  
    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType{  
        switch(r.type){  
        case COMMISSIONED:  
            return new CommissionedEmployee(r);  
        case HOURLY:  
            return new HourlyEmployee(r);  
        case SALARIED:  
            return new SalariedEmployee(r);  
        default:  
            throw new InvalidEmployeeType(r.type);  
        }  
    }  
} 
</code></pre><h2 id="3-5-使用描述性的名称"><a href="#3-5-使用描述性的名称" class="headerlink" title="3.5 使用描述性的名称"></a>3.5 使用描述性的名称</h2><p>名称描述函数做的事</p>
<h2 id="3-6-函数参数"><a href="#3-6-函数参数" class="headerlink" title="3.6 函数参数"></a>3.6 函数参数</h2><p>尽量避免三个参数，有足够特殊的理由才能使用多参函数（三个参数以上）。</p>
<h3 id="3-6-1-一元函数的普遍形式"><a href="#3-6-1-一元函数的普遍形式" class="headerlink" title="3.6.1 一元函数的普遍形式"></a>3.6.1 一元函数的普遍形式</h3><h3 id="3-6-2-标识参数"><a href="#3-6-2-标识参数" class="headerlink" title="3.6.2 标识参数"></a>3.6.2 标识参数</h3><p>标识参数大声宣布，本函数不止做一件事。一定要避免。</p>
<h3 id="3-6-3-二元函数"><a href="#3-6-3-二元函数" class="headerlink" title="3.6.3 二元函数"></a>3.6.3 二元函数</h3><h3 id="3-6-4-三元函数"><a href="#3-6-4-三元函数" class="headerlink" title="3.6.4 三元函数"></a>3.6.4 三元函数</h3><h3 id="3-6-5-参数对象"><a href="#3-6-5-参数对象" class="headerlink" title="3.6.5 参数对象"></a>3.6.5 参数对象</h3><p>如果函数确实需要两个以上的参数，说明应将一些参数封装为类了。</p>
<h3 id="3-6-6-参数列表"><a href="#3-6-6-参数列表" class="headerlink" title="3.6.6 参数列表"></a>3.6.6 参数列表</h3><p>同类型的可变参数列表，其实可以算作一个参数（List类型的参数）</p>
<pre><code>public static String format(String format, Object... args)  二元函数
</code></pre><h3 id="3-6-7-动词与关键词"><a href="#3-6-7-动词与关键词" class="headerlink" title="3.6.7 动词与关键词"></a>3.6.7 动词与关键词</h3><p>好名字的函数，能很好的解释函数意图、参数顺序和意图</p>
<ul>
<li><p>动词</p>
<p>  一元函数。 函数名和参数名形成一种非常好的动词/名词形式</p>
<ul>
<li>write(name) write的对象是name</li>
<li>writeField(name) 更好的名词，同时声明name是一个field</li>
</ul>
</li>
<li><p>关键词</p>
<p>  把参数名称编码成函数名一部分，大大减轻记忆参数顺序的负担</p>
<ul>
<li>assertExpectedEquasActual(expected，actual）</li>
</ul>
</li>
</ul>
<h3 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h3><p>绝对不要使用输出参数。那是面向对象编程之前远古岁月的一个不得而为之的手段</p>
<h2 id="3-7-无副作用"><a href="#3-7-无副作用" class="headerlink" title="3.7 无副作用"></a>3.7 无副作用</h2><p>副作用是一种谎言。做了函数名说明的事情之外的事，就是副作用。</p>
<p>函数承诺只做一件事，做其他被藏起来的事，这是破坏性的，会导致时序性耦合和顺序依赖</p>
<ul>
<li>对类变量做出未能预期的改动</li>
<li>把变量搞成向函数传递的参数/系统全局变量</li>
</ul>
<p><code>public boolean checkPassword(userName, password)</code> 函数名只是校验密码，但是内部，当密码错误，却调用Session.initalize，这是非常致命的副作用。调用者冒着丢失现有会话数据的风险。时序性耦合令人迷惑，躲在函数副作用之后，就更难排查了。</p>
<h2 id="3-8-分隔指令与查询"><a href="#3-8-分隔指令与查询" class="headerlink" title="3.8 分隔指令与查询"></a>3.8 分隔指令与查询</h2><p>函数只做一件事：</p>
<ul>
<li>指令。修改对象</li>
<li>查询。查询对象</li>
</ul>
<p>实例：</p>
<pre><code>public boolean set(key,value) 设置某个属性，成功返回true

从读者角度考虑一下，if(set(&quot;username&quot;,&quot;bob&quot;)) 是什么含义：
    1. username属性值之前是否已经设置为bob
    2. username属性值设置为bob是否执行成功

作者本意，set是动词，是指令函数。但在if语句块中，set像个形容词
</code></pre><p>解决方案：分隔指令与查询</p>
<pre><code>if(keyExists(&quot;username&quot;)){
    setKeyValue(&quot;username&quot;,&quot;bob&quot;);
}
</code></pre><h2 id="3-9-使用异常代替返回错误码"><a href="#3-9-使用异常代替返回错误码" class="headerlink" title="3.9 使用异常代替返回错误码"></a>3.9 使用异常代替返回错误码</h2><p>指令函数返回错误码，违反分隔指令与查询规则。</p>
<p>返回错误码弊端：</p>
<ul>
<li>要求调用者立刻处理错误</li>
<li>造成异常处理代码与正常逻辑混合在一起</li>
<li>导致多层嵌套</li>
<li>依赖磁铁。错误码通常是一个类，许多地方都导入和使用，该类修改会影响所有使用该类的类。使用异常码，新异常可以直接从异常基类派生出来</li>
</ul>
<h3 id="3-9-1-抽离-try-catch-代码块"><a href="#3-9-1-抽离-try-catch-代码块" class="headerlink" title="3.9.1 抽离 try/catch 代码块"></a>3.9.1 抽离 try/catch 代码块</h3><p>try/catch 把 错误处理代码与正常逻辑混合在一起</p>
<pre><code>try {
    deletePage(page);
    registry.deleteReference(page.name);
    configKeys.deleteKey(page.name.makeKey());
}
catch (Exception e) {
    logger.log(e.getMessage());
}
</code></pre><p>抽离后</p>
<pre><code>public void delete(Page page) {
    try {
        deletePageAndAllReferences(page);
    } catch (Exception e) {
        logErrot(e);
    }
}

private void deletePageAndAllReferences(Page page) {
    deletePage(page);
    registry.deleteReference(page.name);
    configKeys.deleteKey(page.name.makeKey());
}

private void logErrot(Exception e) {

}
</code></pre><h3 id="3-9-2-错误处理就是一件事"><a href="#3-9-2-错误处理就是一件事" class="headerlink" title="3.9.2 错误处理就是一件事"></a>3.9.2 错误处理就是一件事</h3><h2 id="3-10-别重复自己"><a href="#3-10-别重复自己" class="headerlink" title="3.10 别重复自己"></a>3.10 别重复自己</h2><p>消除系统中的重复代码。</p>
<p>重复代码导致一个改变影响多处代码，修改过程中非常有可能遗漏</p>
<h1 id="第四章、-注释"><a href="#第四章、-注释" class="headerlink" title="第四章、 注释"></a>第四章、 注释</h1><p>注释承认自己代码表达能力的失败</p>
<p>注释不能美化糟糕的代码。</p>
<p>代码维护过程中，注释和代码分离是很常见的，大家维护的焦点就是代码，这时错误过时的注释，反而误导对代码的理解</p>
<h2 id="第五章、格式"><a href="#第五章、格式" class="headerlink" title="第五章、格式"></a>第五章、格式</h2><h2 id="第六章、-对象和数据结构-Objects-and-Data-Structures"><a href="#第六章、-对象和数据结构-Objects-and-Data-Structures" class="headerlink" title="第六章、 对象和数据结构 Objects and Data Structures"></a>第六章、 对象和数据结构 Objects and Data Structures</h2><p>私有变量的理由：</p>
<ul>
<li>保护数据</li>
<li>不被外部依赖，修改并不影响其他类</li>
</ul>
<p>但是，为什么有那么多程序员给对象添加 setter和getter，就如同公共变量一般？</p>
<h2 id="6-1-数据抽象"><a href="#6-1-数据抽象" class="headerlink" title="6.1 数据抽象"></a>6.1 数据抽象</h2><p>抽象：隐藏实现。并不是简单的在变量间放上一个函数层（setter/getter），而是暴露抽象接口，以便用户无需了解数据的实现就能操作数据</p>
<p>实例：机动车燃料层</p>
<pre><code>public interface Vehicle {
    double getFuelTankCapacityInGallons(); //油箱容量，单位加仑
    double getGallonsOfGasoline(); //汽油量，加仑
}

public interface Vehicle{
    double getFuelRemainingPercent(); //燃料剩余百分比
}
</code></pre><p>采用百分比抽象，无法确定Vehicle类中数据形态。</p>
<p>抽象并不是简单的setter/getter，而是以最好的方式呈现对象的数据</p>
<h2 id="6-2-数据、对象的反对称性-Anti-Symmetry"><a href="#6-2-数据、对象的反对称性-Anti-Symmetry" class="headerlink" title="6.2 数据、对象的反对称性 Anti-Symmetry"></a>6.2 数据、对象的反对称性 Anti-Symmetry</h2><p>数据结构和对象时对立的。</p>
<p><strong>对象和数据结构间的二分原理：</strong></p>
<ul>
<li><p>数据结构：</p>
<ul>
<li>暴露数据，不提供有意义的函数。</li>
<li><strong>面向过程/方法</strong>，不改动既有数据结构即可<strong>添加新函数</strong>，添加新数据结构得修改所有函数。（本身无方法，方法都在另一个类中）</li>
</ul>
</li>
<li><p>对象：</p>
<ul>
<li>隐藏数据，暴露行为。</li>
<li><strong>面向对象</strong>，不改动既有函数即可<strong>添加新对象</strong>，添加新函数所有对象都得修改。</li>
</ul>
</li>
</ul>
<p>优秀的开发者不带成见地了解两者，依据工作性质选择其中一种手段</p>
<p>代码：</p>
<ul>
<li><p>数据结构-面向过程</p>
<pre><code>public class Square{
    public point topLeft;
    public double side;
}

public class Rectangle{
    public point topLeft;
    public double height;
    public double width;
}

public class Geometry{//几何
    public double area(Object shape){
        if(shape instanceOf Square){
            Square s = (Square) shape;
            return s.side * s.side;
        }else if(shape instanceOf Rectangle){
            Rectangle r = (Rectangle) shape;
            return r.height * r.width;
        }
        throw new NoSuchShapeException();
    }
}
</code></pre><ul>
<li>想增加一个函数 perimeter 求周长，原有数据结构完全不受影响</li>
<li>想添加一个新数据结构，就得修改 所有已有函数来处理新数据结构</li>
</ul>
</li>
<li><p>对象-面向对象</p>
<pre><code>public interface Shape{
    double area();
}

public class Square implements Shape{
    public point topLeft;
    public double side;

    public double area(){
        return side * side;
    }
}

public class Rectangle implements Shape{
    public point topLeft;
    public double height;
    public double width;

    public double area(){
        return height * width;
    }
}
</code></pre><ul>
<li>想增加一个函数 perimeter 求周长，原有对象都得修改实现该函数</li>
<li>想添加一个新对象，原有函数都不会受影响</li>
</ul>
</li>
</ul>
<h2 id="6-3-Law-of-Demeter"><a href="#6-3-Law-of-Demeter" class="headerlink" title="6.3 Law of Demeter"></a>6.3 Law of Demeter</h2><p>迪米特法则（Law of Demeter 简写LoD）又叫作最少知道原则（Least Knowledge Principle 简写LKP），就是说一个对象应当对其他对象尽可能少的了解,不和陌生人说话。talk only to your immediate friends</p>
<h3 id="“朋友”类型："><a href="#“朋友”类型：" class="headerlink" title="“朋友”类型："></a>“朋友”类型：</h3><ol>
<li>当前对象本身（this）</li>
<li>方法参量对象</li>
<li>实例变量对象</li>
<li>实例变量如果是一个聚集，那么聚集中的元素也都是朋友</li>
<li>当前对象所创建的对象</li>
</ol>
<p><a href="http://www.cnblogs.com/silentjesse/p/3510966.html" target="_blank" rel="noopener">实例：老师让体育委员清点女生人数</a></p>
<pre><code>public class Teacher{
    public void command(GroupLeader groupLeader）{
        List&lt;Girl&gt; girls = new ArrayList();
        for(int i = 0; i&lt;20; i++){
            girls.add(new Girl());
        }

        groupLeader.countGirls(girls);
    }
}

public class GroupLeader{
    public void countGirls(List&lt;Girl&gt; girls){
        System.out.println(&quot;女生数量是：&quot; + girls.size());
    }
}

public class Girl{}

public class Client{
    public static void main(String[] args){
        Teacher teacher = new Teacher();
        teacher.commond(new GroupLeader());
    }
}
</code></pre><p>存在的问题：</p>
<ul>
<li>Teacher 只有一个朋友类 GroupLeader。 Teacher 完全不知道自己依赖Girl，这违反LoD，应该把 List<girl> girls 声明为成员变量</girl></li>
<li>Teacher 最少知道原则，完全不需要知道 Girl，所以即使 List<girl> girls 声明为成员变量，还是违反 最少知道原则</girl></li>
</ul>
<p>修改：</p>
<pre><code>public class Teacher{
    public void command(GroupLeader groupLeader）{
        groupLeader.countGirls();
    }
}

public class GroupLeader{
    private List&lt;Girl&gt; girls

    public GroupLeader（List&lt;Girl&gt; girls）{
        this.girls = girls;
    }

    public void countGirls(){
        System.out.println(&quot;女生数量是：&quot; + girls.size());
    }
}

public class Girl{}

public class Client{
    public static void main(String[] args){
        List&lt;Girl&gt; girls = new ArrayList();
        for(int i = 0; i&lt;20; i++){
            girls.add(new Girl());
        }

        Teacher teacher = new Teacher();
        teacher.commond(new GroupLeader(girls));
    }
}
</code></pre><h3 id="LoD-在设计中的应用"><a href="#LoD-在设计中的应用" class="headerlink" title="LoD 在设计中的应用"></a><a href="http://blog.csdn.net/lovelion/article/details/7563445" target="_blank" rel="noopener">LoD 在设计中的应用</a></h3><p>最少知道原则：</p>
<ul>
<li><p>尽量减少对象间的交互。 </p>
<ul>
<li>类耦合度越低，越利于复用</li>
<li>可以通过引入一个合理的第三者来降低对象间的耦合度</li>
</ul>
</li>
<li><p>尽量减少类的公共变量和公共方法。 处在松耦合中的类修改，不会对关联的类造成太大波及</p>
</li>
</ul>
<p>实例：单击按钮(Button)，列表框(List)、组合框(ComboBox)、文本框(TextBox)、文本标签(Label)发生改变</p>
<ul>
<li>存在的问题： 四个朋友类。扩展性差，不便于增加/删除控件</li>
<li>重构方案： 引入控件交互的中间类(Mediator调解人中介物)来降低界面控件之间的耦合度</li>
</ul>
<p><img src="http://my.csdn.net/uploads/201205/14/1336930673_6550.jpg" alt=""></p>
<h2 id="6-4-数据传送对象-Data-Transfer-Objects"><a href="#6-4-数据传送对象-Data-Transfer-Objects" class="headerlink" title="6.4 数据传送对象 Data Transfer Objects"></a>6.4 数据传送对象 Data Transfer Objects</h2><p>Data Transfer Objects（简写 DTO）：只有公共变量，没有方法的类，是最精练的数据结构。</p>
<p>非常有用的结构，尤其在通信场景中（数据库，网络等）</p>
<p>DTO 比 常用的 javaBean 更简洁</p>
<h1 id="第七章、错误处理"><a href="#第七章、错误处理" class="headerlink" title="第七章、错误处理"></a>第七章、错误处理</h1><h2 id="7-1-使用异常而非返回码"><a href="#7-1-使用异常而非返回码" class="headerlink" title="7.1 使用异常而非返回码"></a>7.1 使用异常而非返回码</h2><p>抛出异常代替返回错误码，这样调用代码很整洁，逻辑不会被错误错误处理搞乱</p>
<h2 id="7-2-先写-Try—Catch-Finally-语句"><a href="#7-2-先写-Try—Catch-Finally-语句" class="headerlink" title="7.2 先写 Try—Catch-Finally 语句"></a>7.2 先写 Try—Catch-Finally 语句</h2><p>能帮你定义代码应该期待什么</p>
<h2 id="7-3-使用不可控异常-unchecked-exception"><a href="#7-3-使用不可控异常-unchecked-exception" class="headerlink" title="7.3 使用不可控异常 unchecked exception"></a>7.3 使用不可控异常 unchecked exception</h2><p>可控异常–每个方法的签名声明可能抛出的异常</p>
<p>可控异常违反 开放/闭合原则，低层方法异常的修改必将影响高层方法的签名。如果catch语句在抛出异常的方法三个层级之上，catch语句和抛出异常处之间的每个方法签名中声明该异常，这成本太高，不值票价。</p>
<h2 id="7-4-给出异常发生的环境说明"><a href="#7-4-给出异常发生的环境说明" class="headerlink" title="7.4 给出异常发生的环境说明"></a>7.4 给出异常发生的环境说明</h2><p>抛出的每个异常，须提供足够的环境说明，以便判断错误来源和处所</p>
<p>java的stack trace 无法告知异常的初衷</p>
<h2 id="7-5-依调用者需要定义异常类"><a href="#7-5-依调用者需要定义异常类" class="headerlink" title="7.5 依调用者需要定义异常类"></a>7.5 <code>依调用者需要</code>定义异常类</h2><p>定义异常类最重要的考虑：<strong>异常该如何被捕获</strong></p>
<p><code>没太理解</code> 例子是 封装一个抛出多种异常的三方API为一个自定义异常，从而整洁代码</p>
<h2 id="7-6-定义常规流程"><a href="#7-6-定义常规流程" class="headerlink" title="7.6 定义常规流程"></a>7.6 定义常规流程</h2><p>遵循前文的建议，业务逻辑和错误处理会良好分离。</p>
<p>却把错误处理推到的程序边缘地带。封装三方API而抛出自定义的异常，只在最顶层处理错误。</p>
<p>但有时候，你可以不用抛出异常</p>
<p>下面的笨代码，计算 工资总数: <code>如果有餐食花费，计入总额，如果没有则获得每日标准餐补，计入总额</code>。</p>
<pre><code>try{
    MealExpenses expenses = expensesDAO.getMeals(employeeId);
    total += expenses.getTotal();
}catch(MealExpensesNotFound e){
    total += getMealPerDiem(); //PerDiem allowance 按日补贴
}
</code></pre><p>异常打断了义务逻辑。如果不用处理特殊情况，代码会整洁很多</p>
<p>实现方法是使用 <strong>特例模式（Special Case Pattern）</strong>。使用一个特例类封装异常，客户代码就不用处理异常了</p>
<p>具体到上例：expensesDAO.getMeals 总是返回 MealExpenses。若没有餐食花费，返回一个 餐食补贴的 MealExpenses 对象</p>
<pre><code>public class PerDiemMealExpenses implements MealExpenses{}
</code></pre><h2 id="7-7-别返回null"><a href="#7-7-别返回null" class="headerlink" title="7.7 别返回null"></a>7.7 别返回null</h2><p>随处可见的 null 检查，代码糟糕透了。</p>
<p>返回null，不如抛出异常。</p>
<p>特例对象是爽口良药。</p>
<p>如果三方API可能返回null，考虑重新封装，在新方法中抛异常或返回特例对象。</p>
<h2 id="7-8-别传递null"><a href="#7-8-别传递null" class="headerlink" title="7.8 别传递null"></a>7.8 别传递null</h2><p>返回null很糟糕，传递null更糟糕。</p>
<p>在定义方法时，使用@NotNull 注解</p>
<h2 id="7-9-总结"><a href="#7-9-总结" class="headerlink" title="7.9 总结"></a>7.9 总结</h2><p>整洁代码要可读，也要强固。</p>
<p>可读与强固并不冲突。</p>
<p>分离业务逻辑和错误处理，就能写出可读而强固的整洁代码</p>
<h1 id="第八章、边界"><a href="#第八章、边界" class="headerlink" title="第八章、边界"></a>第八章、边界</h1><h2 id="8-1-使用第三方代码"><a href="#8-1-使用第三方代码" class="headerlink" title="8.1 使用第三方代码"></a>8.1 使用第三方代码</h2><p>接口提供者和接口使用者之间，存在与生俱来的张力。提供者追求普适性以吸引广泛用户，使用者追求集中满足特定需求。这种张力会导致系统边界上出现问题。</p>
<p><strong>以java.util.Map为例</strong></p>
<p>Map提供了丰富灵活的方法，但也要付出代价。</p>
<ul>
<li>Map中可以存放任何类型对象，访问对象时需要判断与转换类型。 <code>Sensor s = (Sensor) sensors.get(sendorId)</code></li>
<li>当Map被修改时，所有用到Map的地方都要跟着修改。Java 5 加入泛型支持，的确见到很多系统都要做大量改动才能</li>
<li>超出控制。我们初衷可能不允许删除Map中的任何对象，但Map提供了删除接口</li>
</ul>
<p>整洁方式</p>
<p>public class sensors{<br>    private Map&lt;string,Sendor&gt; sensors = new HashMap();</p>
<pre><code>public Sensor getById(String id){
    return sensors.get(id);
}
</code></pre><p>}</p>
<p>边界接口（Map）是隐藏的。该接口封装后能适应业务的需要，易于理解，难以误用</p>
<h2 id="8-2-浏览和学习边界"><a href="#8-2-浏览和学习边界" class="headerlink" title="8.2 浏览和学习边界"></a>8.2 浏览和学习边界</h2><p>学习第三方代码很难。整合第三方代码也很难。同时做这两件事难上加难。</p>
<p>更好的做法是，不要在生产代码中实验新东西，而是编写测试来遍览和理解第三方代码。即<strong>学习型测试</strong>。</p>
<h2 id="8-3-学习log4j"><a href="#8-3-学习log4j" class="headerlink" title="8.3 学习log4j"></a>8.3 学习log4j</h2><p>Log4j是一个功能强大的日志组件,提供方便的日志记录</p>
<h2 id="8-4-学习性测试的好处不只是免费"><a href="#8-4-学习性测试的好处不只是免费" class="headerlink" title="8.4 学习性测试的好处不只是免费"></a>8.4 学习性测试的好处不只是免费</h2><p>学习性测试不光免费，还在投资上有正面的回报。</p>
<p>当第三方程序包发布了新版本，我们可以运行学习性测试，看看程序包的行为有没有改变。</p>
<p>无论你是否通过学习型测试来学习，总要有与生产代码调用方式一直的测试来支持整洁的边界。边界测试是减轻迁移劳力的有效方法。</p>
<h2 id="8-5-使用尚不存在的代码"><a href="#8-5-使用尚不存在的代码" class="headerlink" title="8.5 使用尚不存在的代码"></a>8.5 使用尚不存在的代码</h2><p>还有另一种边界，那种将已知和未知分隔开的边界。在代码中总有许多地方是我们的知识未及之处。有时，边界那边就是未知的（至少目前未知）。有时，我们并不往边界那边看过去。</p>
<p>工作中，并发编程总是在边界接口未实现的情况下开始工作。自定义接口（模拟对依赖接口的封装）就很有用了</p>
<h2 id="8-6-整洁的边界"><a href="#8-6-整洁的边界" class="headerlink" title="8.6 整洁的边界"></a>8.6 整洁的边界</h2><p>依赖你能控制的东西，好过依赖你控制不了的东西，免得日后受它控制。</p>
<p>可以像上文对象Map那样<strong>包装</strong>他们，也可以使用 <strong>适配器模式（Adapter Pattern）</strong>将我们的接口转换为第三方接口。</p>
<h1 id="第十章、类"><a href="#第十章、类" class="headerlink" title="第十章、类"></a>第十章、类</h1><h2 id="10-1-类的组织"><a href="#10-1-类的组织" class="headerlink" title="10.1 类的组织"></a>10.1 类的组织</h2><p>遵循自顶向下原则，让程序读起来像一篇报纸。</p>
<p>顺序：先静态，后实体；先公有，后私有；</p>
<p>私有函数应紧跟调用它的公有函数。</p>
<h2 id="10-2-类应该短小"><a href="#10-2-类应该短小" class="headerlink" title="10.2 类应该短小"></a>10.2 类应该短小</h2><p><strong>函数大小标准：代码行数；类大小标准：权责（Responsibility）数量</strong></p>
<p><strong>类名应当描述其权责</strong>。命名正是帮组判断类长度的一个手段。如果无法为类精确命名，这个类大概就太长了。类中包括含义模糊的词（如Processor、Manager，Super）,说明有不恰当的权责聚集</p>
<h3 id="10-2-1-单一权责原则-SRP"><a href="#10-2-1-单一权责原则-SRP" class="headerlink" title="10.2.1 单一权责原则 SRP"></a>10.2.1 单一权责原则 SRP</h3><p><strong>类或模块应且只有一条加以修改的理由</strong>。</p>
<p>鉴别权责（修改理由）常常帮助我们认识并创建更好的抽象</p>
<p>很多开发者害怕数量巨大的短小类会导致难以一目了然抓住全局。常常为了搞清一个功能而在类间跳来跳去。</p>
<p>问题是：抽屉中有许多定义和标记良好的小箱子，还是把工具随便扔到抽屉中，更容易组织管理呢？</p>
<p><strong>系统应由许多短小的类组成，而不是少量巨大的类组成。每个小类封装一个权责，只有一个修改的理由，并与其他类一起协同完成系统行为</strong></p>
<h3 id="10-2-2-内聚"><a href="#10-2-2-内聚" class="headerlink" title="10.2.2 内聚"></a>10.2.2 内聚</h3><p>类应该只有少量实体变量。通常而言，方法操作的变量越多，就越黏聚到类上。如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。</p>
<p>一般来说，创建极大化内聚类是既不可取也不可能的；另一方面，我们希望内聚性保持在较高位置。</p>
<p>内聚性高，意味着类中的方法和变量互相依赖、互相结合成一个逻辑整体。</p>
<p>保持函数参数列表短小，有时会导致类实体变量增多。这时往往意味着需要拆分类，提高内聚性。</p>
<h3 id="10-2-3-保持内聚性就会得到许多短小的类"><a href="#10-2-3-保持内聚性就会得到许多短小的类" class="headerlink" title="10.2.3 保持内聚性就会得到许多短小的类"></a>10.2.3 保持内聚性就会得到许多短小的类</h3><p>仅仅简单将大函数切割为小函数，而且保持函数参数简洁，会导致实体变量增多。比如，大函数用到4个变量，函数拆分后就得变成四个实体变量。</p>
<p>而这4个变量可能就2个方法使用了，这意味着丧失了内聚性。</p>
<p>如果就这2个方法需要共享变量，为什么不让它们拥有自己的类呢？当丧失了内聚性，就拆分它们为单独的类。将大函数拆分为小函数，往往也是拆分为小类的时机。程序会更多有组织结构。</p>
<h4 id="打印质数实例重构"><a href="#打印质数实例重构" class="headerlink" title="打印质数实例重构"></a>打印质数实例重构</h4><p>原程序只有一个大行数，简直一团糟。很深的缩进结构，冗余的变量，紧密耦合的结构</p>
<p>重构和原程序采用同样算法和机制，重构后程序被拆分为3个权责：</p>
<ul>
<li>PrimePrinter 主程序，权责是处理执行环境，因调用方式而改变，例如程序被转换为SOAP服务，该类会被影响</li>
<li>PrimeGenerator 权责是生成质数列表，因质数算法而改变</li>
<li>RowColumnPagePrinter 权责是格式化数字列表成固定行列的列表，因输出格式而改变</li>
</ul>
<p>代码如下：</p>
<ul>
<li><p>PrimePrinter</p>
<pre><code>public class PrimePrinter {
  public static void main(String[] args) {
    final int NUMBER_OF_PRIMES = 1000;
    int[] primes = PrimeGenerator.generate(NUMBER_OF_PRIMES);

    final int ROWS_PER_PAGE = 50;
    final int COLUMNS_PER_PAGE = 4;
    RowColumnPagePrinter tablePrinter =
      new RowColumnPagePrinter(ROWS_PER_PAGE,
                               COLUMNS_PER_PAGE,
                               &quot;The First &quot; + NUMBER_OF_PRIMES +
                                 &quot; Prime Numbers&quot;);

    tablePrinter.print(primes);
  }
}
</code></pre></li>
<li><p>PrimeGenerator</p>
<pre><code>public class PrimeGenerator {
  private static int[] primes;
  private static ArrayList&lt;Integer&gt; multiplesOfPrimeFactors;

  protected static int[] generate(int n) {
    primes = new int[n];
    multiplesOfPrimeFactors = new ArrayList&lt;Integer&gt;();
    set2AsFirstPrime();
    checkOddNumbersForSubsequentPrimes();
    return primes;
  }

  private static void set2AsFirstPrime() {
    primes[0] = 2;
    multiplesOfPrimeFactors.add(2);
  }

  private static void checkOddNumbersForSubsequentPrimes() {
    int primeIndex = 1;
    for (int candidate = 3;
         primeIndex &lt; primes.length;
         candidate += 2) {
      if (isPrime(candidate))
        primes[primeIndex++] = candidate;
    }
  }

  private static boolean isPrime(int candidate) {
    if (isLeastRelevantMultipleOfNextLargerPrimeFactor(candidate)) {
      multiplesOfPrimeFactors.add(candidate);
      return false;
    }
    return isNotMultipleOfAnyPreviousPrimeFactor(candidate);
  }

  private static boolean
  isLeastRelevantMultipleOfNextLargerPrimeFactor(int candidate) {
    int nextLargerPrimeFactor = primes[multiplesOfPrimeFactors.size()];
    int leastRelevantMultiple = nextLargerPrimeFactor * nextLargerPrimeFactor;
    return candidate == leastRelevantMultiple;
  }

  private static boolean
  isNotMultipleOfAnyPreviousPrimeFactor(int candidate) {
    for (int n = 1; n &lt; multiplesOfPrimeFactors.size(); n++) {
      if (isMultipleOfNthPrimeFactor(candidate, n))
        return false;
      }
    return true;
  }

  private static boolean
  isMultipleOfNthPrimeFactor(int candidate, int n) {
    return
      candidate == smallestOddNthMultipleNotLessThanCandidate(candidate, n);
  }

  private static int
  smallestOddNthMultipleNotLessThanCandidate(int candidate, int n) {
    int multiple = multiplesOfPrimeFactors.get(n);
    while (multiple &lt; candidate)
      multiple += 2 * primes[n];
    multiplesOfPrimeFactors.set(n, multiple);
    return multiple;
  }
}
</code></pre></li>
<li><p>RowColumnPagePrinter</p>
<pre><code>public class RowColumnPagePrinter {
  private int rowsPerPage;
  private int columnsPerPage;
  private int numbersPerPage;
  private String pageHeader;
  private PrintStream printStream;

  public RowColumnPagePrinter(int rowsPerPage,
                              int columnsPerPage,
                              String pageHeader) {
    this.rowsPerPage = rowsPerPage;
    this.columnsPerPage = columnsPerPage;
    this.pageHeader = pageHeader;
    numbersPerPage = rowsPerPage * columnsPerPage;
    printStream = System.out;
  }
  public void print(int data[]) {
    int pageNumber = 1;
    for (int firstIndexOnPage = 0;
         firstIndexOnPage &lt; data.length;
         firstIndexOnPage += numbersPerPage) {
      int lastIndexOnPage =
        Math.min(firstIndexOnPage + numbersPerPage - 1,
                 data.length - 1);
      printPageHeader(pageHeader, pageNumber);
      printPage(firstIndexOnPage, lastIndexOnPage, data);
      printStream.println(&quot;\f&quot;);
      pageNumber++;
    }
  }

  private void printPage(int firstIndexOnPage,
                         int lastIndexOnPage,
                         int[] data) {
    int firstIndexOfLastRowOnPage =
      firstIndexOnPage + rowsPerPage - 1;
    for (int firstIndexInRow = firstIndexOnPage;
         firstIndexInRow &lt;= firstIndexOfLastRowOnPage;
         firstIndexInRow++) {
      printRow(firstIndexInRow, lastIndexOnPage, data);
      printStream.println(&quot;&quot;);
    }
  }

  private void printRow(int firstIndexInRow,
                        int lastIndexOnPage,
                        int[] data) {
    for (int column = 0; column &lt; columnsPerPage; column++) {
      int index = firstIndexInRow + column * rowsPerPage;
      if (index &lt;= lastIndexOnPage)
        printStream.format(&quot;%10d&quot;, data[index]);
    }
  }

  private void printPageHeader(String pageHeader,
                               int pageNumber) {
    printStream.println(pageHeader + &quot; --- Page &quot; + pageNumber);
    printStream.println(&quot;&quot;);
  }

  public void setOutput(PrintStream printStream) {
    this.printStream = printStream;
  }
}
</code></pre></li>
</ul>
<h2 id="10-3-为了修改而组织"><a href="#10-3-为了修改而组织" class="headerlink" title="10.3 为了修改而组织"></a>10.3 为了修改而组织</h2><p>修改将一直持续。每次修改（打开类）都让系统冒着其他部分不能如期望工作的风险。整洁系统必须优化类的组织，降低修改带来的风险</p>
<h3 id="Sql类实例重构"><a href="#Sql类实例重构" class="headerlink" title="Sql类实例重构"></a>Sql类实例重构</h3><pre><code>public class Sql {
  public Sql(String table, Column[] columns);
  public String create();
  public String insert(Object[] fields);
  public String selectAll();
  public String findByKey(String keyColumn, String keyValue);
  public String select(Column column, String pattern);
  public String select(Criteria criteria);
  public String preparedInsert();
  private String columnList(Column[] columns) 
  private String valuesList(Object[] fields, final Column[] columns)
  private String selectWithCriteria(String criteria) 
  private String placeholderList(Column[] columns) 
}
</code></pre><p>原程序存在的问题：</p>
<ul>
<li><p>存在两个修改的理由，说明违反了SRP原则</p>
<p>  每当需要新增支持一种语句（如 update），必须“打开”类进行修改，风险随之而来，可能破坏类中其他代码，必须全面重新测试。</p>
<p>  每当需要更改select查询，也必须“打开”类进行修改。</p>
</li>
<li><p>内聚性不足</p>
<p>  存在类似 <code>selectWithCriteria</code>等 只与 <code>select</code> 有关的是有方法</p>
</li>
</ul>
<p>如果该类无需增加update功能，就该不动Sql类。但是一旦打开了类，就应该马上修正设计方案</p>
<p>重构方案：</p>
<ul>
<li>每个功能拆分为一个权责类。Sql为基类，每个功能都是一个子类。</li>
<li>私有方法放到被使用的类。valuesList方法只在insert中使用了，放到InsertSql中</li>
<li>公共私有方法放到工具类。Where 和 ColumnList</li>
</ul>
<p>代码如下：</p>
<ul>
<li><p>Sql</p>
<pre><code>abstract public class Sql {
   public Sql(String table, Column[] columns) {};
   abstract public String generate();
}
</code></pre></li>
<li><p>CreateSql</p>
<pre><code>class CreateSql extends Sql {
   public CreateSql(String table, Column[] columns) { super(table, columns); }
   @Override public String generate() { return &quot;&quot;; }
}
</code></pre></li>
<li><p>InsertSql</p>
<pre><code>class InsertSql extends Sql {
   public InsertSql(String table, Column[] columns, Object[] fields) { super(table, columns); }
   @Override public String generate() { return &quot;&quot;; }
   private String valuesList(Object[] fields, final Column[] columns) { return &quot;&quot;; }
}
</code></pre></li>
<li><p>Where</p>
<pre><code>class Where {
   public Where(String criteria) {}
   public String generate() { return &quot;&quot;; }
}
</code></pre></li>
<li><p>ColumnList</p>
<pre><code>class ColumnList {
   public ColumnList(Column[] columns) {}
   public String generate() { return &quot;&quot;; }
}
</code></pre></li>
</ul>
<p>当需要增加update是，只需新建UpdateSql类。</p>
<p>重构后的系统，符合单一权责原则SRP，符合 开闭原则OCP</p>
<h3 id="隔离修改"><a href="#隔离修改" class="headerlink" title="隔离修改"></a>隔离修改</h3><p>借助接口和抽象类隔离细节修改带来的影响。</p>
<p>依赖倒置原则DIP：类应当依赖于抽象，而不是依赖于具体细节。</p>
<h1 id="第十一章、-系统"><a href="#第十一章、-系统" class="headerlink" title="第十一章、 系统"></a>第十一章、 系统</h1><h2 id="11-1-如何建造一个城市"><a href="#11-1-如何建造一个城市" class="headerlink" title="11.1 如何建造一个城市"></a>11.1 如何建造一个城市</h2><p>城市能够正常运转是因为城市演化出恰当的抽象等级和模块（供水系统、供电系统、交通、执法、立法等），各组件即便在不了解全局时，都能有效转转</p>
<p>本章讨论的就是如何在较高的抽象层级-系统层级 上保持整洁</p>
<h2 id="11-2-将系统的构造和使用分开"><a href="#11-2-将系统的构造和使用分开" class="headerlink" title="11.2 将系统的构造和使用分开"></a>11.2 将系统的构造和使用分开</h2><p>Separate Constructing a System from Using It</p>
<p>酒店建设时，先搭个框架，起重机升降机附着在外面，工人忙碌其间。建成后，起重机升降机都会消失，酒店变得整洁</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/14/编程思想/VO DTO DO PO 概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/14/编程思想/VO DTO DO PO 概念/" itemprop="url">VO DTO DO PO 概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-14T08:56:53+08:00">
                2019-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程思想/" itemprop="url" rel="index">
                    <span itemprop="name">编程思想</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>浅析VO、DTO、DO、PO的概念、区别和用处 http://blog.csdn.net/zjrbiancheng/article/details/6253232
</code></pre><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><pre><code>VO（View Object）：视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。 展示User 可能是包含昵称头像
DTO（Data Transfer Object）：数据传输对象，服务层返回的数据传输对象。 服务器返回的User不包含密码
DO（Domain Object）：领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。 抽象User可能包含密码和登录方法
PO（Persistent Object）：持久化（通常是关系型数据库）对象。 存储User可能不包含密码
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="风" />
            
              <p class="site-author-name" itemprop="name">风</p>
              <p class="site-description motion-element" itemprop="description">随心而动，随刃而行</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">187</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">59</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">风</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
