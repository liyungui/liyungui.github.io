<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hook," />










<meta name="description" content="Android平台下hook框架adbi的研究（上） adbi源代码 Linux可以利用ptrace()函数来attach到一个进程上，从而可以修改对应该进程的内存内容和寄存器的值 adbi（The Android Dynamic Binary Instrumentation Toolkit）是一个通用的框架，使得hook变得异常简单。 进程注入基本实现原理利用ptrace()attach到一个进">
<meta name="keywords" content="Hook">
<meta property="og:type" content="article">
<meta property="og:title" content="adbi 注入原理">
<meta property="og:url" content="http://yoursite.com/2018/05/18/Android/Android逆向/Android-Hook/android-hook框架/ADBI--Native InLine/adbi注入原理/index.html">
<meta property="og:site_name" content="风">
<meta property="og:description" content="Android平台下hook框架adbi的研究（上） adbi源代码 Linux可以利用ptrace()函数来attach到一个进程上，从而可以修改对应该进程的内存内容和寄存器的值 adbi（The Android Dynamic Binary Instrumentation Toolkit）是一个通用的框架，使得hook变得异常简单。 进程注入基本实现原理利用ptrace()attach到一个进">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-12-28T07:12:41.870Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="adbi 注入原理">
<meta name="twitter:description" content="Android平台下hook框架adbi的研究（上） adbi源代码 Linux可以利用ptrace()函数来attach到一个进程上，从而可以修改对应该进程的内存内容和寄存器的值 adbi（The Android Dynamic Binary Instrumentation Toolkit）是一个通用的框架，使得hook变得异常简单。 进程注入基本实现原理利用ptrace()attach到一个进">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/05/18/Android/Android逆向/Android-Hook/android-hook框架/ADBI--Native InLine/adbi注入原理/"/>





  <title>adbi 注入原理 | 风</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">风</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">技术博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/Android/Android逆向/Android-Hook/android-hook框架/ADBI--Native InLine/adbi注入原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">adbi 注入原理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T16:44:42+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a href="http://blog.csdn.net/roland_sun/article/details/34109569" target="_blank" rel="noopener">Android平台下hook框架adbi的研究（上）</a></p>
<p><a href="https://github.com/crmulliner/adbi" target="_blank" rel="noopener">adbi源代码</a></p>
<p>Linux可以利用ptrace()函数来attach到一个进程上，从而可以修改对应该进程的内存内容和寄存器的值</p>
<p>adbi（The Android Dynamic Binary Instrumentation Toolkit）是一个通用的框架，使得hook变得异常简单。</p>
<h1 id="进程注入基本实现原理"><a href="#进程注入基本实现原理" class="headerlink" title="进程注入基本实现原理"></a>进程注入基本实现原理</h1><p>利用ptrace()attach到一个进程上，然后在进程调用序列中插入一个调用dlopen()加载so文件（初始化函数中hook指定的函数）的步骤。</p>
<p>adbi工具集由两个主要模块组成，分别是用于注入.so文件的进程劫持工具（hijack tool）和一个修改函数入口的基础库。</p>
<p>接下来，我们还是通过阅读代码来分别了解这两个模块的实现原理，本篇我们先将重点放在劫持工具的实现上。</p>
<p><strong>注入进程需要解决两个问题</strong></p>
<ol>
<li>获得目标进程dlopen()函数的调用地址</li>
<li>插入一个调用dlopen()函数的步骤到目标进程的调用序列中。</li>
</ol>
<h2 id="1-获得目标进程dlopen-函数的调用地址"><a href="#1-获得目标进程dlopen-函数的调用地址" class="headerlink" title="1. 获得目标进程dlopen()函数的调用地址"></a>1. 获得目标进程dlopen()函数的调用地址</h2><pre><code>----main()-----------------------------------------------------------------------
//在当前进程中dlopen()加载libdl.so动态库，接着用dlsym()函数获得当前进程dlopen()函数的调用地址
//libdl.so动态库肯定早已加载到当前进程中了，这里再加载一次并不会真的再在内存中的另一个位置加载一次，而是返回已经加载过的地址
void *ldl = dlopen(&quot;libdl.so&quot;, RTLD_LAZY);  
if (ldl) {  
    dlopenaddr = dlsym(ldl, &quot;dlopen&quot;);  
    dlclose(ldl);  
}  

unsigned long int lkaddr; //本进程linker地址。linker是Android提供的动态链接器，不同于普通的Linux。dlopen()函数就是在linker里面定义的（bionic/linker/dlfcn.cpp中: soinfo libdl_info = {&quot;libdl.so&quot;）  
unsigned long int lkaddr2; //目标进程linker地址   
find_linker(getpid(), &amp;lkaddr);  
find_linker(pid, &amp;lkaddr2);  

dlopenaddr = lkaddr2 + (dlopenaddr - lkaddr); //同一台机器上的进程肯定用的是同一个linker，所以其内部的dlopen()函数和linker头的偏移量是固定的

----find_linker()-----------------------------------------------------------------------
static int find_linker(pid_t pid, unsigned long *addr) {  
    struct mm mm[1000];  
    unsigned long libcaddr;  
    int nmm;  
    char libc[256];  
    symtab_t s;  

    if (0 &gt; load_memmap(pid, mm, &amp;nmm)) {  
        printf(&quot;cannot read memory map\n&quot;);  
        return -1;  
    }  
    if (0 &gt; find_linker_mem(libc, sizeof(libc), &amp;libcaddr, mm, nmm)) {  
        printf(&quot;cannot find libc\n&quot;);  
        return -1;  
    }  

    *addr = libcaddr;  

    return 1;  
} 

      ----load_memmap()-----------------------------------------------------------------------
    static int load_memmap(pid_t pid, struct mm *mm, int *nmmp) {  
        char raw[80000]; // this depends on the number of libraries an executable uses  
        char name[MAX_NAME_LEN];  
        char *p;  
        unsigned long start, end;  
        struct mm *m;  
        int nmm = 0;  
        int fd, rv;  
        int i;  

        //打开文件(路径是“/proc/&lt;进程号&gt;/maps”)读出指定进程的内存映射信息，其格式大概如下：
        sprintf(raw, &quot;/proc/%d/maps&quot;, pid);  
        fd = open(raw, O_RDONLY);  
        if (0 &gt; fd) {  
            printf(&quot;Can&apos;t open %s for reading\n&quot;, raw);  
            return -1;  
        }  

        //逐行读取内存映射信息文件的内容
        memset(raw, 0, sizeof(raw));  /* Zero to ensure data is null terminated */                
        p = raw;  
        while (1) {  
            rv = read(fd, p, sizeof(raw)-(p-raw));  
            if (0 &gt; rv) {  
                return -1;  
            }  
            if (0 == rv)  
                break;  
            p += rv;  
            if (p-raw &gt;= sizeof(raw)) {  
                printf(&quot;Too many memory mapping\n&quot;);  
                return -1;  
            }  
        }  
        close(fd);  

        //逐行解析内存映射信息文件的内容。文件格式如下：
        40096000-40098000 r-xp 00000000 b3:16 109        /system/bin/app_process  
        40098000-40099000 r--p 00001000 b3:16 109        /system/bin/app_process  
        40099000-4009a000 rw-p 00000000 00:00 0   
        4009a000-400a9000 r-xp 00000000 b3:16 176        /system/bin/linker  
        400a9000-400aa000 r--p 0000e000 b3:16 176        /system/bin/linker  
        400aa000-400ab000 rw-p 0000f000 b3:16 176        /system/bin/linker  
        400ab000-400ae000 rw-p 00000000 00:00 0   
        400ae000-400b0000 r--p 00000000 00:00 0   
        400b0000-400b9000 r-xp 00000000 b3:16 855        /system/lib/libcutils.so  
        be846000-be867000 rw-p 00000000 00:00 0          [stack] 
        p = strtok(raw, &quot;\n&quot;);  
        m = mm;  
        while (p) {  
            /* parse current map line */  
            rv = sscanf(p, &quot;%08lx-%08lx %*s %*s %*s %*s %s\n&quot;,  
                &amp;start, &amp;end, name);  //解析出当前行的 起始地址，结束地址，和名称。

            p = strtok(NULL, &quot;\n&quot;);  //获取下一行

            if (rv == 2) {  //没有解析出名称(只有两个返回值)，就会用一个自定义的名称补上（“[memory]”）
                m = &amp;mm[nmm++];  
                m-&gt;start = start;  
                m-&gt;end = end;  
                strcpy(m-&gt;name, MEMORY_ONLY);  
                continue;  
            }  

            if (strstr(name, &quot;stack&quot;) != 0) {  //名字是“stack”，表明这段内存用于栈
                stack_start = start;  
                stack_end = end;  
            }  

            //将连续的并且名字相同的内存段合并一下.(从前面的格式中可以看出，会有几行都叫一个名字的情况)
            /* search backward for other mapping with same name */  
            for (i = nmm-1; i &gt;= 0; i--) {  
                m = &amp;mm[i];  
                if (!strcmp(m-&gt;name, name))  
                    break;  
            }  

            if (i &gt;= 0) {  
                if (start &lt; m-&gt;start)  
                    m-&gt;start = start;  
                if (end &gt; m-&gt;end)  
                    m-&gt;end = end;  
            } else {  
                /* new entry */  
                m = &amp;mm[nmm++];  
                m-&gt;start = start;  
                m-&gt;end = end;  
                strcpy(m-&gt;name, name);  
        }  

        *nmmp = nmm;  
        return 0;  
    } 

    ----find_linker_mem()-----------------------------------------------------------------------
    static int find_linker_mem(char *name, int len, unsigned long *start, struct mm *mm, int nmm) {  
        int i;  
        struct mm *m;  
        char *p;  
        for (i = 0, m = mm; i &lt; nmm; i++, m++) {  
            if (!strcmp(m-&gt;name, MEMORY_ONLY))  
                continue;  
            p = strrchr(m-&gt;name, &apos;/&apos;);  
            if (!p)  
                continue;  
            p++;  
            if (strncmp(&quot;linker&quot;, p, 6))  //找出名字以“linker”结尾(/system/bin/linker)的那段内存的起始地址。
                continue;  
        break;  
        }  
        if (i &gt;= nmm)  
        /* not found */  
            return -1;  

        *start = m-&gt;start;  
        strncpy(name, m-&gt;name, len);  
        if (strlen(m-&gt;name) &gt;= len)  
            name[len-1] = &apos;\0&apos;;  
        return 0;  
    }  
</code></pre><h2 id="2-插入一个调用dlopen-函数的步骤到目标进程的调用序列中"><a href="#2-插入一个调用dlopen-函数的步骤到目标进程的调用序列中" class="headerlink" title="2. 插入一个调用dlopen()函数的步骤到目标进程的调用序列中"></a>2. 插入一个调用dlopen()函数的步骤到目标进程的调用序列中</h2><pre><code>// Attach 
if (0 &gt; ptrace(PTRACE_ATTACH, pid, 0, 0)) {//被Attach的进程将成为当前进程的子进程，并且会暂停执行。
    printf(&quot;cannot attach to %d, error!\n&quot;, pid);
    exit(1);
}
waitpid(pid, NULL, 0);//等待被Attach的进程暂停运行才返回
ptrace(PTRACE_GETREGS, pid, 0, &amp;regs); //获得目标进程的所有寄存器的值
//unsigned int sc[]
sc[11] = regs.ARM_r0;  
sc[12] = regs.ARM_r1;  
sc[13] = regs.ARM_r2;  
sc[14] = regs.ARM_r3;  
sc[15] = regs.ARM_lr;  
sc[16] = regs.ARM_pc;  
sc[17] = regs.ARM_sp;  
sc[19] = dlopenaddr;
// push library name to stack  
//case &apos;l&apos;: n = strlen(optarg)+1; n = n/4 + (n%4 ? 1 : 0); 
//命令行-l参数后就是so库完整名称。ptrace()写入目标进程以4字节为单位 
libaddr = regs.ARM_sp - n*4 - sizeof(sc);  
sc[18] = libaddr; 
// write library name to stack  
if (0 &gt; write_mem(pid, (unsigned long*)arg, n, libaddr)) {  
    printf(&quot;cannot write library name (%s) to stack, error!\n&quot;, arg);  
    exit(1);  
}  
// write code to stack  
codeaddr = regs.ARM_sp - sizeof(sc);  
if (0 &gt; write_mem(pid, (unsigned long*)&amp;sc, sizeof(sc)/sizeof(long), codeaddr)) {  
    printf(&quot;cannot write code, error!\n&quot;);  
    exit(1);  
}

    ----write_mem()-----------------------------------------------------------------------
    /* Write NLONG 4 byte words from BUF into PID starting at address POS.  Calling process must be attached to PID. */  
    static int write_mem(pid_t pid, unsigned long *buf, int nlong, unsigned long pos) {  
        unsigned long *p;  
        int i;  

        for (p = buf, i = 0; i &lt; nlong; p++, i++)  
            if (0 &gt; ptrace(PTRACE_POKETEXT, pid, pos+(i*4), *p))  
                return -1;  
        return 0;  
    }

mprotect()给栈内存段设置可执行属性。
    adbi采用了另一种方法找目标进程mprotect()内存地址。
    思路是分析ELF文件libc.so来获得其中符号mprotect的值（其实就是mprotect()函数相对于文件头的偏移），再加上libc.so文件在内存中映射的起始地址，就是mprotect()函数真正的调用地址了
// calc stack pointer  
regs.ARM_sp = regs.ARM_sp - n*4 - sizeof(sc);  

// call mprotect() to make stack executable  
regs.ARM_r0 = stack_start; // want to make stack executable  
regs.ARM_r1 = stack_end - stack_start; // stack size  
regs.ARM_r2 = PROT_READ|PROT_WRITE|PROT_EXEC; // protections  

regs.ARM_lr = codeaddr; // points to loading and fixing code  
regs.ARM_pc = mprotectaddr; // execute mprotect()

ptrace(PTRACE_SETREGS, pid, 0, &amp;regs);  
ptrace(PTRACE_DETACH, pid, 0, SIGCONT); //deAttach,让目标进程恢复运行 
</code></pre>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Hook/" rel="tag"><i class="fa fa-tag"></i> Hook</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/18/联想t420安装黑苹果/" rel="next" title="联想t420安装黑苹果">
                <i class="fa fa-chevron-left"></i> 联想t420安装黑苹果
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/18/Android/Android逆向/Android-Hook/android-hook框架/xposed--Dalvik FrameWork/小米系统miui使用xposed框架/" rel="prev" title="小米系统miui使用xposed框架">
                小米系统miui使用xposed框架 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="风" />
            
              <p class="site-author-name" itemprop="name">风</p>
              <p class="site-description motion-element" itemprop="description">随心而动，随刃而行</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">119</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#进程注入基本实现原理"><span class="nav-number">1.</span> <span class="nav-text">进程注入基本实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-获得目标进程dlopen-函数的调用地址"><span class="nav-number">1.1.</span> <span class="nav-text">1. 获得目标进程dlopen()函数的调用地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-插入一个调用dlopen-函数的步骤到目标进程的调用序列中"><span class="nav-number">1.2.</span> <span class="nav-text">2. 插入一个调用dlopen()函数的步骤到目标进程的调用序列中</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">风</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
