<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="View,Canvas," />










<meta name="description" content="原理使用Canvas 绘制图形有两种方式：  直接画，drawXXX: drawLine,drawCircle 通过path画，drawPath(Path path, Paint paint)  两种实现方式 自定义View 复写onDraw(Canvas canvas) 复写onTouchEvent(MotionEvent event)   使用ImageView 用Canvas绘制一张空的Bi">
<meta name="keywords" content="View,Canvas">
<meta property="og:type" content="article">
<meta property="og:title" content="Android画板实现">
<meta property="og:url" content="http://yoursite.com/2018/11/14/Android画板实现/index.html">
<meta property="og:site_name" content="风">
<meta property="og:description" content="原理使用Canvas 绘制图形有两种方式：  直接画，drawXXX: drawLine,drawCircle 通过path画，drawPath(Path path, Paint paint)  两种实现方式 自定义View 复写onDraw(Canvas canvas) 复写onTouchEvent(MotionEvent event)   使用ImageView 用Canvas绘制一张空的Bi">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2018/11/14/Android画板实现/双缓冲.png">
<meta property="og:updated_time" content="2018-11-16T08:57:42.989Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android画板实现">
<meta name="twitter:description" content="原理使用Canvas 绘制图形有两种方式：  直接画，drawXXX: drawLine,drawCircle 通过path画，drawPath(Path path, Paint paint)  两种实现方式 自定义View 复写onDraw(Canvas canvas) 复写onTouchEvent(MotionEvent event)   使用ImageView 用Canvas绘制一张空的Bi">
<meta name="twitter:image" content="http://yoursite.com/2018/11/14/Android画板实现/双缓冲.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/11/14/Android画板实现/"/>





  <title>Android画板实现 | 风</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">风</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">技术博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/14/Android画板实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android画板实现</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-14T17:54:53+08:00">
                2018-11-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>使用Canvas</p>
<p>绘制图形有两种方式：</p>
<ul>
<li>直接画，drawXXX: drawLine,drawCircle</li>
<li>通过path画，drawPath(Path path, Paint paint)</li>
</ul>
<h1 id="两种实现方式"><a href="#两种实现方式" class="headerlink" title="两种实现方式"></a>两种实现方式</h1><ul>
<li>自定义View<ul>
<li>复写onDraw(Canvas canvas)</li>
<li>复写onTouchEvent(MotionEvent event)</li>
</ul>
</li>
<li>使用ImageView<ul>
<li>用Canvas绘制一张空的Bitmap，通过ImageView的setImageBitmap()方法加载这个Bitmap</li>
<li>setOnTouchListener()</li>
</ul>
</li>
</ul>
<h2 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h2><p>完整实现即用的是自定义View</p>
<h2 id="使用ImageView实现绘制直线"><a href="#使用ImageView实现绘制直线" class="headerlink" title="使用ImageView实现绘制直线"></a>使用ImageView实现绘制直线</h2><p>不断绘制直线(折现)。</p>
<p>可以使用二阶贝塞尔曲线绘制(以起点和终点的中点作为控制点)，效果更加平滑</p>
<pre><code>private void showImage() {
    // 创建一张空白图片
    mBitmap = Bitmap.createBitmap(720, 1280, Bitmap.Config.ARGB_8888);
    // 创建一张画布
    canvas = new Canvas(mBitmap);
    // 画布背景为白色
    canvas.drawColor(Color.WHITE);
    // 创建画笔
    paint = new Paint();
    // 画笔颜色为蓝色
    paint.setColor(Color.BLUE);
    // 宽度5个像素
    paint.setStrokeWidth(5);
    // 先将白色背景画上
    canvas.drawBitmap(mBitmap, new Matrix(), paint);
    img.setImageBitmap(mBitmap);//展示白色背景图

    img.setOnTouchListener(new View.OnTouchListener() {
        int startX;
        int startY;

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            switch (event.getAction()) {
                case MotionEvent.ACTION_DOWN:
                    // 获取手按下时的坐标
                    startX = (int) event.getX();
                    startY = (int) event.getY();
                    break;
                case MotionEvent.ACTION_MOVE:
                    // 获取手移动后的坐标
                    int endX = (int) event.getX();
                    int endY = (int) event.getY();
                    // 在开始和结束坐标间画一条线
                    canvas.drawLine(startX, startY, endX, endY, paint);
                    // 刷新开始坐标
                    startX = (int) event.getX();
                    startY = (int) event.getY();
                    img.setImageBitmap(mBitmap);
                    break;
            }
            return true;
        }
    });
}
</code></pre><h1 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h1><p>功能：</p>
<ul>
<li>支持撤销（undo）；</li>
<li>支持反撤销（redo）；</li>
<li>支持橡皮擦（eraser）；</li>
<li>支持清除功能（clear）；</li>
<li>支持保存为图像（save）。</li>
</ul>
<p><a href="https://github.com/wensefu/android-palette" target="_blank" rel="noopener">GitHub</a></p>
<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>绘制：考虑到性能问题，使用了双缓冲绘图技术。</li>
<li>撤销功能：在画轨迹时，记录每一步的轨迹和画笔属性，每次撤销时把最后一步删除，然后重绘；</li>
<li>反撤销功能：撤销时把撤销的轨迹和画笔属性保存在另一个列表里，反撤销时从这个列表里取出来放到记录绘制信息的列表里，然后重绘；</li>
<li>橡皮擦功能：应用到android的图象混合（Xfermode）知识</li>
<li>清除功能：清除屏上的像素记录即可；</li>
</ul>
<h3 id="android的图象混合（Xfermode）"><a href="#android的图象混合（Xfermode）" class="headerlink" title="android的图象混合（Xfermode）"></a>android的图象混合（Xfermode）</h3><p>图象混合本质上用一句话解释就是：</p>
<pre><code>按照某种算法将画布上你将要绘制的区域的每个像素的ARGB和你将要在这个区域绘制的ARGB进行组合变换。
</code></pre><p>Xfermode有三个子类，两个在API 16上已经过时了，现在最常用的是PorterDuffXfermode，目前支持18种图像混合算法，分别产生不同的混合效果，做橡皮擦功能用到了CLEAR算法(PorterDuff.Mode.CLEAR,将绘制区域的所有像素点ARGB全部置0，显示activity的背景色，没设置默认为黑色背景)，其他算法的效果大家有兴趣可以参考google官方的介绍</p>
<p>需要注意的是，Xfermode的某些算法不支持硬件加速</p>
<h3 id="android双缓冲绘图技术"><a href="#android双缓冲绘图技术" class="headerlink" title="android双缓冲绘图技术"></a>android双缓冲绘图技术</h3><p>所谓缓冲，简单地说就是将<strong>多个将要执行的独立的任务集结起来</strong>，一起提交。</p>
<p>打个比方，现实生活中，你现在要将很多砖从A处搬到B处，原始的方法是徒手一次搬几块，这就是没有使用“缓存”的方法。你也可以用一辆拖车，先把砖搬到拖车上，再把拖车拉到B处，这就是使用了“缓存”的方法。</p>
<p>每个canvas都有对应的一个bitmap，绘图的过程实际上就是往这个bitmap上写入ARGB信息，然后把这些信息交给GPU进行显示。这里面其实已经包含了一次缓冲的过程(<strong>显示缓冲</strong>)。</p>
<p>绘图时的双缓冲其实就是再增加一个canvas，把想要绘制的内容先绘制到这个增加的canvas对应的bitmap上，写完后再把这个bitmap的ARGB信息一次提交给上下文的canvas去绘制。</p>
<p>双缓冲技术在绘制数据量较大时在性能上有明显的提升，画板程序之所以用到了双缓存，也是基于提高绘制效率的考虑。</p>
<h4 id="显示缓冲的验证"><a href="#显示缓冲的验证" class="headerlink" title="显示缓冲的验证"></a>显示缓冲的验证</h4><pre><code>@Override
protected void onDraw(Canvas canvas) {
    canvas.drawRect(rect,mPaint);
    try {
        TimeUnit.MILLISECONDS.sleep(2000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    canvas.drawCircle(cx,cy,100,mPaint);
}
两个几乎同时一起显示出来的。
这就说明必须要等onDraw方法执行完成之后，才会把数据交给GPU去处理展示。
这就是android绘图当中的第一道缓冲，即显示缓冲区。
</code></pre><h4 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h4><ul>
<li>再创建一个Canvas和对应的Bitmap</li>
<li>在onDraw方法里默认的Canvas通过drawBitmap画bitmap从而实现双缓冲。</li>
</ul>
<p>用代码简单的表述是这样的：</p>
<pre><code>private void init(){
    Bitmap bufferBm = Bitmap.create(getWidth,getHeight,Bitmap.Config.ARGB_8888);
    Canvas bufferCanvas = new Canvas(bufferBm);
}

private void drawSomething(){
    bufferCanvas.drawRect();
    bufferCanvas.drawCircle();
    ...
    invalidate();
}

@Override
protected void onDraw(Canvas canvas) {
    canvas.drawBitmap(bufferBm,0,0,null);
}
</code></pre><img src="/2018/11/14/Android画板实现/双缓冲.png">
<h4 id="双缓冲绘图的优缺点及适用场景"><a href="#双缓冲绘图的优缺点及适用场景" class="headerlink" title="双缓冲绘图的优缺点及适用场景"></a>双缓冲绘图的优缺点及适用场景</h4><p>使用双缓冲会增加内存消耗。</p>
<ul>
<li>在绘制数据量较小时，不使用双缓冲，GPU的负荷更低，即绘制性能更高；</li>
<li>在绘制数据量较大时，使用双缓冲绘图，绘制性能明显高于不使用双缓冲的情况；</li>
</ul>
<p><strong>实例验证：自定义View,每次点击在点击处画一个圆</strong></p>
<p>实验之前，先打开开发者选项里的”GPU呈现模式分析“，设置为“在屏幕上显示为条形图”</p>
<p>不用双缓冲的代码：</p>
<pre><code>public class MyView extends View{

    private Paint mPaint;
    private List&lt;Point&gt; mPoints;

    public MyView(Context context) {
        super(context);
    }

    public MyView(Context context, AttributeSet attrs) {
        super(context, attrs);
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
        mPaint.setStyle(Paint.Style.FILL);
        mPaint.setColor(Color.GREEN);
        setBackgroundColor(Color.WHITE);
        mPoints = new ArrayList&lt;&gt;();
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        int action = event.getAction();
        switch (action){
            case MotionEvent.ACTION_DOWN:
                mPoints.add(new Point((int)event.getX(),(int)event.getY()));
                break;
            case MotionEvent.ACTION_UP:
                invalidate();
                break;
        }
        return true;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        for (Point p : mPoints) {
            canvas.drawCircle(p.x,p.y,50,mPaint);
        }
    }
}
</code></pre><p>双缓冲代码如下：</p>
<pre><code>public class MyView extends View{

    private Paint mPaint;
    private Canvas mBufferCanvas;
    private Bitmap mBufferBitmap;

    public MyView(Context context) {
        super(context);
    }

    public MyView(Context context, AttributeSet attrs) {
        super(context, attrs);
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
        mPaint.setStyle(Paint.Style.FILL);
        mPaint.setColor(Color.GREEN);
        setBackgroundColor(Color.WHITE);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        int action = event.getAction();
        switch (action){
            case MotionEvent.ACTION_DOWN:
                if (mBufferBitmap == null) {
                    mBufferBitmap = Bitmap.createBitmap(getWidth(),getHeight(), Bitmap.Config.ARGB_8888);
                    mBufferCanvas = new Canvas(mBufferBitmap);
                }
                mBufferCanvas.drawCircle((int)event.getX(),(int)event.getY(),50,mPaint);
                break;
            case MotionEvent.ACTION_UP:
                invalidate();
                break;
        }
        return true;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        if (mBufferBitmap == null) {
            return;
        }
        canvas.drawBitmap(mBufferBitmap,0,0,null);
    }
}
</code></pre><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><p>非常简短，只有200来行</p>
<pre><code>package com.shensz.course.module.main.screen.liveroom.component;

import android.content.Context;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Path;
import android.graphics.PorterDuff;
import android.graphics.PorterDuffXfermode;
import android.graphics.Xfermode;
import android.support.annotation.Nullable;
import android.util.AttributeSet;
import android.util.DisplayMetrics;
import android.util.TypedValue;
import android.view.MotionEvent;
import android.view.View;

import java.util.ArrayList;
import java.util.List;

public class PaletteView extends View {

    private Paint mPaint;
    private Path mPath;
    private float mLastX;
    private float mLastY;
    private Bitmap mBufferBitmap;
    private Canvas mBufferCanvas;

    private static final int MAX_CACHE_STEP = 20;

    private List&lt;DrawingInfo&gt; mDrawingList;
    private List&lt;DrawingInfo&gt; mRemovedList;

    private Xfermode mXferModeClear;
    private Xfermode mXferModeDraw;
    private int mDrawSize;
    private int mEraserSize;
    private int mPenAlpha = 255;

    private boolean mCanEraser;

    private Callback mCallback;

    public enum Mode {
        DRAW,
        ERASER
    }

    private Mode mMode = Mode.DRAW;


    public PaletteView(Context context) {
        super(context);
        init();
    }

    public PaletteView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    public PaletteView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init();
    }

    public interface Callback {
        void onUndoRedoStatusChanged();
    }

    public void setCallback(Callback callback) {
        mCallback = callback;
    }

    public static class DimenUtils {

        private static final Resources sResource = Resources.getSystem();

        public static float dp2px(float dp) {
            DisplayMetrics dm = sResource.getDisplayMetrics();
            return TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dp, dm);
        }

        public static int dp2pxInt(float dp) {
            return (int) dp2px(dp);
        }

        public static float sp2px(float sp) {
            DisplayMetrics dm = sResource.getDisplayMetrics();
            return TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, sp, dm);
        }

        public static int sp2pxInt(float sp) {
            return (int) sp2px(sp);
        }


    }

    private void init() {
        setDrawingCacheEnabled(true);
        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
        mPaint.setStyle(Paint.Style.STROKE);
        mPaint.setFilterBitmap(true);
        mPaint.setStrokeJoin(Paint.Join.ROUND);
        mPaint.setStrokeCap(Paint.Cap.ROUND);
        mDrawSize = DimenUtils.dp2pxInt(3);
        mEraserSize = DimenUtils.dp2pxInt(30);
        mPaint.setStrokeWidth(mDrawSize);
        mPaint.setColor(0XFF000000);
        mXferModeDraw = new PorterDuffXfermode(PorterDuff.Mode.SRC);
        mXferModeClear = new PorterDuffXfermode(PorterDuff.Mode.CLEAR);
        mPaint.setXfermode(mXferModeDraw);
    }

    private void initBuffer() {
        mBufferBitmap = Bitmap.createBitmap(getWidth(), getHeight(), Bitmap.Config.ARGB_8888);
        mBufferCanvas = new Canvas(mBufferBitmap);
    }

    private abstract static class DrawingInfo {
        Paint paint;

        abstract void draw(Canvas canvas);
    }

    private static class PathDrawingInfo extends DrawingInfo {

        Path path;

        @Override
        void draw(Canvas canvas) {
            canvas.drawPath(path, paint);
        }
    }

    public Mode getMode() {
        return mMode;
    }

    public void setMode(Mode mode) {
        if (mode != mMode) {
            mMode = mode;
            if (mMode == Mode.DRAW) {
                mPaint.setXfermode(mXferModeDraw);
                mPaint.setStrokeWidth(mDrawSize);
            } else {
                mPaint.setXfermode(mXferModeClear);
                mPaint.setStrokeWidth(mEraserSize);
            }
        }
    }

    public void setEraserSize(int size) {
        mEraserSize = size;
    }

    public void setPenRawSize(int size) {
        mDrawSize = size;
        if (mMode == Mode.DRAW) {
            mPaint.setStrokeWidth(mDrawSize);
        }
    }

    public void setPenColor(int color) {
        mPaint.setColor(color);
    }

    private void reDraw() {
        if (mDrawingList != null) {
            mBufferBitmap.eraseColor(Color.TRANSPARENT);
            for (DrawingInfo drawingInfo : mDrawingList) {
                drawingInfo.draw(mBufferCanvas);
            }
            invalidate();
        }
    }

    public int getPenColor() {
        return mPaint.getColor();
    }

    public int getPenSize() {
        return mDrawSize;
    }

    public int getEraserSize() {
        return mEraserSize;
    }

    public void setPenAlpha(int alpha) {
        mPenAlpha = alpha;
        if (mMode == Mode.DRAW) {
            mPaint.setAlpha(alpha);
        }
    }

    public int getPenAlpha() {
        return mPenAlpha;
    }

    public boolean canRedo() {
        return mRemovedList != null &amp;&amp; mRemovedList.size() &gt; 0;
    }

    public boolean canUndo() {
        return mDrawingList != null &amp;&amp; mDrawingList.size() &gt; 0;
    }

    public void redo() {
        int size = mRemovedList == null ? 0 : mRemovedList.size();
        if (size &gt; 0) {
            DrawingInfo info = mRemovedList.remove(size - 1);
            mDrawingList.add(info);
            mCanEraser = true;
            reDraw();
            if (mCallback != null) {
                mCallback.onUndoRedoStatusChanged();
            }
        }
    }

    public void undo() {
        int size = mDrawingList == null ? 0 : mDrawingList.size();
        if (size &gt; 0) {
            DrawingInfo info = mDrawingList.remove(size - 1);
            if (mRemovedList == null) {
                mRemovedList = new ArrayList&lt;&gt;(MAX_CACHE_STEP);
            }
            if (size == 1) {
                mCanEraser = false;
            }
            mRemovedList.add(info);
            reDraw();
            if (mCallback != null) {
                mCallback.onUndoRedoStatusChanged();
            }
        }
    }

    public void clear() {
        if (mBufferBitmap != null) {
            if (mDrawingList != null) {
                mDrawingList.clear();
            }
            if (mRemovedList != null) {
                mRemovedList.clear();
            }
            mCanEraser = false;
            mBufferBitmap.eraseColor(Color.TRANSPARENT);
            invalidate();
            if (mCallback != null) {
                mCallback.onUndoRedoStatusChanged();
            }
        }
    }

    public Bitmap buildBitmap() {
        Bitmap bm = getDrawingCache();
        Bitmap result = Bitmap.createBitmap(bm);
        destroyDrawingCache();
        return result;
    }

    private void saveDrawingPath() {
        if (mDrawingList == null) {
            mDrawingList = new ArrayList&lt;&gt;(MAX_CACHE_STEP);
        } else if (mDrawingList.size() == MAX_CACHE_STEP) {
            mDrawingList.remove(0);
        }
        Path cachePath = new Path(mPath);
        Paint cachePaint = new Paint(mPaint);
        PathDrawingInfo info = new PathDrawingInfo();
        info.path = cachePath;
        info.paint = cachePaint;
        mDrawingList.add(info);
        mCanEraser = true;
        if (mCallback != null) {
            mCallback.onUndoRedoStatusChanged();
        }
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        if (mBufferBitmap != null) {
            canvas.drawBitmap(mBufferBitmap, 0, 0, null);
        }
    }

    @SuppressWarnings(&quot;all&quot;)
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if(!isEnabled()){
            return false;
        }
        final int action = event.getAction() &amp; MotionEvent.ACTION_MASK;
        final float x = event.getX();
        final float y = event.getY();
        switch (action) {
            case MotionEvent.ACTION_DOWN:
                mLastX = x;
                mLastY = y;
                if (mPath == null) {
                    mPath = new Path();
                }
                mPath.moveTo(x,y);
                break;
            case MotionEvent.ACTION_MOVE:
                //这里终点设为两点的中心点的目的在于使绘制的曲线更平滑，如果终点直接设置为x,y，效果和lineto是一样的,实际是折线效果
                mPath.quadTo(mLastX, mLastY, (x + mLastX) / 2, (y + mLastY) / 2);
                if (mBufferBitmap == null) {
                    initBuffer();
                }
                if (mMode == Mode.ERASER &amp;&amp; !mCanEraser) {
                    break;
                }
                mBufferCanvas.drawPath(mPath,mPaint);
                invalidate();
                mLastX = x;
                mLastY = y;
                break;
            case MotionEvent.ACTION_UP:
                if (mMode == Mode.DRAW || mCanEraser) {
                    saveDrawingPath();
                }
                mPath.reset();
                break;
        }
        return true;
    }
}
</code></pre>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/View/" rel="tag"><i class="fa fa-tag"></i> View</a>
          
            <a href="/tags/Canvas/" rel="tag"><i class="fa fa-tag"></i> Canvas</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/06/Android/AndroidStudio在Mac端使用/" rel="next" title="AndroidStudio在Mac端使用">
                <i class="fa fa-chevron-left"></i> AndroidStudio在Mac端使用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/11/14/Android中View的绘制/" rel="prev" title="Android中View的绘制.md">
                Android中View的绘制.md <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="风" />
            
              <p class="site-author-name" itemprop="name">风</p>
              <p class="site-description motion-element" itemprop="description">随心而动，随刃而行</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">75</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#原理"><span class="nav-number">1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#两种实现方式"><span class="nav-number">2.</span> <span class="nav-text">两种实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义View"><span class="nav-number">2.1.</span> <span class="nav-text">自定义View</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用ImageView实现绘制直线"><span class="nav-number">2.2.</span> <span class="nav-text">使用ImageView实现绘制直线</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#完整实现"><span class="nav-number">3.</span> <span class="nav-text">完整实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#原理分析"><span class="nav-number">3.1.</span> <span class="nav-text">原理分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路"><span class="nav-number">3.1.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#android的图象混合（Xfermode）"><span class="nav-number">3.1.2.</span> <span class="nav-text">android的图象混合（Xfermode）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#android双缓冲绘图技术"><span class="nav-number">3.1.3.</span> <span class="nav-text">android双缓冲绘图技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#显示缓冲的验证"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">显示缓冲的验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双缓冲"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">双缓冲</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双缓冲绘图的优缺点及适用场景"><span class="nav-number">3.1.3.3.</span> <span class="nav-text">双缓冲绘图的优缺点及适用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关键代码"><span class="nav-number">3.2.</span> <span class="nav-text">关键代码</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">风</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
