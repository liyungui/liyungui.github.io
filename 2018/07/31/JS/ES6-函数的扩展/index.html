<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JS,ES6," />










<meta name="description" content="函数参数的默认值ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 function log(x, y = &amp;apos;World&amp;apos;) {   console.log(x, y); }  log(&amp;apos;Hello&amp;apos;) // Hello World log(&amp;apos;Hello&amp;apos;, &amp;apos;China&amp;apos;) // Hello China">
<meta name="keywords" content="JS,ES6">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6-函数的扩展">
<meta property="og:url" content="http://yoursite.com/2018/07/31/JS/ES6-函数的扩展/index.html">
<meta property="og:site_name" content="风">
<meta property="og:description" content="函数参数的默认值ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 function log(x, y = &amp;apos;World&amp;apos;) {   console.log(x, y); }  log(&amp;apos;Hello&amp;apos;) // Hello World log(&amp;apos;Hello&amp;apos;, &amp;apos;China&amp;apos;) // Hello China">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-03-12T04:25:31.586Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6-函数的扩展">
<meta name="twitter:description" content="函数参数的默认值ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 function log(x, y = &amp;apos;World&amp;apos;) {   console.log(x, y); }  log(&amp;apos;Hello&amp;apos;) // Hello World log(&amp;apos;Hello&amp;apos;, &amp;apos;China&amp;apos;) // Hello China">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/07/31/JS/ES6-函数的扩展/"/>





  <title>ES6-函数的扩展 | 风</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">风</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">技术博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/31/JS/ES6-函数的扩展/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ES6-函数的扩展</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-31T10:39:20+08:00">
                2018-07-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h1><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<pre><code>function log(x, y = &apos;World&apos;) {
  console.log(x, y);
}

log(&apos;Hello&apos;) // Hello World
log(&apos;Hello&apos;, &apos;China&apos;) // Hello China
log(&apos;Hello&apos;, &apos;&apos;) // Hello
</code></pre><p>使用参数默认值时，函数不能有同名参数</p>
<pre><code>// 不报错
function foo(x, x, y) {
  // ...
}

// 报错
function foo(x, x, y = 1) {
  // ...
}
// SyntaxError: Duplicate parameter name not allowed in this context
</code></pre><p>参数默认值是惰性求值的</p>
<pre><code>let x = 99;
function foo(p = x + 1) {
  console.log(p);
}

foo() // 100

x = 100;
foo() // 101
</code></pre><h2 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h2><ul>
<li>函数的尾参数有默认值，可以省略</li>
<li>其他位置，不能省略。显式输入undefined</li>
</ul>
<p>示例</p>
<p>// 例一<br>function f(x = 1, y) {<br>  return [x, y];<br>}</p>
<pre><code>f() // [1, undefined]
f(2) // [2, undefined])
f(, 1) // 报错
f(undefined, 1) // [1, 1]
</code></pre><h2 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h2><p>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>一旦设置了参数的<strong>默认值</strong>，函数进行声明<strong>初始化</strong>时，参数会形成一个<strong>单独的作用域</strong>（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<pre><code>var x = 1;
function f(x, y = x) {
  console.log(y);
}
f(2) // 2
调用函数f时，参数形成一个单独的作用域。
在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。

let x = 1;
function f(y = x) {
  let x = 2;
  console.log(y);
}
f() // 1

function f(y = x) {
  let x = 2;
  console.log(y);
}
f() // ReferenceError: x is not defined
</code></pre><p>如果参数的默认值是一个函数，该函数的作用域也遵守这个规则</p>
<pre><code>let foo = &apos;outer&apos;;

function bar(func = () =&gt; foo) {
  let foo = &apos;inner&apos;;
  console.log(func());
}

bar(); // outer
</code></pre><h2 id="指定参数是否可以省略"><a href="#指定参数是否可以省略" class="headerlink" title="指定参数是否可以省略"></a>指定参数是否可以省略</h2><p>不得省略，如果省略就抛出一个错误</p>
<pre><code>function throwIfMissing() {
  throw new Error(&apos;Missing parameter&apos;);
}

function foo(mustBeProvided = throwIfMissing()) {
  return mustBeProvided;
}

foo()
// Error: Missing parameter

参数mustBeProvided的默认值等于throwIfMissing函数的运行结果（注意函数名throwIfMissing之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。
</code></pre><p>将参数默认值设为undefined，表明这个参数是可以省略的。</p>
<pre><code>function foo(optional = undefined) { ··· }
</code></pre><h1 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h1><ul>
<li>形式为 <code>...变量名</code><ul>
<li>用于获取函数的多余参数，这样就不需要使用arguments对象了。</li>
<li>是一个数组<ul>
<li>arguments对象不是数组，而是一个类似数组的对象。</li>
<li>所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。</li>
</ul>
</li>
</ul>
</li>
<li>只能是最后一个参数</li>
<li>函数的length属性，不包括 rest 参数</li>
</ul>
<p>实例</p>
<pre><code>function add(...values) {
  let sum = 0;
  for (var val of values) {
    sum += val;
  }
  return sum;
}

add(2, 5, 3) // 10
</code></pre><p>实例：rest 参数代替arguments变量</p>
<pre><code>// arguments变量的写法
function sortNumbers() {
  return Array.prototype.slice.call(arguments).sort();
}

// rest参数的写法
const sortNumbers = (...numbers) =&gt; numbers.sort();
</code></pre><h1 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h1><p>从 ES5 开始，函数内部可以设定为严格模式。</p>
<p>ES2016 规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p>
<ul>
<li>函数内部的严格模式，同时适用于函数体和函数参数。</li>
<li>函数先执行函数参数，再执行函数体。</li>
<li>这就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行</li>
</ul>
<p>两种方法可以规避这种限制</p>
<ul>
<li>设定全局性的严格模式</li>
<li>把函数包在一个无参数的立即执行函数里面</li>
</ul>
<p>代码</p>
<pre><code>&apos;use strict&apos;;
function doSomething(a, b = a) {
  // code
}

const doSomething = (function () {
  &apos;use strict&apos;;
  return function(value = 42) {
    return value;
  };
}());
</code></pre><h1 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h1><p>函数的name属性，返回该函数的函数名</p>
<p>将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。</p>
<pre><code>var f = function () {};

// ES5
f.name // &quot;&quot;

// ES6
f.name // &quot;f&quot;
</code></pre><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>ES6 允许使用“箭头”（=&gt;）定义函数</p>
<pre><code>(参数)=&gt;{代码行;
        return 返回值;}
</code></pre><ul>
<li>省略 function 关键字</li>
<li>如果参数个数=1，省略小括号</li>
<li>如果函数体代码行=1，省略大括号和return</li>
<li>参数支持变量解构</li>
<li>如果箭头函数<strong>返回对象</strong>，必须在<strong>对象外面加上括号</strong>，否则会报错<ul>
<li>因为 大括号被解释为代码块</li>
</ul>
</li>
</ul>
<p>实例</p>
<pre><code>var sum = (num1, num2) =&gt; { return num1 + num2; }

var f = v =&gt; v;
// 等同于
var f = function (v) {
  return v;
};

var f = () =&gt; 5;
// 等同于
var f = function () { return 5 };

var sum = (num1, num2) =&gt; num1 + num2;
// 等同于
var sum = function(num1, num2) {
  return num1 + num2;
};

const full = ({ first, last }) =&gt; first + &apos; &apos; + last;
// 等同于
function full(person) {
  return person.first + &apos; &apos; + person.last;
}

//返回对象，在对象外面加上括号
let getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; });

let foo = () =&gt; { a: 1 };
foo() // undefined
始意图是返回一个对象{ a: 1 }，但是由于引擎认为大括号是代码块，所以执行了一行语句a: 1。这时，a被解释为语句的标签，因此实际执行的语句是1;，然后函数就结束了，没有返回值
</code></pre><p>实例：rest 参数与箭头函数结合</p>
<pre><code>const numbers = (...nums) =&gt; nums;
numbers(1, 2, 3, 4, 5)
// [1,2,3,4,5]

const headAndTail = (head, ...tail) =&gt; [head, tail];
headAndTail(1, 2, 3, 4, 5)
// [1,[2,3,4,5]]
</code></pre><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul>
<li>函数体内的<strong>this对象指向不可变</strong><ul>
<li>就是<strong>定义时所在的对象</strong>，而不是使用时所在的对象。<ul>
<li>箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数</li>
<li>箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）</li>
</ul>
</li>
<li>有<strong>利于封装回调函数</strong></li>
</ul>
</li>
<li>不可以当作构造函数<ul>
<li>不可以使用new命令，否则会抛出一个错误。</li>
</ul>
</li>
<li>不可以使用arguments对象<ul>
<li>该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>
</ul>
</li>
<li>不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</li>
</ul>
<p>箭头函数转成 ES5 的代码如下，转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this</p>
<pre><code>// ES6
function foo() {
  setTimeout(() =&gt; {
    console.log(&apos;id:&apos;, this.id);
  }, 100);
}

// ES5
function foo() {
  var _this = this;
  setTimeout(function () {
    console.log(&apos;id:&apos;, _this.id);
  }, 100);
}
</code></pre><h2 id="箭头函数嵌套"><a href="#箭头函数嵌套" class="headerlink" title="箭头函数嵌套"></a>箭头函数嵌套</h2><h1 id="函数绑定”（function-bind）运算符"><a href="#函数绑定”（function-bind）运算符" class="headerlink" title="函数绑定”（function bind）运算符"></a>函数绑定”（function bind）运算符</h1><p>将对象绑定到函数上面</p>
<ul>
<li>两个冒号（::） <code>对象::函数</code><ul>
<li>对象为空，将方法绑定在该对象上</li>
<li>运算结果为对象，可以采用链式写法</li>
</ul>
</li>
<li>用来取代call、apply、bind调用</li>
</ul>
<p>实例：</p>
<pre><code>foo::bar;
// 等同于
bar.bind(foo);

let log = ::console.log;
// 等同于
var log = console.log.bind(console);

import { map, takeWhile, forEach } from &quot;iterlib&quot;;
getPlayers()
::map(x =&gt; x.character())
::takeWhile(x =&gt; x.strength &gt; 100)
::forEach(x =&gt; console.log(x));
</code></pre><h1 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h1><h2 id="尾调用-Tail-Call"><a href="#尾调用-Tail-Call" class="headerlink" title="尾调用(Tail Call)"></a>尾调用(Tail Call)</h2><ul>
<li>函数式编程的一个重要概念，</li>
<li>某个函数的最后一步是调用另一个函数</li>
</ul>
<p>实例：</p>
<pre><code>//尾调用
function f(x){
  return g(x);
}

//函数m和n都属于尾调用
function f(x) {
  if (x &gt; 0) {
    return m(x)
  }
  return n(x);
}


//非尾调用。调用函数g之后，还有赋值操作
function f(x){
  let y = g(x);
  return y;
}

//非尾调用。调用函数g之后，还有加法操作
function f(x){
  return g(x) + 1;
}

//非尾调用。调用函数g之后，还有return undefined;
function f(x){
  g(x);
}
</code></pre><h2 id="调用帧和调用栈"><a href="#调用帧和调用栈" class="headerlink" title="调用帧和调用栈"></a>调用帧和调用栈</h2><p>函数调用会在内存形成一个“调用记录”，又称“<strong>调用帧</strong>”（call frame），保存调用位置和内部变量等信息。</p>
<p>所有的调用帧，就形成一个“<strong>调用栈</strong>”（call stack）</p>
<h2 id="尾调用优化-Tail-call-optimization"><a href="#尾调用优化-Tail-call-optimization" class="headerlink" title="尾调用优化(Tail call optimization)"></a>尾调用优化(Tail call optimization)</h2><p><strong>直接用内层函数的调用帧，取代外层函数的调用帧。这将大大节省内存</strong></p>
<ul>
<li>只在严格模式下有效<ul>
<li>正常模式下，函数内部有两个变量，可以跟踪函数的调用栈<ul>
<li>func.arguments：返回调用时函数的参数。</li>
<li>func.caller：返回调用当前函数的那个函数。</li>
</ul>
</li>
<li>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。</li>
<li>严格模式禁用这两个变量</li>
</ul>
</li>
</ul>
<p>因为尾调用是函数的最后一步操作，<strong>一般</strong>调用位置、内部变量等信息都不会再用到了，不需要保留外层函数的调用帧。</p>
<pre><code>function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();

// 等同于
function f() {
  return g(3);
}
f();

// 等同于
g(3);

不需要保存内部变量m和n的值、g的调用位置等信息，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧
</code></pre><p>实例：无法进行“尾调用优化”</p>
<p>内层函数inner用到了外层函数addOne的内部变量one</p>
<pre><code>function addOne(a){
  var one = 1;
  function inner(b){
    return b + one;
  }
  return inner(a);
}
</code></pre><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>函数调用自身，称为递归。如果<strong>尾调用自身</strong>，就称为尾递归。</p>
<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误</p>
<h3 id="递归函数的改写"><a href="#递归函数的改写" class="headerlink" title="递归函数的改写"></a>递归函数的改写</h3><p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。</p>
<p>做到这一点的方法，就是把<strong>所有用到的内部变量改写成函数的参数</strong>。</p>
<p><strong>缺点：不太直观</strong></p>
<p>实例：n的阶乘</p>
<p>阶乘函数 factorial 需要用到一个中间变量total，那就把这个中间变量改写成函数的参数。</p>
<p>这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？</p>
<pre><code>//最多需要保存n个调用记录，复杂度 O(n) 
function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}
factorial(5) // 120

//改写成尾递归，只保留一个调用记录，复杂度 O(1) 
function factorial(n, total) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}
factorial(5, 1) // 120
</code></pre><p>实例：Fibonacci 数列</p>
<pre><code>function Fibonacci (n) {
  if ( n &lt;= 1 ) {return 1};
  return Fibonacci(n - 1) + Fibonacci(n - 2);
}
Fibonacci(10) // 89
Fibonacci(100) // 堆栈溢出
Fibonacci(500) // 堆栈溢出

//尾递归优化
function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n &lt;= 1 ) {return ac2};

  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}
Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity
</code></pre><h3 id="尾递归的优雅实现"><a href="#尾递归的优雅实现" class="headerlink" title="尾递归的优雅实现"></a>尾递归的优雅实现</h3><h4 id="柯里化-currying"><a href="#柯里化-currying" class="headerlink" title="柯里化(currying)"></a>柯里化(currying)</h4><p>尾递归函数之外，再提供一个正常形式的函数</p>
<pre><code>function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}

function factorial(n) {
  return tailFactorial(n, 1);
}

factorial(5) // 120
</code></pre><p>柯里化</p>
<ul>
<li>函数式编程的一个概念</li>
<li>意将多参数的函数转换成单参数的形式。</li>
</ul>
<p>代码</p>
<pre><code>function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}

function currying(fn, n) {//fn柯里化的函数，n是柯里化的参数
  return function (m) {
    return fn.call(this, m, n);
  };
}

const factorial = currying(tailFactorial, 1);

factorial(5) // 120
</code></pre><h4 id="采用ES6的函数默认值"><a href="#采用ES6的函数默认值" class="headerlink" title="采用ES6的函数默认值"></a>采用ES6的函数默认值</h4><pre><code>function factorial(n, total = 1) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}
factorial(5) // 120
</code></pre><h3 id="自己实现尾递归优化"><a href="#自己实现尾递归优化" class="headerlink" title="自己实现尾递归优化"></a>自己实现尾递归优化</h3><h4 id="递归本质上是一种循环操作"><a href="#递归本质上是一种循环操作" class="headerlink" title="递归本质上是一种循环操作"></a>递归本质上是一种循环操作</h4><p><strong>纯粹的函数式编程语言没有循环操作命令</strong>，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。</p>
<p>对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</p>
<h4 id="实现尾递归优化"><a href="#实现尾递归优化" class="headerlink" title="实现尾递归优化"></a>实现尾递归优化</h4><p>尾递归优化只在严格模式下生效，那么正常模式下，可以自己实现尾递归优化</p>
<p>原理：尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p>
<h1 id="函数参数的尾逗号"><a href="#函数参数的尾逗号" class="headerlink" title="函数参数的尾逗号"></a>函数参数的尾逗号</h1><p>ES2017 允许<strong>函数定义和调用最后一个参数有尾逗号</strong>(trailing comma)。因此，函数参数与数组和对象的尾逗号规则，保持一致了。</p>
<pre><code>function clownsEverywhere(
  param1,
  param2,
) { /* ... */ }

clownsEverywhere(
  &apos;foo&apos;,
  &apos;bar&apos;,
);
</code></pre>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JS/" rel="tag"><i class="fa fa-tag"></i> JS</a>
          
            <a href="/tags/ES6/" rel="tag"><i class="fa fa-tag"></i> ES6</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/30/JS/ES6-变量的解构赋值/" rel="next" title="ES6-变量的解构赋值">
                <i class="fa fa-chevron-left"></i> ES6-变量的解构赋值
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/31/JS/ES6-Promise对象/" rel="prev" title="ES6-Promise对象">
                ES6-Promise对象 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="风" />
            
              <p class="site-author-name" itemprop="name">风</p>
              <p class="site-description motion-element" itemprop="description">随心而动，随刃而行</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">308</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">71</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#函数参数的默认值"><span class="nav-number">1.</span> <span class="nav-text">函数参数的默认值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#参数默认值的位置"><span class="nav-number">1.1.</span> <span class="nav-text">参数默认值的位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的-length-属性"><span class="nav-number">1.2.</span> <span class="nav-text">函数的 length 属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作用域"><span class="nav-number">1.3.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指定参数是否可以省略"><span class="nav-number">1.4.</span> <span class="nav-text">指定参数是否可以省略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#rest-参数"><span class="nav-number">2.</span> <span class="nav-text">rest 参数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#严格模式"><span class="nav-number">3.</span> <span class="nav-text">严格模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#name-属性"><span class="nav-number">4.</span> <span class="nav-text">name 属性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#箭头函数"><span class="nav-number">5.</span> <span class="nav-text">箭头函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本使用"><span class="nav-number">5.1.</span> <span class="nav-text">基本使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注意点"><span class="nav-number">5.2.</span> <span class="nav-text">注意点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#箭头函数嵌套"><span class="nav-number">5.3.</span> <span class="nav-text">箭头函数嵌套</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数绑定”（function-bind）运算符"><span class="nav-number">6.</span> <span class="nav-text">函数绑定”（function bind）运算符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#尾调用优化"><span class="nav-number">7.</span> <span class="nav-text">尾调用优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#尾调用-Tail-Call"><span class="nav-number">7.1.</span> <span class="nav-text">尾调用(Tail Call)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调用帧和调用栈"><span class="nav-number">7.2.</span> <span class="nav-text">调用帧和调用栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#尾调用优化-Tail-call-optimization"><span class="nav-number">7.3.</span> <span class="nav-text">尾调用优化(Tail call optimization)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#尾递归"><span class="nav-number">7.4.</span> <span class="nav-text">尾递归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#递归函数的改写"><span class="nav-number">7.4.1.</span> <span class="nav-text">递归函数的改写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#尾递归的优雅实现"><span class="nav-number">7.4.2.</span> <span class="nav-text">尾递归的优雅实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#柯里化-currying"><span class="nav-number">7.4.2.1.</span> <span class="nav-text">柯里化(currying)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#采用ES6的函数默认值"><span class="nav-number">7.4.2.2.</span> <span class="nav-text">采用ES6的函数默认值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自己实现尾递归优化"><span class="nav-number">7.4.3.</span> <span class="nav-text">自己实现尾递归优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#递归本质上是一种循环操作"><span class="nav-number">7.4.3.1.</span> <span class="nav-text">递归本质上是一种循环操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现尾递归优化"><span class="nav-number">7.4.3.2.</span> <span class="nav-text">实现尾递归优化</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数参数的尾逗号"><span class="nav-number">8.</span> <span class="nav-text">函数参数的尾逗号</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">风</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
