<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JS,ES6," />










<meta name="description" content="属性简洁表示法直接写入变量和函数，作为对象的属性和方法。  键值对同名。即属性的键名和值名相同 属性简写：省略 属性名和冒号 方法简写：省略 冒号和function 方法的值是一个 Generator 函数，前面需要加上星号     简洁写法的属性名总是字符串 属性名是字符串，直接取变量名;属性值是变量值  实例 function people(name, age) {     return {">
<meta name="keywords" content="JS,ES6">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6-对象的扩展">
<meta property="og:url" content="http://yoursite.com/2018/08/01/JS/ES6-对象的扩展/index.html">
<meta property="og:site_name" content="风">
<meta property="og:description" content="属性简洁表示法直接写入变量和函数，作为对象的属性和方法。  键值对同名。即属性的键名和值名相同 属性简写：省略 属性名和冒号 方法简写：省略 冒号和function 方法的值是一个 Generator 函数，前面需要加上星号     简洁写法的属性名总是字符串 属性名是字符串，直接取变量名;属性值是变量值  实例 function people(name, age) {     return {">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-12-28T06:50:02.016Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6-对象的扩展">
<meta name="twitter:description" content="属性简洁表示法直接写入变量和函数，作为对象的属性和方法。  键值对同名。即属性的键名和值名相同 属性简写：省略 属性名和冒号 方法简写：省略 冒号和function 方法的值是一个 Generator 函数，前面需要加上星号     简洁写法的属性名总是字符串 属性名是字符串，直接取变量名;属性值是变量值  实例 function people(name, age) {     return {">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/08/01/JS/ES6-对象的扩展/"/>





  <title>ES6-对象的扩展 | 风</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">风</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">技术博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/01/JS/ES6-对象的扩展/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ES6-对象的扩展</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-01T10:11:20+08:00">
                2018-08-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="属性简洁表示法"><a href="#属性简洁表示法" class="headerlink" title="属性简洁表示法"></a>属性简洁表示法</h1><p><strong>直接写入变量和函数，作为对象的属性和方法。</strong></p>
<ul>
<li>键值对同名。即属性的键名和值名相同<ul>
<li>属性简写：省略 属性名和冒号</li>
<li>方法简写：省略 冒号和function<ul>
<li>方法的值是一个 Generator 函数，前面需要加上星号</li>
</ul>
</li>
</ul>
</li>
<li>简洁写法的属性名总是字符串</li>
<li>属性名是字符串，直接取变量名;属性值是变量值</li>
</ul>
<p>实例</p>
<pre><code>function people(name, age) {
    return {
        name: name,
        age: age
        getName: function() {
            console.log(this.name)
        }
    };
}

function people(name, age) {
    return {
        name,
        age
        getName () {
            console.log(this.name)
        }
    };
}

const obj = {
  * m() {
    yield &apos;hello world&apos;;
  }
};

const foo = &apos;bar&apos;;
const baz = {foo};
baz // {foo: &quot;bar&quot;}//属性名是字符串，直接取变量名;属性值是变量值
// 等同于
const baz = {foo: foo};

const obj = {
  class () {}
};
// 等同于
var obj = {
  &apos;class&apos;: function() {}
};
</code></pre><h1 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h1><p>ES6 允许<strong>字面量定义对象(使用大括号)</strong>时，<strong>用表达式作为对象的属性名</strong> 即把表达式放在方括号内</p>
<pre><code>let lastWord = &apos;last word&apos;;
const a = {
  &apos;first word&apos;: &apos;hello&apos;,
  [lastWord]: &apos;world&apos;
};
a[&apos;first word&apos;] // &quot;hello&quot;
a[lastWord] // &quot;world&quot;
a[&apos;last word&apos;] // &quot;world&quot;
</code></pre><p><strong>属性名表达式与简洁表示法，不能同时使用</strong>，会报错。</p>
<pre><code>// 报错
const foo = &apos;bar&apos;;
const bar = &apos;abc&apos;;
const baz = { [foo] };

// 正确
const foo = &apos;bar&apos;;
const baz = { [foo]: &apos;abc&apos;};
</code></pre><p><strong>属性名表达式是对象，默认情况下自动将对象转为字符串[object Object]</strong></p>
<pre><code>const keyA = {a: 1};
const keyB = {b: 2};
const myObject = {
  [keyA]: &apos;valueA&apos;,
  [keyB]: &apos;valueB&apos;
};
myObject // Object {[object Object]: &quot;valueB&quot;}

[keyA]和[keyB]得到的都是[object Object]
所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性
</code></pre><h1 id="属性的可枚举性和遍历"><a href="#属性的可枚举性和遍历" class="headerlink" title="属性的可枚举性和遍历"></a>属性的可枚举性和遍历</h1><h2 id="可枚举性"><a href="#可枚举性" class="headerlink" title="可枚举性"></a>可枚举性</h2><h3 id="描述对象（Descriptor）"><a href="#描述对象（Descriptor）" class="headerlink" title="描述对象（Descriptor）"></a>描述对象（Descriptor）</h3><ul>
<li>用来控制该属性的行为。</li>
<li>对象的每个属性都有一个描述对象，</li>
<li>获取该属性的描述对象 <code>Object.getOwnPropertyDescriptor()</code></li>
</ul>
<p>实例：描述对象</p>
<pre><code>let obj = { foo: 123 };
Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;)
//  {
//    value: 123,
//    writable: true,
//    enumerable: true,
//    configurable: true
//  }
</code></pre><h3 id="可枚举性-1"><a href="#可枚举性-1" class="headerlink" title="可枚举性"></a>可枚举性</h3><ul>
<li><strong>描述对象的enumerable属性</strong></li>
<li>最初目的，就是让某些属性可以规避掉for…in操作</li>
</ul>
<p><strong>目前，有四个操作会忽略enumerable为false的属性。</strong></p>
<ul>
<li>for…in循环：只遍历<strong>对象自身</strong>的和<strong>继承</strong>的<strong>可枚举</strong>的属性。</li>
<li>Object.keys()：返回<strong>对象自身</strong>的所有<strong>可枚举</strong>的属性的键名。</li>
<li>Object.assign()： 只拷贝<strong>对象自身</strong>的<strong>可枚举</strong>的属性。</li>
<li>JSON.stringify()：只串行化<strong>对象自身</strong>的<strong>可枚举</strong>的属性。</li>
</ul>
<p>实例：toString和length属性不可枚举</p>
<pre><code>Object.getOwnPropertyDescriptor(Object.prototype, &apos;toString&apos;).enumerable
// false

Object.getOwnPropertyDescriptor([], &apos;length&apos;).enumerable
// false

    上面代码中，toString和length属性的enumerable都是false，
    因此for...in不会遍历到这两个继承自原型的属性。
</code></pre><p><strong>ES6 规定，所有 Class 的原型的方法都是不可枚举的</strong></p>
<p>Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, ‘foo’).enumerable<br>// false<br>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for…in循环，而用Object.keys()代替。</p>
<h2 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h2><h3 id="五种遍历对象的属性的方法"><a href="#五种遍历对象的属性的方法" class="headerlink" title="五种遍历对象的属性的方法"></a>五种遍历对象的属性的方法</h3><p>ES6 一共有 5 种方法可以遍历对象的属性。</p>
<h4 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h4><p>for…in循环遍历<strong>对象自身</strong>的和<strong>继承</strong>的<strong>可枚举属性</strong>（不含 Symbol 属性）。</p>
<h4 id="Object-keys-obj"><a href="#Object-keys-obj" class="headerlink" title="Object.keys(obj)"></a>Object.keys(obj)</h4><p>Object.keys返回一个数组，包括<strong>对象自身</strong>的（不含继承的）所有<strong>可枚举</strong>属性（不含 Symbol 属性）的键名。</p>
<h4 id="Object-getOwnPropertyNames-obj"><a href="#Object-getOwnPropertyNames-obj" class="headerlink" title="Object.getOwnPropertyNames(obj)"></a>Object.getOwnPropertyNames(obj)</h4><p>Object.getOwnPropertyNames返回一个数组，包含<strong>对象自身</strong>的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>
<h4 id="Object-getOwnPropertySymbols-obj"><a href="#Object-getOwnPropertySymbols-obj" class="headerlink" title="Object.getOwnPropertySymbols(obj)"></a>Object.getOwnPropertySymbols(obj)</h4><p>Object.getOwnPropertySymbols返回一个数组，包含<strong>对象自身</strong>的所有 <strong>Symbol</strong> 属性的键名。</p>
<h4 id="Reflect-ownKeys-obj"><a href="#Reflect-ownKeys-obj" class="headerlink" title="Reflect.ownKeys(obj)"></a>Reflect.ownKeys(obj)</h4><p>Reflect.ownKeys返回一个数组，包含<strong>对象自身</strong>的所有键名，不管键名是 <strong>Symbol</strong> 或字符串，也不管是否可枚举。</p>
<h3 id="属性遍历次序规则"><a href="#属性遍历次序规则" class="headerlink" title="属性遍历次序规则"></a>属性遍历次序规则</h3><p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历次序规则。</p>
<ul>
<li>所有数值键，按照数值升序排列。</li>
<li>所有字符串键，按照加入时间升序排列。</li>
<li>所有 Symbol 键，按照加入时间升序排列。</li>
</ul>
<p>实例：</p>
<pre><code>Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })
// [&apos;2&apos;, &apos;10&apos;, &apos;b&apos;, &apos;a&apos;, Symbol()]
上面代码中，Reflect.ownKeys方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是 Symbol 属性。
</code></pre><h1 id="方法的-name-属性"><a href="#方法的-name-属性" class="headerlink" title="方法的 name 属性"></a>方法的 name 属性</h1><p>对象方法也是函数，因此也有name属性，<strong>返回函数名</strong></p>
<ul>
<li>对象的方法使用了取值函数(getter)和存值函数(setter)，<ul>
<li>name属性不在该方法上面</li>
<li>在该方法的属性的描述对象的get和set属性上面</li>
<li>返回值是方法名前加上get和set</li>
</ul>
</li>
<li><p>两种特殊情况</p>
<ul>
<li>bind方法创造的函数<ul>
<li>name属性返回bound加上原函数的名字；</li>
</ul>
</li>
<li><p>Function构造函数创造的函数</p>
<ul>
<li>name属性返回anonymous<br>实例</li>
</ul>
<p>onst obj = {<br>get foo() {},<br>set foo(x) {}<br>};</p>
<p>obj.foo.name<br>// TypeError: Cannot read property ‘name’ of undefined</p>
<p>const descriptor = Object.getOwnPropertyDescriptor(obj, ‘foo’);<br>descriptor.get.name // “get foo”<br>descriptor.set.name // “set foo”</p>
<p>(new Function()).name // “anonymous”</p>
<p>var doSomething = function() {<br>// …<br>};<br>doSomething.bind().name // “bound doSomething”</p>
</li>
</ul>
</li>
</ul>
<h1 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h1><p><strong>是否严格相等</strong></p>
<p>比较两个值是否相等三种方法：</p>
<ul>
<li>相等运算符（==）<ul>
<li>缺点：<ul>
<li><strong>自动转换数据类型</strong></li>
</ul>
</li>
</ul>
</li>
<li>严格相等运算符（===）<ul>
<li>缺点：<ul>
<li>NaN不等于自身</li>
<li>+0等于-0</li>
</ul>
</li>
</ul>
</li>
<li>is()<br>  -ES6 提出<ul>
<li>“Same-value equality”（同值相等)算法</li>
<li>两个值是否<strong>严格相等</strong><ul>
<li>解决了严格比较运算符（===）的两个缺点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p><strong>合并对象，将源对象的所有可枚举属性，复制到目标对象</strong></p>
<pre><code>Object.assign(target, ... source)
</code></pre><ul>
<li><strong>浅拷贝</strong></li>
<li><strong>属性覆盖</strong> 后面的属性会覆盖前面的属性<ul>
<li>目标对象与源对象有同名属性</li>
<li>多个源对象有同名属性</li>
</ul>
</li>
<li>只有一个参数<ul>
<li>直接返回该参数</li>
</ul>
</li>
<li>参数不是对象，自动转成对象<ul>
<li>非首参(源对象)<ul>
<li>数值和布尔值，无效果<ul>
<li>包装对象不产生可枚举属性</li>
</ul>
</li>
<li>字符串，以数组形式拷入目标对象(属性名为元素索引)<ul>
<li>包装对象产生可枚举属性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>undefined和null无法转成对象<ul>
<li>首参，会报错</li>
<li>非首参，跳过</li>
</ul>
</li>
<li><p>取值函数的处理</p>
<ul>
<li><p>求值后复制值<br>实例</p>
<p>const target = { a: 1, b: 1 };<br>const source1 = { b: 2, c: 2 };<br>const source2 = { c: 3 };<br>Object.assign(target, source1, source2);<br>target // {a:1, b:2, c:3}</p>
<p>const obj = {a: 1};<br>Object.assign(obj) === obj // true</p>
<p>Object.assign(undefined) // 报错<br>let obj = {a: 1};<br>Object.assign(obj, undefined) === obj // true</p>
</li>
</ul>
</li>
</ul>
<p>实例：字符串的处理，转为数组对象</p>
<pre><code>const v1 = &apos;abc&apos;;
const v2 = true;
const v3 = 10;
const obj = Object.assign({}, v1, v2, v3);
console.log(obj); // { &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; }
</code></pre><p>实例：数组对象的处理</p>
<pre><code>Object.assign([1, 2, 3], [4, 5])
// [4, 5, 3]
    把数组视为属性名为 0、1、2 的对象
    因此源数组的 0 号属性4覆盖了目标数组的 0 号属性1
</code></pre><p>实例：取值函数的处理</p>
<pre><code>const source = {
  get foo() { return 1 }
};
const target = {};
Object.assign(target, source)
// { foo: 1 }
</code></pre><h2 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h2><h3 id="合并对象-克隆对象"><a href="#合并对象-克隆对象" class="headerlink" title="合并对象/克隆对象"></a>合并对象/克隆对象</h3><h3 id="为对象添加属性"><a href="#为对象添加属性" class="headerlink" title="为对象添加属性"></a>为对象添加属性</h3><p>将x属性和y属性添加到Point类的对象实例</p>
<p>class Point {<br>  constructor(x, y) {<br>    Object.assign(this, {x, y});<br>  }<br>}</p>
<h3 id="为对象添加方法"><a href="#为对象添加方法" class="headerlink" title="为对象添加方法"></a>为对象添加方法</h3><pre><code>Object.assign(SomeClass.prototype, {
  someMethod(arg1, arg2) {
    ···
  },
  anotherMethod() {
    ···
  }
});

// 等同于下面的写法
SomeClass.prototype.someMethod = function (arg1, arg2) {
  ···
};
SomeClass.prototype.anotherMethod = function () {
  ···
};
</code></pre><h3 id="为属性指定默认值"><a href="#为属性指定默认值" class="headerlink" title="为属性指定默认值"></a>为属性指定默认值</h3><p>EFAULTS对象是默认值，options对象是用户提供的参数</p>
<p>Object.assign方法将DEFAULTS和options合并成一个新对象，如果两者有同名属性，则option的属性值会覆盖DEFAULTS的属性值</p>
<pre><code>const DEFAULTS = {
  logLevel: 0,
  outputFormat: &apos;html&apos;
};
function processContent(options) {
  options = Object.assign({}, DEFAULTS, options);
  console.log(options);
  // ...
}
</code></pre><h1 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h1><p>扩展运算符（<code>...</code>）</p>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p><strong>解构赋值必须是最后一个参数</strong>，否则会报错。</p>
<pre><code>let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }
</code></pre><p><strong>变量声明</strong>语句之中，如果使用<strong>解构赋值</strong>，<strong>扩展运算符</strong>后面必须是一个<strong>变量</strong>名，而不能是一个解构赋值表达式</p>
<p><strong>扩展运算符的解构赋值，只能复制对象自身的属性</strong>。 继承的属性无法复制</p>
<pre><code>const o = Object.create({ x: 1, y: 2 });
o.z = 3;
let { x, ...newObj } = o;//这里的扩展运算符后只能是变量，所以引入了中间变量newObj
let { y, z } = newObj;
x // 1
y // undefined
z // 3

变量x是单纯的解构赋值，所以可以读取对象o继承的属性；
变量y和z是扩展运算符的解构赋值，只能读取对象o自身的属性
    所以变量z可以赋值成功，变量y取不到值
</code></pre>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JS/" rel="tag"><i class="fa fa-tag"></i> JS</a>
          
            <a href="/tags/ES6/" rel="tag"><i class="fa fa-tag"></i> ES6</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/31/JS/ES6-Promise对象/" rel="next" title="ES6-Promise对象">
                <i class="fa fa-chevron-left"></i> ES6-Promise对象
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/01/JS/Redux教程/" rel="prev" title="Redux教程">
                Redux教程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="风" />
            
              <p class="site-author-name" itemprop="name">风</p>
              <p class="site-description motion-element" itemprop="description">随心而动，随刃而行</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">118</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">48</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#属性简洁表示法"><span class="nav-number">1.</span> <span class="nav-text">属性简洁表示法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#属性名表达式"><span class="nav-number">2.</span> <span class="nav-text">属性名表达式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#属性的可枚举性和遍历"><span class="nav-number">3.</span> <span class="nav-text">属性的可枚举性和遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#可枚举性"><span class="nav-number">3.1.</span> <span class="nav-text">可枚举性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#描述对象（Descriptor）"><span class="nav-number">3.1.1.</span> <span class="nav-text">描述对象（Descriptor）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可枚举性-1"><span class="nav-number">3.1.2.</span> <span class="nav-text">可枚举性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性的遍历"><span class="nav-number">3.2.</span> <span class="nav-text">属性的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#五种遍历对象的属性的方法"><span class="nav-number">3.2.1.</span> <span class="nav-text">五种遍历对象的属性的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#for…in"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">for…in</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-keys-obj"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">Object.keys(obj)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-getOwnPropertyNames-obj"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">Object.getOwnPropertyNames(obj)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-getOwnPropertySymbols-obj"><span class="nav-number">3.2.1.4.</span> <span class="nav-text">Object.getOwnPropertySymbols(obj)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reflect-ownKeys-obj"><span class="nav-number">3.2.1.5.</span> <span class="nav-text">Reflect.ownKeys(obj)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性遍历次序规则"><span class="nav-number">3.2.2.</span> <span class="nav-text">属性遍历次序规则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#方法的-name-属性"><span class="nav-number">4.</span> <span class="nav-text">方法的 name 属性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Object-is"><span class="nav-number">5.</span> <span class="nav-text">Object.is()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Object-assign"><span class="nav-number">6.</span> <span class="nav-text">Object.assign()</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本使用"><span class="nav-number">6.1.</span> <span class="nav-text">基本使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见用途"><span class="nav-number">6.2.</span> <span class="nav-text">常见用途</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#合并对象-克隆对象"><span class="nav-number">6.2.1.</span> <span class="nav-text">合并对象/克隆对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为对象添加属性"><span class="nav-number">6.2.2.</span> <span class="nav-text">为对象添加属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为对象添加方法"><span class="nav-number">6.2.3.</span> <span class="nav-text">为对象添加方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为属性指定默认值"><span class="nav-number">6.2.4.</span> <span class="nav-text">为属性指定默认值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对象的扩展运算符"><span class="nav-number">7.</span> <span class="nav-text">对象的扩展运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解构赋值"><span class="nav-number">7.1.</span> <span class="nav-text">解构赋值</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">风</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
