<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="编程思想," />










<meta name="description" content="第一章、 整洁代码我们一直需要整洁代码。 可预见的未来，自动化产生代码无法替代人工编写。 第二章、 有意义的命名2.2 名副其实名称应该答复了所有大问题。 为何存在，何用，如何用 如果名称需要注释类补充，就不是名副其实 实例： 消逝的时间，以日记 elapsedTimeInDay; daysSinceCreation fileAgeInDay 2.3 避免误导 避免留下误导的错误仙索。   实例：">
<meta name="keywords" content="编程思想">
<meta property="og:type" content="article">
<meta property="og:title" content="CleanCode">
<meta property="og:url" content="http://yoursite.com/2019/01/14/编程思想/Clean code/index.html">
<meta property="og:site_name" content="风">
<meta property="og:description" content="第一章、 整洁代码我们一直需要整洁代码。 可预见的未来，自动化产生代码无法替代人工编写。 第二章、 有意义的命名2.2 名副其实名称应该答复了所有大问题。 为何存在，何用，如何用 如果名称需要注释类补充，就不是名副其实 实例： 消逝的时间，以日记 elapsedTimeInDay; daysSinceCreation fileAgeInDay 2.3 避免误导 避免留下误导的错误仙索。   实例：">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://my.csdn.net/uploads/201205/14/1336930673_6550.jpg">
<meta property="og:updated_time" content="2020-03-28T10:45:01.604Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CleanCode">
<meta name="twitter:description" content="第一章、 整洁代码我们一直需要整洁代码。 可预见的未来，自动化产生代码无法替代人工编写。 第二章、 有意义的命名2.2 名副其实名称应该答复了所有大问题。 为何存在，何用，如何用 如果名称需要注释类补充，就不是名副其实 实例： 消逝的时间，以日记 elapsedTimeInDay; daysSinceCreation fileAgeInDay 2.3 避免误导 避免留下误导的错误仙索。   实例：">
<meta name="twitter:image" content="http://my.csdn.net/uploads/201205/14/1336930673_6550.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/01/14/编程思想/Clean code/"/>





  <title>CleanCode | 风</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">风</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">技术博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/14/编程思想/Clean code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="风">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">CleanCode</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-14T08:56:53+08:00">
                2019-01-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程思想/" itemprop="url" rel="index">
                    <span itemprop="name">编程思想</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="第一章、-整洁代码"><a href="#第一章、-整洁代码" class="headerlink" title="第一章、 整洁代码"></a>第一章、 整洁代码</h2><p>我们一直需要整洁代码。 可预见的未来，自动化产生代码无法替代人工编写。</p>
<h2 id="第二章、-有意义的命名"><a href="#第二章、-有意义的命名" class="headerlink" title="第二章、 有意义的命名"></a>第二章、 有意义的命名</h2><h2 id="2-2-名副其实"><a href="#2-2-名副其实" class="headerlink" title="2.2 名副其实"></a>2.2 名副其实</h2><p>名称应该答复了所有大问题。 为何存在，何用，如何用</p>
<p>如果名称需要注释类补充，就不是名副其实</p>
<p>实例： 消逝的时间，以日记</p>
<pre><code>elapsedTimeInDay;
daysSinceCreation
fileAgeInDay
</code></pre><h2 id="2-3-避免误导"><a href="#2-3-避免误导" class="headerlink" title="2.3 避免误导"></a>2.3 避免误导</h2><ul>
<li><p>避免留下误导的错误仙索。</p>
<p>  实例： 一组账号</p>
<pre><code>accountList 最好别用，即使真是List&lt;Account&gt;。List对程序员有特殊含义
accounts 推荐使用
</code></pre></li>
<li><p>避免使用不同之处较小的名称</p>
<p>  现代IDE都能自动提示自动补全，假如相似的名称放在一起，不同之处较小，分清楚得花多少时间</p>
</li>
</ul>
<h2 id="2-4-做有意义的区分"><a href="#2-4-做有意义的区分" class="headerlink" title="2.4 做有意义的区分"></a>2.4 做有意义的区分</h2><p>错误示例：</p>
<ul>
<li>a,b,c</li>
<li>list1,list2</li>
<li>Product,ProductInfo,ProductData</li>
<li>name,nameString</li>
</ul>
<h2 id="使用读得出来的名称"><a href="#使用读得出来的名称" class="headerlink" title="使用读得出来的名称"></a>使用读得出来的名称</h2><p>方便交流</p>
<h2 id="2-6-使用可搜索的名称"><a href="#2-6-使用可搜索的名称" class="headerlink" title="2.6 使用可搜索的名称"></a>2.6 使用可搜索的名称</h2><p>单字母名称和数字常量，都是无法搜索</p>
<p>MAX_COLUM_PER_PAGE 能搜索出来，常量 7 麻烦了</p>
<h2 id="2-7-避免使用编码"><a href="#2-7-避免使用编码" class="headerlink" title="2.7 避免使用编码"></a>2.7 避免使用编码</h2><p>现在语言中使用编码，纯属多余的负担</p>
<h3 id="2-7-1-匈牙利命名法"><a href="#2-7-1-匈牙利命名法" class="headerlink" title="2.7.1 匈牙利命名法"></a>2.7.1 匈牙利命名法</h3><p>windows c 语言 API 时代，程序员需要匈牙利命名法来帮助自己记住类型。</p>
<ul>
<li>类型不好区分：整数句柄，长指针，void指针，string的几种实现（不同属性/用途）</li>
<li>编译器不做类型检查</li>
</ul>
<h3 id="2-7-2-成员前缀"><a href="#2-7-2-成员前缀" class="headerlink" title="2.7.2 成员前缀"></a>2.7.2 成员前缀</h3><p>类和函数足够小，自然不需要 m_ 前缀来表明成员变量</p>
<p>现代IDE 都自动用高亮来 标识成员变量</p>
<h3 id="2-7-3-接口和实现"><a href="#2-7-3-接口和实现" class="headerlink" title="2.7.3 接口和实现"></a>2.7.3 接口和实现</h3><p>用户根本不需要知道这个是接口。</p>
<p>我说如果，一定要选一个编码的话，宁愿选择给实现编码。</p>
<h2 id="2-8-避免思维映射"><a href="#2-8-避免思维映射" class="headerlink" title="2.8 避免思维映射"></a>2.8 避免思维映射</h2><p>不要让读者非得把你的名称映射/翻译为他们熟知的名称。 明确是王道</p>
<h2 id="2-9-类名"><a href="#2-9-类名" class="headerlink" title="2.9 类名"></a>2.9 类名</h2><ul>
<li><p>类名应是名词/名词短语。</p>
<pre><code>Address，AddressParser
</code></pre></li>
<li><p>避免使用Manager，Processor，Data，Info。 出现说明类过大/命名不明确</p>
</li>
</ul>
<h2 id="2-10-方法名"><a href="#2-10-方法名" class="headerlink" title="2.10 方法名"></a>2.10 方法名</h2><ul>
<li><p>方法名应是动词</p>
<pre><code>deletePage，save
</code></pre></li>
<li><p>重载构造器是，使用静态工厂方法名</p>
<pre><code>Message.fromType(1) 好过 new Message(1);
</code></pre></li>
</ul>
<h2 id="2-11-别扮可爱"><a href="#2-11-别扮可爱" class="headerlink" title="2.11 别扮可爱"></a>2.11 别扮可爱</h2><p>别为了扮可爱，用一些不好理解的词命名</p>
<h2 id="2-12-每个概念对应一个词"><a href="#2-12-每个概念对应一个词" class="headerlink" title="2.12 每个概念对应一个词"></a>2.12 每个概念对应一个词</h2><p>给每个抽象概念选一个词，并一以贯之。</p>
<p>错误范例： </p>
<ul>
<li>使用 <code>fetch</code> , <code>retrive</code>, <code>find</code>, <code>get</code> 来给查询命名，怎么记得住哪个类中用哪个方法呢</li>
<li><code>controller</code> , <code>manager</code> , <code>driver</code></li>
</ul>
<h2 id="2-13-别用双关语（一个词用于多个概念-目的）"><a href="#2-13-别用双关语（一个词用于多个概念-目的）" class="headerlink" title="2.13 别用双关语（一个词用于多个概念/目的）"></a>2.13 别用双关语（一个词用于多个概念/目的）</h2><p><code>add</code> 用于多个场景/目的：</p>
<ul>
<li>连接两个字符串。 <code>append</code> 就挺好</li>
<li>将一个对象放到集合中。 <code>insert</code> 可以</li>
</ul>
<h2 id="2-14-使用解决方案领域名称"><a href="#2-14-使用解决方案领域名称" class="headerlink" title="2.14 使用解决方案领域名称"></a>2.14 使用解决方案领域名称</h2><p>只有程序员才会读你的代码，放心地使用解决方案领域名称吧。</p>
<p>使用问题领域名称，难道你指望你的客户会跟你讨论代码。</p>
<h2 id="2-15-使用源自所涉问题领域的名称"><a href="#2-15-使用源自所涉问题领域的名称" class="headerlink" title="2.15 使用源自所涉问题领域的名称"></a>2.15 使用源自所涉问题领域的名称</h2><p>如果实在不能用解决方案领域名称命名，那就用所涉问题领域名称吧。至少，负责维护的程序员就能去请教领域专家了。</p>
<h2 id="2-16-添加有意义的语境"><a href="#2-16-添加有意义的语境" class="headerlink" title="2.16 添加有意义的语境"></a>2.16 添加有意义的语境</h2><p>多数名称都不能自我说明，需要良好命令的类、函数、名称空间来提供语境。如果没有，给名称添加前缀是最后一招了。</p>
<p>addressFirstName，addressState</p>
<h1 id="第三章、函数"><a href="#第三章、函数" class="headerlink" title="第三章、函数"></a>第三章、函数</h1><h2 id="3-1-短小"><a href="#3-1-短小" class="headerlink" title="3.1 短小"></a>3.1 短小</h2><h3 id="代码块和缩进"><a href="#代码块和缩进" class="headerlink" title="代码块和缩进"></a>代码块和缩进</h3><p>代码块(if/else,while等)应该只有一行（调用函数），缩进层级不该多于两层。</p>
<h2 id="3-2-只做一件事"><a href="#3-2-只做一件事" class="headerlink" title="3.2 只做一件事"></a>3.2 只做一件事</h2><p>判断函数是否只做了一件事：能否再拆出一个函数</p>
<h2 id="3-3-每个函数一抽象层级"><a href="#3-3-每个函数一抽象层级" class="headerlink" title="3.3 每个函数一抽象层级"></a>3.3 每个函数一抽象层级</h2><p>如何确保函数只做一件事：函数中的语句都在同一抽象层级上。</p>
<h3 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h3><p>每个函数后面紧跟位于下一抽象层级的函数（被调用的函数）</p>
<h2 id="3-4-switch语句"><a href="#3-4-switch语句" class="headerlink" title="3.4 switch语句"></a>3.4 <a href="http://feikiss.iteye.com/blog/1454010" target="_blank" rel="noopener">switch语句</a></h2><p>即使只有两种条件的switch语句也比我想要的单个代码块或函数大得多。而switch天生要做N件事。</p>
<p>不幸我们总无法避开switch语句，我们可以<strong>利用多态来确保每个switch都埋藏在较低的抽象层级，且永不重复</strong>。</p>
<pre><code>public Money calculatePay(Employee e) thorws InvalidEmployeeType {  
    switch(e.type)  {  
       case COMMISSIONED:  
            return calculateCommissionedPay(e);  
       case HOURLY:  
            return calculateHourlyPay(e);  
       case SALARIED:  
             return calculateSalariedPay(e);  
       default:  
             throw new InvalidEmployeeType(e.type);  
}  
</code></pre><p>该函数问题：</p>
<ul>
<li>首先，太长，当出现新的雇员时，它还会更长</li>
<li>其次，明显做了不止一件事。</li>
<li>第三，违反了单一权责原则，因为有好几个修改它的理由。</li>
<li>第四，违反了开-关原则，因为每当添加新的雇员类型时，就必须修改它。</li>
<li><p>最麻烦的，可能是到处皆有类似结构的函数。都需要重复同样的switch结构</p>
<p>  例如，可能会有： </p>
<pre><code>isPayday(Employ e, Date date)  
deliverPay(Employee e, Money pay)
</code></pre></li>
</ul>
<p>解决方案：</p>
<p>将switch语句埋到抽象工厂底下，不让任何人看到。</p>
<p>使用switch语句为Employee的派生类创建适当的实体，而不同的函数，如calculatePay、isPayday和deliverPay等，则由Employee接口动态的调用相应子类方法。 </p>
<pre><code>public interface Employee{  
    public boolean isPayday();  
    public Money calculatePay();  
    public void deliverPay(Money pay);  

} 

public interface EmployeeFactory{  
    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;  
} 

public class EmployeeFactoryImpl implements EmployeeFactory{  
    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType{  
        switch(r.type){  
        case COMMISSIONED:  
            return new CommissionedEmployee(r);  
        case HOURLY:  
            return new HourlyEmployee(r);  
        case SALARIED:  
            return new SalariedEmployee(r);  
        default:  
            throw new InvalidEmployeeType(r.type);  
        }  
    }  
} 
</code></pre><h2 id="3-5-使用描述性的名称"><a href="#3-5-使用描述性的名称" class="headerlink" title="3.5 使用描述性的名称"></a>3.5 使用描述性的名称</h2><p>名称描述函数做的事</p>
<h2 id="3-6-函数参数"><a href="#3-6-函数参数" class="headerlink" title="3.6 函数参数"></a>3.6 函数参数</h2><p>尽量避免三个参数，有足够特殊的理由才能使用多参函数（三个参数以上）。</p>
<h3 id="3-6-1-一元函数的普遍形式"><a href="#3-6-1-一元函数的普遍形式" class="headerlink" title="3.6.1 一元函数的普遍形式"></a>3.6.1 一元函数的普遍形式</h3><h3 id="3-6-2-标识参数"><a href="#3-6-2-标识参数" class="headerlink" title="3.6.2 标识参数"></a>3.6.2 标识参数</h3><p>标识参数大声宣布，本函数不止做一件事。一定要避免。</p>
<h3 id="3-6-3-二元函数"><a href="#3-6-3-二元函数" class="headerlink" title="3.6.3 二元函数"></a>3.6.3 二元函数</h3><h3 id="3-6-4-三元函数"><a href="#3-6-4-三元函数" class="headerlink" title="3.6.4 三元函数"></a>3.6.4 三元函数</h3><h3 id="3-6-5-参数对象"><a href="#3-6-5-参数对象" class="headerlink" title="3.6.5 参数对象"></a>3.6.5 参数对象</h3><p>如果函数确实需要两个以上的参数，说明应将一些参数封装为类了。</p>
<h3 id="3-6-6-参数列表"><a href="#3-6-6-参数列表" class="headerlink" title="3.6.6 参数列表"></a>3.6.6 参数列表</h3><p>同类型的可变参数列表，其实可以算作一个参数（List类型的参数）</p>
<pre><code>public static String format(String format, Object... args)  二元函数
</code></pre><h3 id="3-6-7-动词与关键词"><a href="#3-6-7-动词与关键词" class="headerlink" title="3.6.7 动词与关键词"></a>3.6.7 动词与关键词</h3><p>好名字的函数，能很好的解释函数意图、参数顺序和意图</p>
<ul>
<li><p>动词</p>
<p>  一元函数。 函数名和参数名形成一种非常好的动词/名词形式</p>
<ul>
<li>write(name) write的对象是name</li>
<li>writeField(name) 更好的名词，同时声明name是一个field</li>
</ul>
</li>
<li><p>关键词</p>
<p>  把参数名称编码成函数名一部分，大大减轻记忆参数顺序的负担</p>
<ul>
<li>assertExpectedEquasActual(expected，actual）</li>
</ul>
</li>
</ul>
<h3 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h3><p>绝对不要使用输出参数。那是面向对象编程之前远古岁月的一个不得而为之的手段</p>
<h2 id="3-7-无副作用"><a href="#3-7-无副作用" class="headerlink" title="3.7 无副作用"></a>3.7 无副作用</h2><p>副作用是一种谎言。做了函数名说明的事情之外的事，就是副作用。</p>
<p>函数承诺只做一件事，做其他被藏起来的事，这是破坏性的，会导致时序性耦合和顺序依赖</p>
<ul>
<li>对类变量做出未能预期的改动</li>
<li>把变量搞成向函数传递的参数/系统全局变量</li>
</ul>
<p><code>public boolean checkPassword(userName, password)</code> 函数名只是校验密码，但是内部，当密码错误，却调用Session.initalize，这是非常致命的副作用。调用者冒着丢失现有会话数据的风险。时序性耦合令人迷惑，躲在函数副作用之后，就更难排查了。</p>
<h2 id="3-8-分隔指令与查询"><a href="#3-8-分隔指令与查询" class="headerlink" title="3.8 分隔指令与查询"></a>3.8 分隔指令与查询</h2><p>函数只做一件事：</p>
<ul>
<li>指令。修改对象</li>
<li>查询。查询对象</li>
</ul>
<p>实例：</p>
<pre><code>public boolean set(key,value) 设置某个属性，成功返回true

从读者角度考虑一下，if(set(&quot;username&quot;,&quot;bob&quot;)) 是什么含义：
    1. username属性值之前是否已经设置为bob
    2. username属性值设置为bob是否执行成功

作者本意，set是动词，是指令函数。但在if语句块中，set像个形容词
</code></pre><p>解决方案：分隔指令与查询</p>
<pre><code>if(keyExists(&quot;username&quot;)){
    setKeyValue(&quot;username&quot;,&quot;bob&quot;);
}
</code></pre><h2 id="3-9-使用异常代替返回错误码"><a href="#3-9-使用异常代替返回错误码" class="headerlink" title="3.9 使用异常代替返回错误码"></a>3.9 使用异常代替返回错误码</h2><p>指令函数返回错误码，违反分隔指令与查询规则。</p>
<p>返回错误码弊端：</p>
<ul>
<li>要求调用者立刻处理错误</li>
<li>造成异常处理代码与正常逻辑混合在一起</li>
<li>导致多层嵌套</li>
<li>依赖磁铁。错误码通常是一个类，许多地方都导入和使用，该类修改会影响所有使用该类的类。使用异常码，新异常可以直接从异常基类派生出来</li>
</ul>
<h3 id="3-9-1-抽离-try-catch-代码块"><a href="#3-9-1-抽离-try-catch-代码块" class="headerlink" title="3.9.1 抽离 try/catch 代码块"></a>3.9.1 抽离 try/catch 代码块</h3><p>try/catch 把 错误处理代码与正常逻辑混合在一起</p>
<pre><code>try {
    deletePage(page);
    registry.deleteReference(page.name);
    configKeys.deleteKey(page.name.makeKey());
}
catch (Exception e) {
    logger.log(e.getMessage());
}
</code></pre><p>抽离后</p>
<pre><code>public void delete(Page page) {
    try {
        deletePageAndAllReferences(page);
    } catch (Exception e) {
        logErrot(e);
    }
}

private void deletePageAndAllReferences(Page page) {
    deletePage(page);
    registry.deleteReference(page.name);
    configKeys.deleteKey(page.name.makeKey());
}

private void logErrot(Exception e) {

}
</code></pre><h3 id="3-9-2-错误处理就是一件事"><a href="#3-9-2-错误处理就是一件事" class="headerlink" title="3.9.2 错误处理就是一件事"></a>3.9.2 错误处理就是一件事</h3><h2 id="3-10-别重复自己"><a href="#3-10-别重复自己" class="headerlink" title="3.10 别重复自己"></a>3.10 别重复自己</h2><p>消除系统中的重复代码。</p>
<p>重复代码导致一个改变影响多处代码，修改过程中非常有可能遗漏</p>
<h1 id="第四章、-注释"><a href="#第四章、-注释" class="headerlink" title="第四章、 注释"></a>第四章、 注释</h1><p>注释承认自己代码表达能力的失败</p>
<p>注释不能美化糟糕的代码。</p>
<p>代码维护过程中，注释和代码分离是很常见的，大家维护的焦点就是代码，这时错误过时的注释，反而误导对代码的理解</p>
<h2 id="第五章、格式"><a href="#第五章、格式" class="headerlink" title="第五章、格式"></a>第五章、格式</h2><h2 id="第六章、-对象和数据结构-Objects-and-Data-Structures"><a href="#第六章、-对象和数据结构-Objects-and-Data-Structures" class="headerlink" title="第六章、 对象和数据结构 Objects and Data Structures"></a>第六章、 对象和数据结构 Objects and Data Structures</h2><p>私有变量的理由：</p>
<ul>
<li>保护数据</li>
<li>不被外部依赖，修改并不影响其他类</li>
</ul>
<p>但是，为什么有那么多程序员给对象添加 setter和getter，就如同公共变量一般？</p>
<h2 id="6-1-数据抽象"><a href="#6-1-数据抽象" class="headerlink" title="6.1 数据抽象"></a>6.1 数据抽象</h2><p>抽象：隐藏实现。并不是简单的在变量间放上一个函数层（setter/getter），而是暴露抽象接口，以便用户无需了解数据的实现就能操作数据</p>
<p>实例：机动车燃料层</p>
<pre><code>public interface Vehicle {
    double getFuelTankCapacityInGallons(); //油箱容量，单位加仑
    double getGallonsOfGasoline(); //汽油量，加仑
}

public interface Vehicle{
    double getFuelRemainingPercent(); //燃料剩余百分比
}
</code></pre><p>采用百分比抽象，无法确定Vehicle类中数据形态。</p>
<p>抽象并不是简单的setter/getter，而是以最好的方式呈现对象的数据</p>
<h2 id="6-2-数据、对象的反对称性-Anti-Symmetry"><a href="#6-2-数据、对象的反对称性-Anti-Symmetry" class="headerlink" title="6.2 数据、对象的反对称性 Anti-Symmetry"></a>6.2 数据、对象的反对称性 Anti-Symmetry</h2><p>数据结构和对象时对立的。</p>
<p><strong>对象和数据结构间的二分原理：</strong></p>
<ul>
<li><p>数据结构：</p>
<ul>
<li>暴露数据，不提供有意义的函数。</li>
<li><strong>面向过程/方法</strong>，不改动既有数据结构即可<strong>添加新函数</strong>，添加新数据结构得修改所有函数。（本身无方法，方法都在另一个类中）</li>
</ul>
</li>
<li><p>对象：</p>
<ul>
<li>隐藏数据，暴露行为。</li>
<li><strong>面向对象</strong>，不改动既有函数即可<strong>添加新对象</strong>，添加新函数所有对象都得修改。</li>
</ul>
</li>
</ul>
<p>优秀的开发者不带成见地了解两者，依据工作性质选择其中一种手段</p>
<p>代码：</p>
<ul>
<li><p>数据结构-面向过程</p>
<pre><code>public class Square{
    public point topLeft;
    public double side;
}

public class Rectangle{
    public point topLeft;
    public double height;
    public double width;
}

public class Geometry{//几何
    public double area(Object shape){
        if(shape instanceOf Square){
            Square s = (Square) shape;
            return s.side * s.side;
        }else if(shape instanceOf Rectangle){
            Rectangle r = (Rectangle) shape;
            return r.height * r.width;
        }
        throw new NoSuchShapeException();
    }
}
</code></pre><ul>
<li>想增加一个函数 perimeter 求周长，原有数据结构完全不受影响</li>
<li>想添加一个新数据结构，就得修改 所有已有函数来处理新数据结构</li>
</ul>
</li>
<li><p>对象-面向对象</p>
<pre><code>public interface Shape{
    double area();
}

public class Square implements Shape{
    public point topLeft;
    public double side;

    public double area(){
        return side * side;
    }
}

public class Rectangle implements Shape{
    public point topLeft;
    public double height;
    public double width;

    public double area(){
        return height * width;
    }
}
</code></pre><ul>
<li>想增加一个函数 perimeter 求周长，原有对象都得修改实现该函数</li>
<li>想添加一个新对象，原有函数都不会受影响</li>
</ul>
</li>
</ul>
<h2 id="6-3-Law-of-Demeter"><a href="#6-3-Law-of-Demeter" class="headerlink" title="6.3 Law of Demeter"></a>6.3 Law of Demeter</h2><p>迪米特法则（Law of Demeter 简写LoD）又叫作最少知道原则（Least Knowledge Principle 简写LKP），就是说一个对象应当对其他对象尽可能少的了解,不和陌生人说话。talk only to your immediate friends</p>
<h3 id="“朋友”类型："><a href="#“朋友”类型：" class="headerlink" title="“朋友”类型："></a>“朋友”类型：</h3><ol>
<li>当前对象本身（this）</li>
<li>方法参量对象</li>
<li>实例变量对象</li>
<li>实例变量如果是一个聚集，那么聚集中的元素也都是朋友</li>
<li>当前对象所创建的对象</li>
</ol>
<p><a href="http://www.cnblogs.com/silentjesse/p/3510966.html" target="_blank" rel="noopener">实例：老师让体育委员清点女生人数</a></p>
<pre><code>public class Teacher{
    public void command(GroupLeader groupLeader）{
        List&lt;Girl&gt; girls = new ArrayList();
        for(int i = 0; i&lt;20; i++){
            girls.add(new Girl());
        }

        groupLeader.countGirls(girls);
    }
}

public class GroupLeader{
    public void countGirls(List&lt;Girl&gt; girls){
        System.out.println(&quot;女生数量是：&quot; + girls.size());
    }
}

public class Girl{}

public class Client{
    public static void main(String[] args){
        Teacher teacher = new Teacher();
        teacher.commond(new GroupLeader());
    }
}
</code></pre><p>存在的问题：</p>
<ul>
<li>Teacher 只有一个朋友类 GroupLeader。 Teacher 完全不知道自己依赖Girl，这违反LoD，应该把 List<girl> girls 声明为成员变量</girl></li>
<li>Teacher 最少知道原则，完全不需要知道 Girl，所以即使 List<girl> girls 声明为成员变量，还是违反 最少知道原则</girl></li>
</ul>
<p>修改：</p>
<pre><code>public class Teacher{
    public void command(GroupLeader groupLeader）{
        groupLeader.countGirls();
    }
}

public class GroupLeader{
    private List&lt;Girl&gt; girls

    public GroupLeader（List&lt;Girl&gt; girls）{
        this.girls = girls;
    }

    public void countGirls(){
        System.out.println(&quot;女生数量是：&quot; + girls.size());
    }
}

public class Girl{}

public class Client{
    public static void main(String[] args){
        List&lt;Girl&gt; girls = new ArrayList();
        for(int i = 0; i&lt;20; i++){
            girls.add(new Girl());
        }

        Teacher teacher = new Teacher();
        teacher.commond(new GroupLeader(girls));
    }
}
</code></pre><h3 id="LoD-在设计中的应用"><a href="#LoD-在设计中的应用" class="headerlink" title="LoD 在设计中的应用"></a><a href="http://blog.csdn.net/lovelion/article/details/7563445" target="_blank" rel="noopener">LoD 在设计中的应用</a></h3><p>最少知道原则：</p>
<ul>
<li><p>尽量减少对象间的交互。 </p>
<ul>
<li>类耦合度越低，越利于复用</li>
<li>可以通过引入一个合理的第三者来降低对象间的耦合度</li>
</ul>
</li>
<li><p>尽量减少类的公共变量和公共方法。 处在松耦合中的类修改，不会对关联的类造成太大波及</p>
</li>
</ul>
<p>实例：单击按钮(Button)，列表框(List)、组合框(ComboBox)、文本框(TextBox)、文本标签(Label)发生改变</p>
<ul>
<li>存在的问题： 四个朋友类。扩展性差，不便于增加/删除控件</li>
<li>重构方案： 引入控件交互的中间类(Mediator调解人中介物)来降低界面控件之间的耦合度</li>
</ul>
<p><img src="http://my.csdn.net/uploads/201205/14/1336930673_6550.jpg" alt=""></p>
<h2 id="6-4-数据传送对象-Data-Transfer-Objects"><a href="#6-4-数据传送对象-Data-Transfer-Objects" class="headerlink" title="6.4 数据传送对象 Data Transfer Objects"></a>6.4 数据传送对象 Data Transfer Objects</h2><p>Data Transfer Objects（简写 DTO）：只有公共变量，没有方法的类，是最精练的数据结构。</p>
<p>非常有用的结构，尤其在通信场景中（数据库，网络等）</p>
<p>DTO 比 常用的 javaBean 更简洁</p>
<h1 id="第七章、错误处理"><a href="#第七章、错误处理" class="headerlink" title="第七章、错误处理"></a>第七章、错误处理</h1><h2 id="7-1-使用异常而非返回码"><a href="#7-1-使用异常而非返回码" class="headerlink" title="7.1 使用异常而非返回码"></a>7.1 使用异常而非返回码</h2><p>抛出异常代替返回错误码，这样调用代码很整洁，逻辑不会被错误错误处理搞乱</p>
<h2 id="7-2-先写-Try—Catch-Finally-语句"><a href="#7-2-先写-Try—Catch-Finally-语句" class="headerlink" title="7.2 先写 Try—Catch-Finally 语句"></a>7.2 先写 Try—Catch-Finally 语句</h2><p>能帮你定义代码应该期待什么</p>
<h2 id="7-3-使用不可控异常-unchecked-exception"><a href="#7-3-使用不可控异常-unchecked-exception" class="headerlink" title="7.3 使用不可控异常 unchecked exception"></a>7.3 使用不可控异常 unchecked exception</h2><p>可控异常–每个方法的签名声明可能抛出的异常</p>
<p>可控异常违反 开放/闭合原则，低层方法异常的修改必将影响高层方法的签名。如果catch语句在抛出异常的方法三个层级之上，catch语句和抛出异常处之间的每个方法签名中声明该异常，这成本太高，不值票价。</p>
<h2 id="7-4-给出异常发生的环境说明"><a href="#7-4-给出异常发生的环境说明" class="headerlink" title="7.4 给出异常发生的环境说明"></a>7.4 给出异常发生的环境说明</h2><p>抛出的每个异常，须提供足够的环境说明，以便判断错误来源和处所</p>
<p>java的stack trace 无法告知异常的初衷</p>
<h2 id="7-5-依调用者需要定义异常类"><a href="#7-5-依调用者需要定义异常类" class="headerlink" title="7.5 依调用者需要定义异常类"></a>7.5 <code>依调用者需要</code>定义异常类</h2><p>定义异常类最重要的考虑：<strong>异常该如何被捕获</strong></p>
<p><code>没太理解</code> 例子是 封装一个抛出多种异常的三方API为一个自定义异常，从而整洁代码</p>
<h2 id="7-6-定义常规流程"><a href="#7-6-定义常规流程" class="headerlink" title="7.6 定义常规流程"></a>7.6 定义常规流程</h2><p>遵循前文的建议，业务逻辑和错误处理会良好分离。</p>
<p>却把错误处理推到的程序边缘地带。封装三方API而抛出自定义的异常，只在最顶层处理错误。</p>
<p>但有时候，你可以不用抛出异常</p>
<p>下面的笨代码，计算 工资总数: <code>如果有餐食花费，计入总额，如果没有则获得每日标准餐补，计入总额</code>。</p>
<pre><code>try{
    MealExpenses expenses = expensesDAO.getMeals(employeeId);
    total += expenses.getTotal();
}catch(MealExpensesNotFound e){
    total += getMealPerDiem(); //PerDiem allowance 按日补贴
}
</code></pre><p>异常打断了义务逻辑。如果不用处理特殊情况，代码会整洁很多</p>
<p>实现方法是使用 <strong>特例模式（Special Case Pattern）</strong>。使用一个特例类封装异常，客户代码就不用处理异常了</p>
<p>具体到上例：expensesDAO.getMeals 总是返回 MealExpenses。若没有餐食花费，返回一个 餐食补贴的 MealExpenses 对象</p>
<pre><code>public class PerDiemMealExpenses implements MealExpenses{}
</code></pre><h2 id="7-7-别返回null"><a href="#7-7-别返回null" class="headerlink" title="7.7 别返回null"></a>7.7 别返回null</h2><p>随处可见的 null 检查，代码糟糕透了。</p>
<p>返回null，不如抛出异常。</p>
<p>特例对象是爽口良药。</p>
<p>如果三方API可能返回null，考虑重新封装，在新方法中抛异常或返回特例对象。</p>
<h2 id="7-8-别传递null"><a href="#7-8-别传递null" class="headerlink" title="7.8 别传递null"></a>7.8 别传递null</h2><p>返回null很糟糕，传递null更糟糕。</p>
<p>在定义方法时，使用@NotNull 注解</p>
<h2 id="7-9-总结"><a href="#7-9-总结" class="headerlink" title="7.9 总结"></a>7.9 总结</h2><p>整洁代码要可读，也要强固。</p>
<p>可读与强固并不冲突。</p>
<p>分离业务逻辑和错误处理，就能写出可读而强固的整洁代码</p>
<h1 id="第八章、边界"><a href="#第八章、边界" class="headerlink" title="第八章、边界"></a>第八章、边界</h1><h2 id="8-1-使用第三方代码"><a href="#8-1-使用第三方代码" class="headerlink" title="8.1 使用第三方代码"></a>8.1 使用第三方代码</h2><p>接口提供者和接口使用者之间，存在与生俱来的张力。提供者追求普适性以吸引广泛用户，使用者追求集中满足特定需求。这种张力会导致系统边界上出现问题。</p>
<p><strong>以java.util.Map为例</strong></p>
<p>Map提供了丰富灵活的方法，但也要付出代价。</p>
<ul>
<li>Map中可以存放任何类型对象，访问对象时需要判断与转换类型。 <code>Sensor s = (Sensor) sensors.get(sendorId)</code></li>
<li>当Map被修改时，所有用到Map的地方都要跟着修改。Java 5 加入泛型支持，的确见到很多系统都要做大量改动才能</li>
<li>超出控制。我们初衷可能不允许删除Map中的任何对象，但Map提供了删除接口</li>
</ul>
<p>整洁方式</p>
<p>public class sensors{<br>    private Map&lt;string,Sendor&gt; sensors = new HashMap();</p>
<pre><code>public Sensor getById(String id){
    return sensors.get(id);
}
</code></pre><p>}</p>
<p>边界接口（Map）是隐藏的。该接口封装后能适应业务的需要，易于理解，难以误用</p>
<h2 id="8-2-浏览和学习边界"><a href="#8-2-浏览和学习边界" class="headerlink" title="8.2 浏览和学习边界"></a>8.2 浏览和学习边界</h2><p>学习第三方代码很难。整合第三方代码也很难。同时做这两件事难上加难。</p>
<p>更好的做法是，不要在生产代码中实验新东西，而是编写测试来遍览和理解第三方代码。即<strong>学习型测试</strong>。</p>
<h2 id="8-3-学习log4j"><a href="#8-3-学习log4j" class="headerlink" title="8.3 学习log4j"></a>8.3 学习log4j</h2><p>Log4j是一个功能强大的日志组件,提供方便的日志记录</p>
<h2 id="8-4-学习性测试的好处不只是免费"><a href="#8-4-学习性测试的好处不只是免费" class="headerlink" title="8.4 学习性测试的好处不只是免费"></a>8.4 学习性测试的好处不只是免费</h2><p>学习性测试不光免费，还在投资上有正面的回报。</p>
<p>当第三方程序包发布了新版本，我们可以运行学习性测试，看看程序包的行为有没有改变。</p>
<p>无论你是否通过学习型测试来学习，总要有与生产代码调用方式一直的测试来支持整洁的边界。边界测试是减轻迁移劳力的有效方法。</p>
<h2 id="8-5-使用尚不存在的代码"><a href="#8-5-使用尚不存在的代码" class="headerlink" title="8.5 使用尚不存在的代码"></a>8.5 使用尚不存在的代码</h2><p>还有另一种边界，那种将已知和未知分隔开的边界。在代码中总有许多地方是我们的知识未及之处。有时，边界那边就是未知的（至少目前未知）。有时，我们并不往边界那边看过去。</p>
<p>工作中，并发编程总是在边界接口未实现的情况下开始工作。自定义接口（模拟对依赖接口的封装）就很有用了</p>
<h2 id="8-6-整洁的边界"><a href="#8-6-整洁的边界" class="headerlink" title="8.6 整洁的边界"></a>8.6 整洁的边界</h2><p>依赖你能控制的东西，好过依赖你控制不了的东西，免得日后受它控制。</p>
<p>可以像上文对象Map那样<strong>包装</strong>他们，也可以使用 <strong>适配器模式（Adapter Pattern）</strong>将我们的接口转换为第三方接口。</p>
<h1 id="第十章、类"><a href="#第十章、类" class="headerlink" title="第十章、类"></a>第十章、类</h1><h2 id="10-1-类的组织"><a href="#10-1-类的组织" class="headerlink" title="10.1 类的组织"></a>10.1 类的组织</h2><p>遵循自顶向下原则，让程序读起来像一篇报纸。</p>
<p>顺序：先静态，后实体；先公有，后私有；</p>
<p>私有函数应紧跟调用它的公有函数。</p>
<h2 id="10-2-类应该短小"><a href="#10-2-类应该短小" class="headerlink" title="10.2 类应该短小"></a>10.2 类应该短小</h2><p><strong>函数大小标准：代码行数；类大小标准：权责（Responsibility）数量</strong></p>
<p><strong>类名应当描述其权责</strong>。命名正是帮组判断类长度的一个手段。如果无法为类精确命名，这个类大概就太长了。类中包括含义模糊的词（如Processor、Manager，Super）,说明有不恰当的权责聚集</p>
<h3 id="10-2-1-单一权责原则-SRP"><a href="#10-2-1-单一权责原则-SRP" class="headerlink" title="10.2.1 单一权责原则 SRP"></a>10.2.1 单一权责原则 SRP</h3><p><strong>类或模块应且只有一条加以修改的理由</strong>。</p>
<p>鉴别权责（修改理由）常常帮助我们认识并创建更好的抽象</p>
<p>很多开发者害怕数量巨大的短小类会导致难以一目了然抓住全局。常常为了搞清一个功能而在类间跳来跳去。</p>
<p>问题是：抽屉中有许多定义和标记良好的小箱子，还是把工具随便扔到抽屉中，更容易组织管理呢？</p>
<p><strong>系统应由许多短小的类组成，而不是少量巨大的类组成。每个小类封装一个权责，只有一个修改的理由，并与其他类一起协同完成系统行为</strong></p>
<h3 id="10-2-2-内聚"><a href="#10-2-2-内聚" class="headerlink" title="10.2.2 内聚"></a>10.2.2 内聚</h3><p>类应该只有少量实体变量。通常而言，方法操作的变量越多，就越黏聚到类上。如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。</p>
<p>一般来说，创建极大化内聚类是既不可取也不可能的；另一方面，我们希望内聚性保持在较高位置。</p>
<p>内聚性高，意味着类中的方法和变量互相依赖、互相结合成一个逻辑整体。</p>
<p>保持函数参数列表短小，有时会导致类实体变量增多。这时往往意味着需要拆分类，提高内聚性。</p>
<h3 id="10-2-3-保持内聚性就会得到许多短小的类"><a href="#10-2-3-保持内聚性就会得到许多短小的类" class="headerlink" title="10.2.3 保持内聚性就会得到许多短小的类"></a>10.2.3 保持内聚性就会得到许多短小的类</h3><p>仅仅简单将大函数切割为小函数，而且保持函数参数简洁，会导致实体变量增多。比如，大函数用到4个变量，函数拆分后就得变成四个实体变量。</p>
<p>而这4个变量可能就2个方法使用了，这意味着丧失了内聚性。</p>
<p>如果就这2个方法需要共享变量，为什么不让它们拥有自己的类呢？当丧失了内聚性，就拆分它们为单独的类。将大函数拆分为小函数，往往也是拆分为小类的时机。程序会更多有组织结构。</p>
<h4 id="打印质数实例重构"><a href="#打印质数实例重构" class="headerlink" title="打印质数实例重构"></a>打印质数实例重构</h4><p>原程序只有一个大行数，简直一团糟。很深的缩进结构，冗余的变量，紧密耦合的结构</p>
<p>重构和原程序采用同样算法和机制，重构后程序被拆分为3个权责：</p>
<ul>
<li>PrimePrinter 主程序，权责是处理执行环境，因调用方式而改变，例如程序被转换为SOAP服务，该类会被影响</li>
<li>PrimeGenerator 权责是生成质数列表，因质数算法而改变</li>
<li>RowColumnPagePrinter 权责是格式化数字列表成固定行列的列表，因输出格式而改变</li>
</ul>
<p>代码如下：</p>
<ul>
<li><p>PrimePrinter</p>
<pre><code>public class PrimePrinter {
  public static void main(String[] args) {
    final int NUMBER_OF_PRIMES = 1000;
    int[] primes = PrimeGenerator.generate(NUMBER_OF_PRIMES);

    final int ROWS_PER_PAGE = 50;
    final int COLUMNS_PER_PAGE = 4;
    RowColumnPagePrinter tablePrinter =
      new RowColumnPagePrinter(ROWS_PER_PAGE,
                               COLUMNS_PER_PAGE,
                               &quot;The First &quot; + NUMBER_OF_PRIMES +
                                 &quot; Prime Numbers&quot;);

    tablePrinter.print(primes);
  }
}
</code></pre></li>
<li><p>PrimeGenerator</p>
<pre><code>public class PrimeGenerator {
  private static int[] primes;
  private static ArrayList&lt;Integer&gt; multiplesOfPrimeFactors;

  protected static int[] generate(int n) {
    primes = new int[n];
    multiplesOfPrimeFactors = new ArrayList&lt;Integer&gt;();
    set2AsFirstPrime();
    checkOddNumbersForSubsequentPrimes();
    return primes;
  }

  private static void set2AsFirstPrime() {
    primes[0] = 2;
    multiplesOfPrimeFactors.add(2);
  }

  private static void checkOddNumbersForSubsequentPrimes() {
    int primeIndex = 1;
    for (int candidate = 3;
         primeIndex &lt; primes.length;
         candidate += 2) {
      if (isPrime(candidate))
        primes[primeIndex++] = candidate;
    }
  }

  private static boolean isPrime(int candidate) {
    if (isLeastRelevantMultipleOfNextLargerPrimeFactor(candidate)) {
      multiplesOfPrimeFactors.add(candidate);
      return false;
    }
    return isNotMultipleOfAnyPreviousPrimeFactor(candidate);
  }

  private static boolean
  isLeastRelevantMultipleOfNextLargerPrimeFactor(int candidate) {
    int nextLargerPrimeFactor = primes[multiplesOfPrimeFactors.size()];
    int leastRelevantMultiple = nextLargerPrimeFactor * nextLargerPrimeFactor;
    return candidate == leastRelevantMultiple;
  }

  private static boolean
  isNotMultipleOfAnyPreviousPrimeFactor(int candidate) {
    for (int n = 1; n &lt; multiplesOfPrimeFactors.size(); n++) {
      if (isMultipleOfNthPrimeFactor(candidate, n))
        return false;
      }
    return true;
  }

  private static boolean
  isMultipleOfNthPrimeFactor(int candidate, int n) {
    return
      candidate == smallestOddNthMultipleNotLessThanCandidate(candidate, n);
  }

  private static int
  smallestOddNthMultipleNotLessThanCandidate(int candidate, int n) {
    int multiple = multiplesOfPrimeFactors.get(n);
    while (multiple &lt; candidate)
      multiple += 2 * primes[n];
    multiplesOfPrimeFactors.set(n, multiple);
    return multiple;
  }
}
</code></pre></li>
<li><p>RowColumnPagePrinter</p>
<pre><code>public class RowColumnPagePrinter {
  private int rowsPerPage;
  private int columnsPerPage;
  private int numbersPerPage;
  private String pageHeader;
  private PrintStream printStream;

  public RowColumnPagePrinter(int rowsPerPage,
                              int columnsPerPage,
                              String pageHeader) {
    this.rowsPerPage = rowsPerPage;
    this.columnsPerPage = columnsPerPage;
    this.pageHeader = pageHeader;
    numbersPerPage = rowsPerPage * columnsPerPage;
    printStream = System.out;
  }
  public void print(int data[]) {
    int pageNumber = 1;
    for (int firstIndexOnPage = 0;
         firstIndexOnPage &lt; data.length;
         firstIndexOnPage += numbersPerPage) {
      int lastIndexOnPage =
        Math.min(firstIndexOnPage + numbersPerPage - 1,
                 data.length - 1);
      printPageHeader(pageHeader, pageNumber);
      printPage(firstIndexOnPage, lastIndexOnPage, data);
      printStream.println(&quot;\f&quot;);
      pageNumber++;
    }
  }

  private void printPage(int firstIndexOnPage,
                         int lastIndexOnPage,
                         int[] data) {
    int firstIndexOfLastRowOnPage =
      firstIndexOnPage + rowsPerPage - 1;
    for (int firstIndexInRow = firstIndexOnPage;
         firstIndexInRow &lt;= firstIndexOfLastRowOnPage;
         firstIndexInRow++) {
      printRow(firstIndexInRow, lastIndexOnPage, data);
      printStream.println(&quot;&quot;);
    }
  }

  private void printRow(int firstIndexInRow,
                        int lastIndexOnPage,
                        int[] data) {
    for (int column = 0; column &lt; columnsPerPage; column++) {
      int index = firstIndexInRow + column * rowsPerPage;
      if (index &lt;= lastIndexOnPage)
        printStream.format(&quot;%10d&quot;, data[index]);
    }
  }

  private void printPageHeader(String pageHeader,
                               int pageNumber) {
    printStream.println(pageHeader + &quot; --- Page &quot; + pageNumber);
    printStream.println(&quot;&quot;);
  }

  public void setOutput(PrintStream printStream) {
    this.printStream = printStream;
  }
}
</code></pre></li>
</ul>
<h2 id="10-3-为了修改而组织"><a href="#10-3-为了修改而组织" class="headerlink" title="10.3 为了修改而组织"></a>10.3 为了修改而组织</h2><p>修改将一直持续。每次修改（打开类）都让系统冒着其他部分不能如期望工作的风险。整洁系统必须优化类的组织，降低修改带来的风险</p>
<h3 id="Sql类实例重构"><a href="#Sql类实例重构" class="headerlink" title="Sql类实例重构"></a>Sql类实例重构</h3><pre><code>public class Sql {
  public Sql(String table, Column[] columns);
  public String create();
  public String insert(Object[] fields);
  public String selectAll();
  public String findByKey(String keyColumn, String keyValue);
  public String select(Column column, String pattern);
  public String select(Criteria criteria);
  public String preparedInsert();
  private String columnList(Column[] columns) 
  private String valuesList(Object[] fields, final Column[] columns)
  private String selectWithCriteria(String criteria) 
  private String placeholderList(Column[] columns) 
}
</code></pre><p>原程序存在的问题：</p>
<ul>
<li><p>存在两个修改的理由，说明违反了SRP原则</p>
<p>  每当需要新增支持一种语句（如 update），必须“打开”类进行修改，风险随之而来，可能破坏类中其他代码，必须全面重新测试。</p>
<p>  每当需要更改select查询，也必须“打开”类进行修改。</p>
</li>
<li><p>内聚性不足</p>
<p>  存在类似 <code>selectWithCriteria</code>等 只与 <code>select</code> 有关的是有方法</p>
</li>
</ul>
<p>如果该类无需增加update功能，就该不动Sql类。但是一旦打开了类，就应该马上修正设计方案</p>
<p>重构方案：</p>
<ul>
<li>每个功能拆分为一个权责类。Sql为基类，每个功能都是一个子类。</li>
<li>私有方法放到被使用的类。valuesList方法只在insert中使用了，放到InsertSql中</li>
<li>公共私有方法放到工具类。Where 和 ColumnList</li>
</ul>
<p>代码如下：</p>
<ul>
<li><p>Sql</p>
<pre><code>abstract public class Sql {
   public Sql(String table, Column[] columns) {};
   abstract public String generate();
}
</code></pre></li>
<li><p>CreateSql</p>
<pre><code>class CreateSql extends Sql {
   public CreateSql(String table, Column[] columns) { super(table, columns); }
   @Override public String generate() { return &quot;&quot;; }
}
</code></pre></li>
<li><p>InsertSql</p>
<pre><code>class InsertSql extends Sql {
   public InsertSql(String table, Column[] columns, Object[] fields) { super(table, columns); }
   @Override public String generate() { return &quot;&quot;; }
   private String valuesList(Object[] fields, final Column[] columns) { return &quot;&quot;; }
}
</code></pre></li>
<li><p>Where</p>
<pre><code>class Where {
   public Where(String criteria) {}
   public String generate() { return &quot;&quot;; }
}
</code></pre></li>
<li><p>ColumnList</p>
<pre><code>class ColumnList {
   public ColumnList(Column[] columns) {}
   public String generate() { return &quot;&quot;; }
}
</code></pre></li>
</ul>
<p>当需要增加update是，只需新建UpdateSql类。</p>
<p>重构后的系统，符合单一权责原则SRP，符合 开闭原则OCP</p>
<h3 id="隔离修改"><a href="#隔离修改" class="headerlink" title="隔离修改"></a>隔离修改</h3><p>借助接口和抽象类隔离细节修改带来的影响。</p>
<p>依赖倒置原则DIP：类应当依赖于抽象，而不是依赖于具体细节。</p>
<h1 id="第十一章、-系统"><a href="#第十一章、-系统" class="headerlink" title="第十一章、 系统"></a>第十一章、 系统</h1><h2 id="11-1-如何建造一个城市"><a href="#11-1-如何建造一个城市" class="headerlink" title="11.1 如何建造一个城市"></a>11.1 如何建造一个城市</h2><p>城市能够正常运转是因为城市演化出恰当的抽象等级和模块（供水系统、供电系统、交通、执法、立法等），各组件即便在不了解全局时，都能有效转转</p>
<p>本章讨论的就是如何在较高的抽象层级-系统层级 上保持整洁</p>
<h2 id="11-2-将系统的构造和使用分开"><a href="#11-2-将系统的构造和使用分开" class="headerlink" title="11.2 将系统的构造和使用分开"></a>11.2 将系统的构造和使用分开</h2><p>Separate Constructing a System from Using It</p>
<p>酒店建设时，先搭个框架，起重机升降机附着在外面，工人忙碌其间。建成后，起重机升降机都会消失，酒店变得整洁</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/编程思想/" rel="tag"><i class="fa fa-tag"></i> 编程思想</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/14/编程思想/VO DTO DO PO 概念/" rel="next" title="VO DTO DO PO 概念">
                <i class="fa fa-chevron-left"></i> VO DTO DO PO 概念
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/14/编程思想/分层架构与M-V-X/" rel="prev" title="分层架构与M-V-X">
                分层架构与M-V-X <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="风" />
            
              <p class="site-author-name" itemprop="name">风</p>
              <p class="site-description motion-element" itemprop="description">随心而动，随刃而行</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">310</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">71</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一章、-整洁代码"><span class="nav-number">1.</span> <span class="nav-text">第一章、 整洁代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二章、-有意义的命名"><span class="nav-number">2.</span> <span class="nav-text">第二章、 有意义的命名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-名副其实"><span class="nav-number">3.</span> <span class="nav-text">2.2 名副其实</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-避免误导"><span class="nav-number">4.</span> <span class="nav-text">2.3 避免误导</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-做有意义的区分"><span class="nav-number">5.</span> <span class="nav-text">2.4 做有意义的区分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用读得出来的名称"><span class="nav-number">6.</span> <span class="nav-text">使用读得出来的名称</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-使用可搜索的名称"><span class="nav-number">7.</span> <span class="nav-text">2.6 使用可搜索的名称</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-避免使用编码"><span class="nav-number">8.</span> <span class="nav-text">2.7 避免使用编码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-1-匈牙利命名法"><span class="nav-number">8.1.</span> <span class="nav-text">2.7.1 匈牙利命名法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-2-成员前缀"><span class="nav-number">8.2.</span> <span class="nav-text">2.7.2 成员前缀</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-3-接口和实现"><span class="nav-number">8.3.</span> <span class="nav-text">2.7.3 接口和实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-8-避免思维映射"><span class="nav-number">9.</span> <span class="nav-text">2.8 避免思维映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-9-类名"><span class="nav-number">10.</span> <span class="nav-text">2.9 类名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-10-方法名"><span class="nav-number">11.</span> <span class="nav-text">2.10 方法名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-11-别扮可爱"><span class="nav-number">12.</span> <span class="nav-text">2.11 别扮可爱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-12-每个概念对应一个词"><span class="nav-number">13.</span> <span class="nav-text">2.12 每个概念对应一个词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-13-别用双关语（一个词用于多个概念-目的）"><span class="nav-number">14.</span> <span class="nav-text">2.13 别用双关语（一个词用于多个概念/目的）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-14-使用解决方案领域名称"><span class="nav-number">15.</span> <span class="nav-text">2.14 使用解决方案领域名称</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-15-使用源自所涉问题领域的名称"><span class="nav-number">16.</span> <span class="nav-text">2.15 使用源自所涉问题领域的名称</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-16-添加有意义的语境"><span class="nav-number">17.</span> <span class="nav-text">2.16 添加有意义的语境</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三章、函数"><span class="nav-number"></span> <span class="nav-text">第三章、函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-短小"><span class="nav-number">1.</span> <span class="nav-text">3.1 短小</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#代码块和缩进"><span class="nav-number">1.1.</span> <span class="nav-text">代码块和缩进</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-只做一件事"><span class="nav-number">2.</span> <span class="nav-text">3.2 只做一件事</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-每个函数一抽象层级"><span class="nav-number">3.</span> <span class="nav-text">3.3 每个函数一抽象层级</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自顶向下"><span class="nav-number">3.1.</span> <span class="nav-text">自顶向下</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-switch语句"><span class="nav-number">4.</span> <span class="nav-text">3.4 switch语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-使用描述性的名称"><span class="nav-number">5.</span> <span class="nav-text">3.5 使用描述性的名称</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-函数参数"><span class="nav-number">6.</span> <span class="nav-text">3.6 函数参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-1-一元函数的普遍形式"><span class="nav-number">6.1.</span> <span class="nav-text">3.6.1 一元函数的普遍形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-2-标识参数"><span class="nav-number">6.2.</span> <span class="nav-text">3.6.2 标识参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-3-二元函数"><span class="nav-number">6.3.</span> <span class="nav-text">3.6.3 二元函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-4-三元函数"><span class="nav-number">6.4.</span> <span class="nav-text">3.6.4 三元函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-5-参数对象"><span class="nav-number">6.5.</span> <span class="nav-text">3.6.5 参数对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-6-参数列表"><span class="nav-number">6.6.</span> <span class="nav-text">3.6.6 参数列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-7-动词与关键词"><span class="nav-number">6.7.</span> <span class="nav-text">3.6.7 动词与关键词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输出参数"><span class="nav-number">6.8.</span> <span class="nav-text">输出参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-无副作用"><span class="nav-number">7.</span> <span class="nav-text">3.7 无副作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-分隔指令与查询"><span class="nav-number">8.</span> <span class="nav-text">3.8 分隔指令与查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-9-使用异常代替返回错误码"><span class="nav-number">9.</span> <span class="nav-text">3.9 使用异常代替返回错误码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-1-抽离-try-catch-代码块"><span class="nav-number">9.1.</span> <span class="nav-text">3.9.1 抽离 try/catch 代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-2-错误处理就是一件事"><span class="nav-number">9.2.</span> <span class="nav-text">3.9.2 错误处理就是一件事</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-10-别重复自己"><span class="nav-number">10.</span> <span class="nav-text">3.10 别重复自己</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四章、-注释"><span class="nav-number"></span> <span class="nav-text">第四章、 注释</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第五章、格式"><span class="nav-number">1.</span> <span class="nav-text">第五章、格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第六章、-对象和数据结构-Objects-and-Data-Structures"><span class="nav-number">2.</span> <span class="nav-text">第六章、 对象和数据结构 Objects and Data Structures</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-数据抽象"><span class="nav-number">3.</span> <span class="nav-text">6.1 数据抽象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-数据、对象的反对称性-Anti-Symmetry"><span class="nav-number">4.</span> <span class="nav-text">6.2 数据、对象的反对称性 Anti-Symmetry</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-Law-of-Demeter"><span class="nav-number">5.</span> <span class="nav-text">6.3 Law of Demeter</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#“朋友”类型："><span class="nav-number">5.1.</span> <span class="nav-text">“朋友”类型：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LoD-在设计中的应用"><span class="nav-number">5.2.</span> <span class="nav-text">LoD 在设计中的应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-数据传送对象-Data-Transfer-Objects"><span class="nav-number">6.</span> <span class="nav-text">6.4 数据传送对象 Data Transfer Objects</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第七章、错误处理"><span class="nav-number"></span> <span class="nav-text">第七章、错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-使用异常而非返回码"><span class="nav-number">1.</span> <span class="nav-text">7.1 使用异常而非返回码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-先写-Try—Catch-Finally-语句"><span class="nav-number">2.</span> <span class="nav-text">7.2 先写 Try—Catch-Finally 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-使用不可控异常-unchecked-exception"><span class="nav-number">3.</span> <span class="nav-text">7.3 使用不可控异常 unchecked exception</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-给出异常发生的环境说明"><span class="nav-number">4.</span> <span class="nav-text">7.4 给出异常发生的环境说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-依调用者需要定义异常类"><span class="nav-number">5.</span> <span class="nav-text">7.5 依调用者需要定义异常类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6-定义常规流程"><span class="nav-number">6.</span> <span class="nav-text">7.6 定义常规流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-7-别返回null"><span class="nav-number">7.</span> <span class="nav-text">7.7 别返回null</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-8-别传递null"><span class="nav-number">8.</span> <span class="nav-text">7.8 别传递null</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-9-总结"><span class="nav-number">9.</span> <span class="nav-text">7.9 总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第八章、边界"><span class="nav-number"></span> <span class="nav-text">第八章、边界</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-使用第三方代码"><span class="nav-number">1.</span> <span class="nav-text">8.1 使用第三方代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-浏览和学习边界"><span class="nav-number">2.</span> <span class="nav-text">8.2 浏览和学习边界</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-学习log4j"><span class="nav-number">3.</span> <span class="nav-text">8.3 学习log4j</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-学习性测试的好处不只是免费"><span class="nav-number">4.</span> <span class="nav-text">8.4 学习性测试的好处不只是免费</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-使用尚不存在的代码"><span class="nav-number">5.</span> <span class="nav-text">8.5 使用尚不存在的代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-6-整洁的边界"><span class="nav-number">6.</span> <span class="nav-text">8.6 整洁的边界</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十章、类"><span class="nav-number"></span> <span class="nav-text">第十章、类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-类的组织"><span class="nav-number">1.</span> <span class="nav-text">10.1 类的组织</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-类应该短小"><span class="nav-number">2.</span> <span class="nav-text">10.2 类应该短小</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-1-单一权责原则-SRP"><span class="nav-number">2.1.</span> <span class="nav-text">10.2.1 单一权责原则 SRP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-2-内聚"><span class="nav-number">2.2.</span> <span class="nav-text">10.2.2 内聚</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-3-保持内聚性就会得到许多短小的类"><span class="nav-number">2.3.</span> <span class="nav-text">10.2.3 保持内聚性就会得到许多短小的类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#打印质数实例重构"><span class="nav-number">2.3.1.</span> <span class="nav-text">打印质数实例重构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-3-为了修改而组织"><span class="nav-number">3.</span> <span class="nav-text">10.3 为了修改而组织</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Sql类实例重构"><span class="nav-number">3.1.</span> <span class="nav-text">Sql类实例重构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#隔离修改"><span class="nav-number">3.2.</span> <span class="nav-text">隔离修改</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十一章、-系统"><span class="nav-number"></span> <span class="nav-text">第十一章、 系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1-如何建造一个城市"><span class="nav-number">1.</span> <span class="nav-text">11.1 如何建造一个城市</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2-将系统的构造和使用分开"><span class="nav-number">2.</span> <span class="nav-text">11.2 将系统的构造和使用分开</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">风</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
